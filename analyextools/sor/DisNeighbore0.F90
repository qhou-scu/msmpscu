 !**** DESCRIPTION: _______________________________________________________________________________________
 !                  The program is used to extract the distance between defect atoms and their neast neighbore.
 !                  The program different from DisNeighbore1.F90 is that: DisNeighbore1.F90 calculates the 
 !                  distance between the atoms to the virtual site where defect atoms is.
 !      
 !                  This program ouptut also the displacements of the mass center of the defect atoms. Thus the output
 !                  could be also used for MSD calculations. The extention of files of output is ".DisTracking  "
 !
 !**** NOTE:        The configurations are the TRACK files created by using Trajectories_GPU.F90 (see: Trajectories_GPU.F90)
 !                  If you want extract the displacement of the defect clusters from configurations generated by, 
 !                  for example SUBSTRATE.F90, the program DisTracking0.F90 should be used.            
 !
 !**** USAGE:       _______________________________________________________________________________________
 !                  DisNeighbore.F90.exe -I "filename" -T(est) t1, t2
 !                  OPTIONS
 !                        -T(est) t1, t2:   - the range for the tests to be involved in analysis
 !                  ______________________________________________________________________________________
 !**** HISTORY:
 !                  1st version   2019-09 (Hou Qing Sichuan university)
 !
 !
 !**********************************************************************************
 Program DisNeighbore0_Main
 use MD_SimBoxArray_ToolShell_14_CPU
 implicit none
    type(SimMDCtrl) ::CtrlParam
    type(SimMDBox)  ::SimBox0
    character*256   ::InFname  = "", OutFname="", Fname="", OutFname1="", cmdline 
    character*256   ::GFile0="", GFile1   = "" 

    integer         ::IB, IC0, IC1, IA0, IA, IN, K, hFile, hFile1, I, II, J, NN0, NN1, NS, NP, NNN, CHANGED, IBIN, NBIN, ITIMEPRE, DITIME, LINE
    logical         ::EX0, EX1
    real(KINDDF)    ::LATT, HBS(3), BS(3), LB(3), UB(3), VECT1(3), XP0(3), XP(3), CENTER(3), CENTERDIS(3), EKIN, EPOT, DELT
    integer,      dimension(:), allocatable::IND0, IND, INDP, INDP1, INDP2 
    real(KINDDF), dimension(:), allocatable::DIS
    integer,      dimension(:), allocatable::TimeHis

    integer,      dimension(:), pointer::pIND=>null()
    integer,      dimension(:), pointer::pRec=>null()
    !--- NOTE the variable DefTyp subjected to changes
    integer            ::DEFTYP(mp_MXGROUP) = 2 !  DefTyp=2
    character*256      ::STR 
    character*32       ::tstr(2*mp_MXGROUP)=""
    character*72       ::ofmt

      !*************************************
        call ExtractCmdlineFileNames_Globle_Variables()
        !call get_command(cmdline)
        !I = index(cmdline, gm_ExeName(1:len_trim(gm_ExeName)))
        !I = I+len_trim(gm_ExeName)
        !cmdline = cmdline(I:len_trim(cmdline))
        !call Extract_optstr(cmdline, "-","P", 1, NP, tstr)
        !if(NP .ge. 1) then
        !   DefTyp = ISTR(tstr(1))
        !end if    

        call CommandlineBoxsel(CtrlParam)
        InFname = gm_cfgFileName(1)
        call GetPath(InFname, OutFname)
        call GetFname(InFname, Fname)
        OutFname1 = OutFname(1:len_trim(OutFname)-1)//".DisTracking"
        call AvailableIOUnit(hFile1)
        open(UNIT=hFile1, FILE=OutFname1)
        write(hFile1, fmt="(A7, A7, A9, 10(A15))") "IB", "ICFG", "ITime", "TIME", "X", "Y", "Z", "DISX", "DISY", "DISZ", "EKIN", "EPOT"

        SimBox0%proAutoload = 1
        NBIN = 0
        do IB = CtrlParam%JOBID0, CtrlParam%JOBID1
             !---- LOADING THE RAW DATA
              call STRCATI(GFILE0, InFname, "P", 0, 4)
              call STRCATI(GFILE0, GFILE0, "_", IB,  4)
              inquire(FILE=GFILE0, EXIST=EX0)
              if(.not. EX0) then
                  write(*,*)  'MDPSCU Error: '//GFILE0(1:len_trim(GFILE0))//' not exsit'
                  exit 
               end if
               write(*,*) "Load configuration from ", GFILE0(1:len_trim(GFILE0) )
               call Load_Config_SimMDBox(GFILE0, SimBox0)

              !---- prepair the output
               LATT = SimBox0%RR
               LB = SimBox0%BOXLOW
               UB = SimBox0%BOXUP
               BS = SimBox0%ZL
               HBS = 0.5D0*BS
              
               !---from the fist box, we allocate memories
               if(IB .eq. CtrlParam%JOBID0) then

                  !--- the default number of  defect atom and the nearest neighber
                  NN0 = 1
                  NN1 = 8
                  NNN = NN1*NN0 
                  call Get_StatementList("&NDEF", SimBox0%proKWDStatment, STR, LINE)
                  if(LINE .gt. 0) then
                     call Extract_Numb(STR, mp_MXGROUP+1,I,TSTR)
                     if(I.gt.0) NN0 = IStr(TSTR(1))
                     do J=2, I 
                        DEFTYP(J-1) = IStr(TSTR(J))
                     end do   
                  end if   

                  call Get_StatementList("&NEAREST", SimBox0%proKWDStatment, STR, LINE)
                  if(LINE .gt. 0) then
                     call Extract_Numb(STR, 1,I,TSTR)
                     if(I.gt.0) NN1 = IStr(TSTR(1))
                     NNN = NN0*NN1
                  end if   
                  !--- the number of time steps of recording, and the stepsize in ps 
                  DITIME = 50
                  DELT   = 0.0001D0 
                  call Get_StatementList("&EXTRECORD", SimBox0%proKWDStatment, STR, LINE)
                  if(LINE .gt. 0) then
                     call Extract_Numb(STR, 1,I,TSTR)
                     if(I.gt.0) DITIME = IStr(TSTR(1))
                  end if   
                  call Get_StatementList("&STEPSIZE", SimBox0%proKWDStatment, STR, LINE)
                  if(LINE .gt. 0) then
                     call Extract_Numb(STR, 1,I,TSTR)
                     if(I.gt.0) DELT = DRStr(TSTR(1)) !*CP_S2PS
                  end if   

                  !--- the number of recording
                  NS = SimBox0%NPRT/(NN0*(NN1+1))
                  allocate(DIS(NNN), INDP1(NNN), INDP2(NNN), INDP(NNN), IND0(SimBox0%NPRT), IND(SimBox0%NPRT), TimeHis(NS)) 
                  TimeHis = 0
               end if   
               !--- reorder the index of the neighbors according to the order that they appear
               !--- pIND the index of the neighbors in the original box 
               call GetData_DataPad("IDN", SimBox0%ptrDatPad, pIND)
               IND0 = 0
               K = 0 
               do I=1, SimBox0%NPRT
                  J = pIND(I)
                  if(IND0(J) .le. 0) then
                     K = K + 1
                     IND0(J) = K
                  end if 
                  IND(I) = IND0(J)  
               end do   
               
               !--- to begin out put
               call AvailableIOUnit(hFile)
               GFile1 =  GFILE0(1:len_trim(GFILE0))//".DisNBs0"
               open(UNIT=hFile, FILE=GFile1)
               ITIMEPRE = 0
               IA       = 0
               do IC0 = 1, NS 
                  !--- get the displacement of mass center of the defect, that could be used by
                  !    MSDTraking1.F90 to calculate the MSD of the defect cluster
                  CENTERDIS = 0.D0
                  EKIN      = 0.D0
                  EPOT      = 0.D0
                  do I=1, NN0
                     II = IA + (I-1)*(NN1+1) + 1
                     CENTERDIS = CENTERDIS  + SimBox0%DIS(II,:)
                     EKIN      = EKIN       + SimBox0%EKIN(II)
                     EPOT      = EPOT       + SimBox0%EPOT(II)
                  end do 
                  CENTERDIS(1:3) = CENTERDIS(1:3)/dble(NN0)
                  EKIN           = EKIN/dble(NN0)
                  EPOT           = EPOT/dble(NN0)
   
                  !--- get the position of mass center of the defect
                  CENTER = 0.D0
                  XP0 = SimBox0%XP(IA+1,:)
                  do I=1, NN0
                     II = IA + (I-1)*(NN1+1) + 1
                     XP = SimBox0%XP(II,:)
                     do K=1,3
                        VECT1(K) = XP(K) - XP0(K)
                        if(dabs(VECT1(K)) .GT. HBS(K)) then
                           VECT1(K) = VECT1(K) - DSIGN(BS(K),VECT1(K))
                        end if
                     end do
                     CENTER = CENTER + VECT1 
                  end do
                  CENTER = CENTER/dble(NN0) + XP0
                  do K=1, 3
                     if(CENTER(K) .lt. LB(K)) then
                         CENTER(K) = CENTER(K) + BS(K)
                     else if(CENTER(K) .gt. UB(K)) then
                         CENTER(K) = CENTER(K) - BS(K)
                     endif
                  end do 

                  !--- write out for DisTracking, see also DisTracking0.F90
                  write(hFile1, fmt="(I6,1x,I6, 1x,I8, 1x, 1PE14.6, 1x,8(1pE14.6,1x))") IB, IC0, IC0*DITIME, IC0*(DITIME*DELT), &
                                                   CENTER(1:3)/LATT, CENTERDIS(1:3)/LATT, EKIN*CP_ERGEV, EPOT*CP_ERGEV

                  !--- get the distance from the defect to neighbors
                  IN = 0
                   do II=1, NN0
                      IA0 = IA + 1
                      do I=IA0+1, IA0+NN1
                        VECT1(1:3) = SimBox0%XP(I,:) - SimBox0%XP(IA0,:)
                         do K=1,3
                            if(dabs(VECT1(K)) .GT. HBS(K)) then
                               VECT1(K) = VECT1(K) - DSIGN(BS(K),VECT1(K))
                            end if
                         end do   
                         IN = IN + 1
                         DIS(IN) = dsqrt(sum(VECT1*VECT1))
                         INDP(IN) = IND(I)
                      end do
                      IA = IA + NN1+1
                  end do
                  !--- to check if the neighbors changed
                  !    order INDP in increasing order  
                  INDP2    = SimBox0%NPRT 
                  do I=1, NNN 
                     do J=1, NNN
                        if(INDP2(J) .gt. INDP(I)) then
                           exit
                        end if
                     end do       
                     do K=NNN, J+1, -1
                        INDP2(K) = INDP2(K-1)
                     end do
                     INDP2(J) = INDP(I)
                  end do 

                  CHANGED = 0
                  if(IC0 .gt. 1) then
                     do I=1, NNN
                        if(INDP2(I) .ne. INDP1(I)) then
                           CHANGED = 1
                           exit
                        end if 
                     end do 
                  end if   
                  !--- if chnaged, we add the event to TimeHis 
                  if(CHANGED) then
                     IBIN    = IC0 - ITIMEPRE
                     TimeHis(IBIN) = TimeHis(IBIN) + 1
                     if(NBIN .lt. IBIN) NBIN = IBIN
                     print *, "Change at ", IB, IC0, ITIMEPRE, IBIN, NBIN
                     ITIMEPRE = IC0
                  end if    

                  !write out...
                  write(tstr(1),fmt="(I7)") NNN
                  ofmt ="(I8,1x,"//tstr(1)(1:len_trim(tstr(1)))//"(1pE14.6,1x, I7, 1x), I6)"
                  write(hFile, fmt=ofmt) IC0, (DIS(I)/LATT, INDP(I), I=1, NNN), CHANGED
                  !--- move to next recording
                  !IA    = IA + NN0 + NNN
                  INDP1 = INDP2
               end do !--- end loop for IC0
           close(hFile)
        end do  !--- end loop for IB         
       !***********
         close(hFile1)
         !--- write out the histogram
         call AvailableIOUnit(hFile)
         GFile1 =  OutFname(1:len_trim(OutFname)-1)//".TimeHis1"
         open(UNIT=hFile, FILE=GFile1)
         do IBIN=1, NBIN
            write(hFile,fmt="(I7, 1x, I8, 1x, 1PE14.6, 1x, I8)")  IBIN, IBIN*DITIME, IBIN*(DITIME*DELT), TimeHis(IBIN)
         end do   
         close(hFile)
         if(allocated(DIS))     deallocate(DIS)
         if(allocated(INDP))    deallocate(INDP)
         if(allocated(INDP1))   deallocate(INDP1)
         if(allocated(INDP2))   deallocate(INDP2)
         if(allocated(IND0))    deallocate(IND0)
         if(allocated(IND))     deallocate(IND)
         if(allocated(TimeHis)) deallocate(TimeHis)
     
 
       stop
 End program DisNeighbore0_Main

