 !**** DESCRIPTION: _______________________________________________________________________________________
 !                  The program is to do statistical calcultion on the time intervals betwwen events
 !                  generated by EventSearch_GPU 
 !
 !                  SEE ALSO ____________________________________________________________________________
 !                       EventSearch_GPU.F90
 !
 !
 !**** USAGE:       _______________________________________________________________________________________
 !
 !                  EventSearch_times.F90.exe -s "filename" -T(est) t1, t2, ts -C(fg) c1, c2, cs
 !                  where:
 !                        -s filename:          -  the pathname of files storing the configuration clustering configurations generated by
 !                                                 EventSearch_GPU.exe
 !                  OPTIONS
 !                        -T(est) t1, t2, ts:   - the range for the tests to be involved in analysis
 !                        -C(est) c1, c2, cs:   - the range for the configurations to be involved in analysis
 !
 !                  ______________________________________________________________________________________
 !**** HISTORY:
 !                  version 1st 2019-03 (Hou Qing, Sichuan university)
 !
 !

 module EventSearch_Time_M
 use MD_CONSTANTS
 use MD_TYPEDEF_SimMDBox
 use MD_TYPEDEF_SimMDCtrl
 implicit none
        !--- should be changed according to MD simulation 
        integer::m_DefTyp =2
        integer::m_NBin =10000
        real(kinddf), parameter::m_CA(4) = (/1.D0, 0.75D0, 0.50D0, 0.D0/)
        real(kinddf)::m_HisTW = 50
        real(kinddf)::m_HisDW = 0.1
        real(kinddf)::m_DisTol= 0.2

        !---
        integer,             private ::m_hFileT = 0
        integer,             private ::m_hFileD = 0
        integer,             private ::m_hFileTC = 0
        type(MDRecordStamp), private ::m_StampB1
        type(MDRecordStamp), private ::m_StampB2
        type(SimMDBox),      private ::m_PreSimBoxB1
        type(SimMDBox),      private ::m_PreSimBoxB2
        real(kinddf), dimension(:),   allocatable::m_TimeHis
        real(kinddf), dimension(:),   allocatable::m_DispHis
        real(kinddf), dimension(:),   allocatable::m_BackTHis
        real(kinddf), dimension(:),   allocatable::m_ForwTHis
        real(kinddf), dimension(:,:), allocatable::m_HisByCA        
        
        integer,      dimension(:),   allocatable::m_DefID
 contains

   !**********************************************************************************
   subroutine MyPreRecord(SimBox, CtrlParam)
   !***  PURPOSE:  to initialize the calculation 
   use MD_Globle_Variables
   implicit none
  !----   DUMMY Variables
   type(SimMDBox)  ::SimBox
   type(SimMDCtrl) ::CtrlParam

  !----   Local variables
  character*256 path
  
            
            call GetPath(gm_cfgFileName(1),path)
            !call ExtractExeName_Globle_Variables()
            call AvailableIOUnit(m_hFileT)
            open(UNIT=m_hFileT, FILE=path(1:len_trim(path)-1)//".TimeHis")
            call AvailableIOUnit(m_hFileD)
            open(UNIT=m_hFileD, FILE=path(1:len_trim(path)-1)//".DistHis")
            call AvailableIOUnit(m_hFileTC)
            open(UNIT=m_hFileTC, FILE=path(1:len_trim(path)-1)//".Intervals")
            
            
            m_StampB1%ITime = - 1
            m_StampB1%ITest = 0 
            
            allocate(m_TimeHis(m_NBin), m_BackTHis(m_NBin), m_ForwTHis(m_NBin), m_HisByCA(m_NBin,size(m_CA)+1) )
            allocate(m_DispHis(1000))
            m_TimeHis = 0.D0
            m_DispHis = 0.D0
            m_BackTHis= 0.D0
            m_ForwTHis= 0.D0 
            m_HisByCA=  0.D0
         return
   end subroutine MyPreRecord
  !**********************************************************************************
  !**********************************************************************************
  subroutine MyRecord(Stamp, SimBox, CtrlParam)
  !***  DESCRIPTION: to calcualte and putout the occupation state of lattice and interstials
  !                  identified using method#1
  !
  !    INPUT:  Stamp,       the recoding stamp
  !            SimBox,      the simulation boxs
  !            CtrlParam,   the control parameters for simulation
  !
  implicit none
       !--- dummy variables
       type(MDRecordStamp) ,         intent(in)  ::Stamp
       type(SimMDBox), dimension(:), intent(in)  ::SimBox
       type(SimMDCtrl),              intent(in)  ::CtrlParam
       !--- local variables
       integer::I, K
       !----
       real(KINDDF)::VECT1(3), VECT2(3), BS(3), HBS(3), DISP1, DISP2, LATT, eps=0.01 , CA
       integer::IDT, IDD, RECN=0, IA
       !!!!!!!!!!!!!!!!!!!
       integer::IP, NDEF=0
       save NDEF, LATT, BS, HBS

          if(m_StampB1%ITest .ne. Stamp%ITest .or. &
             any(m_StampB1%IBox .ne. Stamp%Ibox) ) then
             RECN          = 0
             m_StampB1     = Stamp
             m_PreSimBoxB1 = SimBox(1) 
             BS  = SimBox(1)%ZL
             HBS = 0.5D0*BS
             LATT= SimBox(1)%RR
             
             !--- determine ID of defects
             NDEF = count(SimBox(1)%ITYP .eq. m_DefTyp)
             if(.not.allocated(m_DefID)) then
             	  allocate(m_DefID(NDEF))
             	  m_DefID = 0
             end if	 
             
             IP = 0  
             do I=1, SimBox(1)%NPRT
             	  if(SimBox(1)%ITYP(I).eq.m_DefTyp) then
             	  	 IP = IP + 1
             	  	 m_DefID(IP) = I
             	  end if 	
             end do	 
             return
          end if
          
          
          !--- the time diference
          IDT = (Stamp%ITime - m_StampB1%ITime)
          IDT = IDT/m_HisTW + 1
          if(IDT .gt. m_NBin) then
             print *, "Warning :IDT larger than the size of histogram array"  
             call ONWARNING(gm_OnWarning)
          else	if( IDT .le. 0) then
             print *, "Warning :IDT less than zeor"  
             call ONWARNING(gm_OnWarning)
             return
          else  
             m_TimeHis(IDT) = m_TimeHis(IDT) + 1 
          end if
          !--- the distance
          RECN = RECN + 1
          do I=1, NDEF
          	 IP = m_DefID(I)
          	 do K=1,3
          	    VECT1(K) = SimBox(1)%XP(IP,K) -m_PreSimBoxB1%XP(IP,K)
          	    if(dabs(VECT1(K)) .GT. HBS(K)) then
                   VECT1(K) = VECT1(K) - DSIGN(BS(K),VECT1(K))
                end if
             end do
             DISP1 = dsqrt(sum(VECT1*VECT1))*cp_CM2A
             if(DISP1 .gt. m_DisTol) then
                IDD   = DISP1/m_HisDW + 1
                IDD   = min(IDD,size(m_DispHis))
                m_DispHis(IDD) = m_DispHis(IDD) + 1
            else
            	  print *, "DISP1", DISP1
            	  pause    
            end if
          end do  	
          
          !--- update the previous box
          if(RECN .gt. 1) then
             do I=1, NDEF
             	  IP = m_DefID(I)
          	    do K=1,3
          	       VECT2(K) = SimBox(1)%XP(IP,K) -m_PreSimBoxB2%XP(IP,K)
          	       if(dabs(VECT2(K)) .GT. HBS(K)) then
                      VECT2(K) = VECT2(K) - DSIGN(BS(K),VECT2(K))
                   end if
                 end do
                 DISP2 = dsqrt(sum(VECT2*VECT2))*cp_CM2A
                 if(DISP2 .le. m_DisTol) then
                 	  if(IDT .le. m_NBin) m_BackTHis(IDT) = m_BackTHis(IDT) + 1
                 else 	  
                 	  if(IDT .le. m_NBin) m_ForwTHis(IDT) = m_ForwTHis(IDT) + 1
                 end if
                 
                 !---	 
          	     do K=1,3
          	        VECT2(K) = m_PreSimBoxB1%XP(IP,K) -m_PreSimBoxB2%XP(IP,K)
          	        if(dabs(VECT2(K)) .GT. HBS(K)) then
                      VECT2(K) = VECT2(K) - DSIGN(BS(K),VECT2(K))
                    end if
                 end do
                  
             end do  	
             CA =  sum(VECT1/dsqrt(sum(VECT1*VECT1))*VECT2/dsqrt(sum(VECT2*VECT2)))  
             IA = size(m_CA) + 1

             do K=1, size(m_CA) 
             	  if(dabs(m_CA(K) - dabs(CA)) .le. eps) then
             	  	 IA = K
             	  	 exit
             	  end if
             end do    
             m_HisByCA(IDT,IA) = m_HisByCA(IDT,IA) + 1	  
          end if   
          if(RECN .ge. 1) then
          	 if(RECN .gt. 1) then
              	 write(m_hFileTC, fmt="(I4, 1x, I8, 1x, 14(1pE16.7,1x))") &
              	                                          Stamp%ITest, Stamp%IBox(1),              &
              	                                          dble(m_StampB1%ITime - m_StampB2%ITime), &
              	                                          dble(Stamp%ITime - m_StampB1%ITime) ,    &
          	                                              dble(Stamp%ITime - m_StampB2%ITime) ,    &
          	                                              VECT1(1:3)/LATT, VECT2(1:3)/LATT,        &
          	                                              sum(VECT1/dsqrt(sum(VECT1*VECT1))*VECT2/dsqrt(sum(VECT2*VECT2)))
                       	                                              
          	 end if
          	 m_PreSimBoxB2 = m_PreSimBoxB1
          	 m_StampB2     = m_StampB1
          end if	 
          m_PreSimBoxB1 = SimBox(1) 
          m_StampB1     = Stamp
          
 end subroutine MyRecord
 !****************************************************************************

 !**********************************************************************************
   subroutine MyAftRecord(SimBox, CtrlParam)
   !***  PURPOSE:  to initialize the calculation 
   implicit none
  !----   DUMMY Variables
   type(SimMDBox)  ::SimBox
   type(SimMDCtrl) ::CtrlParam

  !----   Local variables
   integer::I
   
          do I=1, size(m_TimeHis)
             write(m_hFileT, fmt="(I8,1x, 14(1pE14.7,1x))") I, m_HisTW*I, m_TimeHis(I),  m_BackTHis(I), m_ForwTHis(I), m_HisByCA(I,1:size(m_CA)+1)
          end do   
          close(m_hFileT)
          
          do I=1, size(m_DispHis)
             write(m_hFileD, fmt="(I8,1x, 4(1pE14.7,1x))") I, m_HisDW*I, m_DispHis(I)
          end do   
          close(m_hFileD)
          close(m_hFileTC)
          
          if(allocated(m_TimeHis)) deallocate(m_TimeHis)
          if(allocated(m_BackTHis)) deallocate(m_BackTHis)
          if(allocated(m_ForwTHis)) deallocate(m_ForwTHis)
          if(allocated(m_DispHis)) deallocate(m_DispHis)
          if(allocated(m_HisByCA)) deallocate(m_HisByCA)  
          
         return
   end subroutine MyAftRecord
  !**********************************************************************************

 end module EventSearch_Time_M

 !**********************************************************************************
 Program EventSearch_Time_Main
 use MD_SimBoxArray_ToolShell_14_CPU
 use EventSearch_Time_M
 implicit none


       call APPSHELL_AddRecord(AFTRECORD=MyAftRecord, PRERECORD=MyPreRecord, RECORDPROC=MyRecord)
       !call APPSHELL_AddRecord(AFTRECORD=MyAftRecord, PRERECORD=MyPreRecord)
       call Multi_ANALYSIS(0,ExitNofile=0)

       stop
 End program EventSearch_Time_Main
