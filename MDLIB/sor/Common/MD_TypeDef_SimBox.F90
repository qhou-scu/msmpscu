  module MD_TYPEDEF_SimMDBox
  !***  DESCRIPTION: this module is to define the data type for Simulation Box.
  !
  !                  ______________________________________________________________________________________
  !**** HISTORY:     2010-03 (HOU Qing), created the first version
  !
  !                  2018-03-22(HOU Qing),
  !                          add DataPad functions for the convience of recording
  !                          extended atomic quantities generated by
  !                          other routines. See also MD_TYPEDEF_DataPad.F90
  !
  !                  2018-04- (HOU Qing),
  !                          correspondingly, the routines for reading configure
  !                          from files in &CFGXYZ format are modified
  !________________________________________________________________________________________________________

  use MD_CONSTANTS
  use MiniUtilities
  use MD_TYPEDEF_RecordStamp
  use MD_TYPEDEF_InputPaser
  use MD_TYPEDEF_DataPad
  implicit none
      !---- parameters could be used for different problems
      integer(KINDINT),  parameter::CP_INPUT_POSONLY    = 0
      integer(KINDINT),  parameter::CP_INPUT_VEL        = 1
      integer(KINDINT),  parameter::CP_INPUT_FOR        = 2
      integer(KINDINT),  parameter::CP_INPUT_SBOXBIT    = 2
      integer(KINDINT),  parameter::CP_INPUT_SBOX       = 2**CP_INPUT_SBOXBIT
      integer(KINDINT),  parameter::CP_INPUT_UNFORMAT   = 2**16
      character*10,      parameter, private::CP_BASICKWD(9)   =&
                                                             (/"&XYZCOL",   &
                                                               "&TYPECOL",  &
                                                               "&VELCOL",   &
                                                               "&FPCOL",    &
                                                               "&DISCOL",   &
                                                               "&EPOTCOL",  &
                                                               "&EKINCOL",  &
                                                               "&STATUCOL", &
                                                               "&STATCOL"/)

      character(len=5),  parameter, private::mp_CTLSTARTFLG = "&BOXF"
      !--- The type of a simulation box
      type::SimMDBox
           real(KINDDF)::RR= -1.D0                                              !lattice legnth in cm, (Astr at inputing)
           real(KINDDF)::LATT(3)=(/0,0,0/)                                      !number of lattices along x, y, z
           real(KINDDF)::BOXSHAPE(3,3)=(/1., 0., 0.,  &                         !box shape, would be used in Rahmann-Parrilino Scheme
                                          0., 1., 0., &
                                          0., 0., 1./)
           real(KINDDF)::ZL(3)   =0.D0                                          !the box siez in cm
           real(KINDDF)::BOXLOW(3) = 1.D64                                      !the low boundary of box
           real(KINDDF)::BOXUP(3) = -1.D64                                      !the up boundary of box: = BOXLOW+ZL

           !---  variables concen with force type
           character*12::POTTYPE = ""                                                ! the type of potentials
           character*128::POTLIBNAME = ""                                            ! the name of potential library
           character*12::POTSUBLIBNAME = ""                                          ! the subname of the potential library


           integer::nPRT = 0                                                         ! the number of particles
           integer::nGroup = 0                                                       ! the number of kinds of particles
           !--- varible concern with groups
           integer,          dimension(mp_MXGROUP)           ::NA = 0                ! number for each kind of atom
           integer,          dimension(mp_MXGROUP+1)         ::IPA = 0               ! flag for each kind of atom
           character(len=8), dimension(mp_MXGROUP)           ::SYMB = ""             ! atomic symbole of atoms
           real(KINDDF),     dimension(mp_MXGROUP)           ::CZ=0.D0               ! atomi number for each kind of atom
           real(KINDDF),     dimension(mp_MXGROUP)           ::CM=0.D0               ! mass for each kind of atom
           integer,          dimension(mp_MXGROUP)           ::PROP=CP_STATU_ACTIVE  ! properties for each kind of atom, for example, could be CP_STATU_FIXPOS to fix the position of the atoms
           integer,          dimension(mp_MXGROUP,mp_MXGROUP)::PTYPE = 0             ! flags to identify atom-atom interactions

           !--- extended properties of the groups

           !--- varibales of atoms
           integer,     dimension(:),   allocatable::ITYP       !The ID of the particles
           real(KINDDF),dimension(:,:), allocatable::XP         !The position of the particles
           real(KINDDF),dimension(:,:), allocatable::XP1        !The velocity of the box
           real(KINDDF),dimension(:,:), allocatable::XP2        !The second order of XP
           real(KINDDF),dimension(:,:), allocatable::XP3        !The third order of XP
           real(KINDDF),dimension(:,:), allocatable::XP4        !The fourth order of XP
           real(KINDDF),dimension(:,:), allocatable::XP5        !The fifith order of XP
           real(KINDDF),dimension(:,:), allocatable::DIS        !The displacement of atoms frtom their initial positions
                                                                !If without periodic condition, DIS should be the same with XP
           integer, dimension(:),       allocatable::STATU      !integers could be used to indicat the staus of the particles


           real(KINDDF),dimension(:,:), allocatable::FP         ! The force on atom
           real(KINDDF),dimension(:),   allocatable::EPOT       ! potential of atoms
           real(KINDDF),dimension(:),   allocatable::EKIN       ! kinetic energy of atoms

           !--- other data to be output in configure files
           !    these data coule be generated of application
           !    routine and added by call Add_DataPad
           type(DataPad), pointer::ptrDatPad =>null()

           !--- thermadynamical varibales of box
           real(KINDDF)::VTENSOR(3,3) = 0                       ! virial tensor
           real(KINDDF)::KTENSOR(3,3) = 0                       ! totoal kinetic energy tensor
           real(KINDDF)::PTENSOR(3,3) = 0                       ! pressure tensor
           real(KINDDF)::TEMPERATURE                            ! temperature
           real(KINDDF)::VOLUME                                 ! volume
           real(KINDDF)::SPRESS0                                ! scalar pressure contributed by kinetic movement
           real(KINDDF)::SPRESS1                                ! scalar pressure contributed by virial
           real(KINDDF)::SPRESS                                 ! total scalar pressure contributed by virial
           real(KINDDF)::AVEPOT                                 ! everage cohesive energy (ev/par)
           real(KINDDF)::HARMIL                                 ! total harmilton


          !--- member variables concerning initial state
          !
          character*260::IniConfig  = ''                       !the file name for initial configuration
          integer::IniCfgFmt        = CP_INPUT_POSONLY         !the file format of initial configuration
          integer::IniCfgID         = 0                        !the configure ID for multiple-configure inupts
                                                               !the input configures are generated by previous calculations    

          !--- member variables concerning initial state
          !
          character*260::TgtConfig  = ''                 !the file name for production configuration, used in NEB applications
          integer::TgtConfigFmt     = CP_INPUT_POSONLY   !the file format of production configuration
          integer::MultiTgtConfig   = 0                  ! determine if use multiple inupt for production configre

          integer::UseUnit = 0                           ! the length unit of initial configure
                                                         ! =0, and default, lattice unit
                                                         ! =1, UNIT unit (the box size is scaled to UNIT)

         !--- abstract additional property data for atoms
         !    that could be used for analysis when data are
         !    loaded from a XYZ format
         !
          type(Statementlist), pointer::proKWDStatment=>null()  !store the statemnet containing keywords from input XYZ files
          type(DataPad),       pointer::proKWDList =>null()     !the keyword of properties required in analysis routines, for exaqmple in clustering
          integer                     ::proAutoLoad=0           !flag to indicate if properties to be automatically load from a XYZ configure file.

      end type SimMDBox



  !--- interface to the external routine -------------------
      interface assignment (=)
          module procedure CopyFrom_SimMDBox
      end interface

  !---------------------------------------------------------
      private:: AccumDatPadD_SimMDBox
      interface AccumDatPad_SimMDBox
          module procedure AccumDatPadD_SimMDBox
      end interface AccumDatPad_SimMDBox

  !---------------------------------------------------------
      private:: AddAtoms_SimMDBox0,  &
                AddAtoms_SimMDBox1
      interface AddAtoms_SimMDBox
          module procedure AddAtoms_SimMDBox0
          module procedure AddAtoms_SimMDBox1
      end interface AddAtoms_SimMDBox

  !---------------------------------------------------------
      private:: Archive_Config_SimMDBox0,  &
                Archive_Config_SimMDBox1
      interface Archive_Config_SimMDBox
           module procedure Archive_Config_SimMDBox0
           module procedure Archive_Config_SimMDBox1
      end interface Archive_Config_SimMDBox

  !---------------------------------------------------------
      private:: CheckForceTableAssigned_SimMDBox0, &
                CheckForceTableAssigned_SimMDBox1
      public::  CheckForceTableAssigned_SimMDBox    
      interface CheckForceTableAssigned_SimMDBox
           module procedure CheckForceTableAssigned_SimMDBox0 
           module procedure CheckForceTableAssigned_SimMDBox1 
      end interface CheckForceTableAssigned_SimMDBox
  !---------------------------------------------------------
      private:: Copy_SimMDBox0, &
                Copy_SimMDBox1, &
                Copy_SimMDBox2
      public::  Copy_SimMDBox
      interface Copy_SimMDBox
          module procedure Copy_SimMDBox0
          module procedure Copy_SimMDBox1
          module procedure Copy_SimMDBox2  
      end interface Copy_SimMDBox

  !---------------------------------------------------------
      public::  CopyInformation_SimMDBox
  !---------------------------------------------------------
      public:: Default_Parameter_SimMDBox

  !---------------------------------------------------------
      private:: Initialize_SimMDBox0, &
                Initialize_SimMDBox1
      public::  Initialize_SimMDBox
      interface Initialize_SimMDBox
          module procedure Initialize_SimMDBox0
          module procedure Initialize_SimMDBox1
      end interface Initialize_SimMDBox

  !---------------------------------------------------------
      private:: Load_Config_SimMDBox0,  &
                Load_Config_SimMDBox1,  &
                Load_Config_SimMDBox2
      public::  Load_Config_SimMDBox
      interface Load_Config_SimMDBox
         module procedure Load_Config_SimMDBox0
         module procedure Load_Config_SimMDBox1
         module procedure Load_Config_SimMDBox2
      end interface Load_Config_SimMDBox       

  !---------------------------------------------------------
      public:: NearestAtomID_SimMDBox

  !---------------------------------------------------------
      private:: NewDatPadType_SimMDBox,  &
                NewDatPadType2_SimMDBox, &
                NewDatPadI_SimMDBox,     &
                NewDatPadI2_SimMDBox,    &
                NewDatPadD_SimMDBox,     &
                NewDatPadD2_SimMDBox
      interface NewDatPad_SimMDBox
          module procedure NewDatPadType_SimMDBox
          module procedure NewDatPadType2_SimMDBox
          module procedure NewDatPadI_SimMDBox
          module procedure NewDatPadI2_SimMDBox
          module procedure NewDatPadD_SimMDBox
          module procedure NewDatPadD2_SimMDBox
      end interface NewDatPad_SimMDBox


  !---------------------------------------------------------
      public:: Release_SimMDBox

  !---------------------------------------------------------
      private:: ReplaceAtomByInd_SimMDBox, &
                ReplaceAtomByPos_SimMDBox
      interface ReplaceAtom_SimMDBox
          module procedure ReplaceAtomByInd_SimMDBox
          module procedure ReplaceAtomByPos_SimMDBox
      end interface ReplaceAtom_SimMDBox

  !---------------------------------------------------------
      private:: Restore_Config_SimMDBox0,  &
                Restore_Config_SimMDBox1
      interface Restore_Config_SimMDBox
           module procedure Restore_Config_SimMDBox0
           module procedure Restore_Config_SimMDBox1
      end interface Restore_Config_SimMDBox       


  !--- end interface to the external routine -------------------

  contains
  !*********************************************************************

  !*********************************************************************
      subroutine Release_SimMDBox(B)
      !
      implicit none
      type(SimMDBox)::B

          B%NPRT   = 0
          B%NGROUP = 0
          B%NA     = 0
          B%IPA    = 0

          B%SYMB = ""
          B%CZ=0.D0
          B%CM=0.D0
          B%PROP=CP_STATU_ACTIVE

          B%PTYPE = 0
          if(allocated(B%ITYP))  deallocate(B%ITYP)
          if(allocated(B%XP))    deallocate(B%XP)
          if(allocated(B%XP1))   deallocate(B%XP1)
          if(allocated(B%XP2))   deallocate(B%XP2)
          if(allocated(B%XP3))   deallocate(B%XP3)
          if(allocated(B%XP4))   deallocate(B%XP4)
          if(allocated(B%XP5))   deallocate(B%XP5)
          if(allocated(B%DIS))   deallocate(B%DIS)
          if(allocated(B%STATU)) deallocate(B%STATU)
          if(allocated(B%FP))    deallocate(B%FP)
          if(allocated(B%EPOT))  deallocate(B%EPOT)
          if(allocated(B%EKIN))  deallocate(B%EKIN)
          call Release_DataPad(B%ptrDatPad)

          call Release_StatementList(B%proKWDStatment)
          call Release_DataPad(B%proKWDList)
      end subroutine Release_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Default_Parameter_SimMDBox(SimBox)
  !***  PURPOSE:   to set the default values for simulation box
  !
  !     INPUT:
  !
  !     OUTPUT     SimBox
  implicit none
     !--- dummy varioables
     type(SimMDBox)::SimBox

     !--- local variables

           call Release_SimMDBox(SimBox)

           SimBox%RR       = -1.D0
           SimBox%LATT     = (/0,0,0/)
           SimBox%BOXSHAPE = 0.D0
           SimBox%BOXSHAPE(1,1) = 1.D0
           SimBox%BOXSHAPE(2,2) = 1.D0
           SimBox%BOXSHAPE(3,3) = 1.D0
           SimBox%ZL       = 0.D0
           SimBox%BOXLOW   = 1.D64
           SimBox%BOXUP(3) = -1.D64

           SimBox%POTTYPE       = ""
           SimBox%POTLIBNAME    = ""
           SimBox%POTSUBLIBNAME = ""

           SimBox%nPRT   = 0
           SimBox%nGroup = 0

           SimBox%VTENSOR = 0
           SimBox%KTENSOR = 0
           SimBox%PTENSOR = 0

           SimBox%IniConfig      = ''
           SimBox%IniCfgFmt      = CP_INPUT_POSONLY
           SimBox%IniCfgID       = 0

           SimBox%TgtConfig      = ''
           SimBox%TgtConfigFmt   = 0
           SimBox%MultiTgtConfig = 0
           SimBox%USEUNIT        = 0

           SimBox%proAutoLoad = 0

          return
  end subroutine Default_Parameter_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Load_Parameter_SimMDBox(hFile, SimBox)
  !***  PURPOSE:   to load the control parameters from a file
  !
  !     INPUT:     hFile,  I/O unit number
  !
  !     OUTPUT     CtrlParam
  implicit none
     !--- dummy varioables
     integer,intent(in)::hFile
     type(SimMDBox)    ::SimBox

     !--- local variables
      integer::LINE
      character*256::STR
      character*32::KEYWORD
     !----

           call GetInputStrLine(hFile,STR, LINE, "!", *100)
           STR = adjustl(STR)
           call GetKeyWord("&", STR, KEYWORD)
           call UpCase(KEYWORD)
           if(KEYWORD(1:LEN_TRIM(KEYWORD)) .NE. mp_CTLSTARTFLG) then
             rewind(hFile)
             !call Load_Parameter_SimMDBox_OLD(hFile, SimBox)
           else
             rewind(hFile)
             call Load_Parameter_SimMDBox_MD0(hFile, SimBox)
           end if
           return
  !---------------------------------------------------------------
  100    WRITE(*,*)"MDPSCU Error in reading box parameters."
         WRITE(*,*)"The process to be stopped."
         stop
  end subroutine Load_Parameter_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Load_BoxParameter_SimMDBox(hFile, SimBox, LINE)
  !***  PURPOSE:   to load the describing parameters of a simulation box
  !
  !     INPUT:     hFile,  I/O unit number
  !
  !     OUTPUT     SimBox
  implicit none
     !--- dummy varioables
     integer, intent(in)   ::hFile
     type(SimMDBox)        ::SimBox
     integer, intent(inout)::LINE

     !--- local variables
      character*256::STR
      character*32::STRNUMB(10), KEYWORD
      integer::I, N

          !**** to start load the box parameters

             do while(.TRUE.)
                call GetInputStrLine(hFile,STR, LINE, "!", *100)
                STR = adjustl(STR)
                call GetKeyWord("&", STR, KEYWORD)
                call UpCase(KEYWORD)
                select case (KEYWORD(1:LEN_TRIM(KEYWORD)) )
                       case( "&ENDSUBCTL")
                                exit

                       case default
                          write(*,*)"MDPSCU warning: unknown keyword in BOXSUBCTL subsection", KEYWORD(1:LEN_TRIM(KEYWORD))
                          write(*,fmt="('               check box file at line:', BZI6)") LINE
                          call ONWARNING(gm_OnWarning)

                       case ("&SIZE")
                              !$$*** To get box size
                               call Extract_Numb(STR,3,n,STRNUMB)
                               if(n .lt. 3) then
                                  write(*,fmt="(' MDPSCU Error: the boxsize should be set in x,y,z directions')")
                                  write(*,fmt="('               check box file at line:', BZI6)") LINE
                                  write(*,fmt="(' Usage: &SIZE bx  ,by , bz ')")
                                  write(*,fmt="(' Process to be stopped')")
                                  stop
                                end if
                                do I=1, 3
                                   SimBox%LATT(I) = DRSTR(STRNUMB(I))
                                end do

                       case ("&LOWB","&BOXLOW")
                              !$$*** To get box size
                               call Extract_Numb(STR,3,n,STRNUMB)
                               if(n .lt. 3) then
                                  write(*,fmt="(' MDPSCU Error: the low-boundary of a box should be set in x,y,z directions')")
                                  write(*,fmt="('               check box file at line:', BZI6)") LINE
                                  write(*,fmt="(' Usage: &LOWB xmi=  ,ymi= , zmi= ')")
                                  write(*,fmt="(' Process to be stopped')")
                                  stop
                                end if
                                do I=1, 3
                                   SimBox%BOXLOW(I) = DRSTR(STRNUMB(I))
                                end do

                        case ("&LATT")
                              !$$*** To get latice length
                               call Extract_Numb(STR,1,N,STRNUMB)
                               SimBox%RR = DRSTR(STRNUMB(1))
                end select
              end do

         return
  !------------------------------------------------------------
  100    WRITE(*,*)"MDPSCU Error in reading simulation box parameters."
         WRITE(*,*)"The process to be stopped."

         stop
  end subroutine Load_BoxParameter_SimMDBox
  !****************************************************************************


  !****************************************************************************
  subroutine Load_AtomParameter_SimMDBox(hFile, SimBox, LINE)
  !***  PURPOSE:   to load the describing parameters of atoms
  !
  !     INPUT:     hFile,  I/O unit number
  !
  !     OUTPUT     SimBox
  implicit none
     !--- dummy varioables
     integer,      intent(in)::hFile
     type(SimMDBox)          ::SimBox
     integer                 ::LINE

     !--- local variables
      character*256::STR,STRTMP(1)
      character*32::STRNUMB(10), KEYWORD
      integer::N, IGROUP

          !**** to start load the group parameters
             IGROUP = 0
             do while(.TRUE.)
                call GetInputStrLine(hFile,STR, LINE, "!", *100)
                STR = adjustl(STR)
                call GetKeyWord("&", STR, KEYWORD)
                call UpCase(KEYWORD)
                select case (KEYWORD(1:LEN_TRIM(KEYWORD)) )
                       case ("&ENDSUBCTL")
                          if(SimBox%NGROUP .lt. 1) then
                              write(*,fmt="(' MDPSCU Error: the number of group is less than 1')")
                              write(*,fmt="('               check box file at line:', BZI6)") LINE
                              write(*,fmt="(' Process to be stopped')")
                              stop
                          end if
                          if(IGROUP.lt.SimBox%NGROUP) then
                              write(*,fmt="(' MDPSCU Error: the number of groups is', I3)") SimBox%NGROUP
                              write(*,fmt="('               only ', I3, ' group parameters have been gievn')") IGROUP
                              write(*,fmt="('               check box file at line:', BZI6)") LINE
                              write(*,fmt="(' Process to be stopped')")
                              stop
                          end if
                          exit

                       case default
                          write(*,*)"MDPSCU warning: unknown keyword in ATOMSUBCTL subsection ", KEYWORD(1:LEN_TRIM(KEYWORD))
                          write(*,fmt="('               check box file at line:', BZI6)") LINE
                          call ONWARNING(gm_OnWarning)

                       case ("&NATOM")
                             !$$*** To get the total number of particles
                              call Extract_Numb(STR,1,N,STRNUMB)
                              if(n .lt. 1 ) then
                                 write(*,fmt="(' MDPSCU Error: the total number of atoms should be given larger than zero')")
                                 write(*,fmt="('               check box file at line:', BZI6)") LINE
                                 write(*,fmt="(' Usage: &NATOM number of atoms')")
                                 write(*,fmt="(' Process to be stopped')")
                                 stop
                               end if
                               SimBox%NPRT = ISTR(STRNUMB(1))

                        case ("&NGROUP")
                              !$$*** To get how many kind of particles concerned
                               call Extract_Numb(STR,1,N,STRNUMB)
                               if(n .lt. 1) then
                                  write(*,fmt="(' MDPSCU Error: the number of groups should be given')")
                                  write(*,fmt="('               check box file at line:', BZI6)") LINE
                                  write(*,fmt="(' Usage: &NGROUPS number of groups')")
                                  write(*,fmt="(' Process to be stopped')")
                                  stop
                                end if
                                SimBox%NGROUP = ISTR(STRNUMB(1))
                                if(SimBox%NGROUP .gt. mp_mxGROUP) then
                                  write(*,fmt="(' MDPSCU Error: the number of groups larger than permitted number:', I4)") mp_mxGROUP
                                  write(*,fmt="('               check box file at line:', BZI6)") LINE
                                  write(*,fmt="(' Process to be stopped')")
                                  stop
                                end if

                                SimBox%NA = 0
                                SimBox%IPA = 0
                                SimBox%PTYPE = 0
                                SimBox%SYMB = ""
                                SimBox%CZ = 0.D0
                                SimBox%CM = 0.D0
                                SimBox%PROP = CP_STATU_ACTIVE

                        case ("&GROUPSUBCTL")
                               if(SimBox%NGROUP .lt. 1) then
                                  write(*,fmt="(' MDPSCU Error: the number of groups is missed. &NGROUP should be given before this line.')")
                                  write(*,fmt="('               check box file at line:', BZI6)") LINE
                                  write(*,fmt="(' Process to be stopped')")
                                  stop
                                end if
                               IGROUP = IGROUP + 1

                               if(IGROUP .gt. SimBox%NGROUP) then
                                  write(*,fmt="(' MDPSCU Error: too many group parameters. NGROUP is only ',I3)") SimBox%NGROUP
                                  write(*,fmt="('               check box file at line:', BZI6)") LINE
                                  write(*,fmt="(' Process to be stopped')")
                                  stop
                                end if

                               call Load_GroupParameter_SimMDBox(hFile, SimBox, IGROUP, LINE)
                end select
              end do
         return
  !------------------------------------------------------------
  100    WRITE(*,*)"MDPSCU Error in reading simulation box parameters."
         WRITE(*,*)"The process to be stopped."
         stop
         return
  end subroutine Load_AtomParameter_SimMDBox
  !****************************************************************************


  !****************************************************************************
  subroutine Load_GroupParameter_SimMDBox(hFile, SimBox, IGROUP, LINE)
  !***  PURPOSE:   to load the describing parameters of atoms
  !
  !     INPUT:     hFile,  I/O unit number
  !
  !     OUTPUT     SimBox
  implicit none
     !--- dummy varioables
     integer, intent(in)::hFile
     type(SimMDBox)     ::SimBox
     integer            ::LINE, IGROUP

     !--- local variables
      character*256::STR,STRTMP(1)
      character*32::STRNUMB(16), KEYWORD
      integer::I, N

          !**** to start load the group parameters
             do while(.TRUE.)
                call GetInputStrLine(hFile,STR, LINE, "!", *100)
                STR = adjustl(STR)
                call GetKeyWord("&", STR, KEYWORD)
                call UpCase(KEYWORD)
                select case (KEYWORD(1:LEN_TRIM(KEYWORD)) )
                       case ("&ENDSUBCTL")
                          exit

                       case default
                          write(*,*)"MDPSCU warning: unknown keyword in GROUPSUBCTL subsection ", KEYWORD(1:LEN_TRIM(KEYWORD))
                          write(*,fmt="('               check box file at line:', BZI6)") LINE
                          call ONWARNING(gm_OnWarning)

                       case ("&NATOM")
                             !$$*** To get the number of particles in group igroup
                              call Extract_Numb(STR,1,N,STRNUMB)
                              if(n .lt. 1 ) then
                                 write(*,fmt="(' MDPSCU Error: the number of atoms in group', I3, 'should be given')") IGROUP
                                 write(*,fmt="('               check box file at line:', BZI6)") LINE
                                 write(*,fmt="(' Usage: &NATOM number of atoms in ther group')")
                                 write(*,fmt="(' Process to be stopped')")
                                 stop
                               end if
                               SimBox%NA(IGROUP) = ISTR(STRNUMB(1) )

                       case ("&ATOMP")
                             !$$*** To get the atomic number and atomic mass of this group
                              call Extract_Numb(STR,2,N,STRNUMB)
                              if(n .lt. 2 ) then
                                 write(*,fmt="(' MDPSCU Error: the atomic number and mass in group', I3, ' should be given')") IGROUP
                                 write(*,fmt="('               check box file at line:', BZI6)") LINE
                                 write(*,fmt="(' Usage: &ATOMP atomic symbol; atomic number; atomic mass; ')")
                                 write(*,fmt="('        atomic symbole shoule in quote')")
                                 write(*,fmt="(' Process to be stopped')")
                                 stop
                               end if
                               SimBox%CZ(IGROUP) = DRSTR(STRNUMB(1))
                               SimBox%CM(IGROUP) = DRSTR(STRNUMB(2))

                               call Extract_Substr(STR,1,N,STRTMP)
                               if(N .lt. 1 ) then
                                 write(*,fmt="(' MDPSCU Error: the atomic symbole in group', I3, ' should be given')") IGROUP
                                 write(*,fmt="('               check box file at line:', BZI6)") LINE
                                 write(*,fmt="(' Usage: &ATOMP atomic symbol; atomic number; atomic mass; ')")
                                 write(*,fmt="('        atomic symbole shoule in quote')")
                                 write(*,fmt="(' Process to be stopped')")
                                 stop
                               end if
                               SimBox%SYMB(IGROUP) = STRTMP(1)(1:len_trim(STRTMP(1)))

                       case ("&STAT")
                             !$$*** To get the atomic n umber and atomic mass of this group
                              call Extract_Substr(STR,16,N,STRNUMB)
                              do I=1, N
                                 call UpCase(STRNUMB(I))
                                 select case(STRNUMB(I))
                                        case ("FIXPOSX")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXPOSX)
                                        case ("FIXPOSY")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXPOSY)
                                        case ("FIXPOSZ")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXPOSZ)
                                        case ("FIXPOS")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXPOS)
                                        case ("FIXVELX")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXVELX)
                                        case ("FIXVELY")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXVELY)
                                        case ("FIXVELZ")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXVELZ)
                                        case ("FIXVEL")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXVELX)
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXVELY)
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FIXVELZ)
                                        case ("ARSEED")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_ARSEEDPART)
                                        case ("FREEPART")
                                             SimBox%PROP(IGROUP) = IOR(SimBox%PROP(IGROUP),CP_STATU_FREEPART)
                                 end select
                              end do
                end select
              end do

              !$$*** check the completeness of the input
              if(len_trim(SimBox%SYMB(IGROUP)) .le. 0 .or. &
                 SimBox%CZ(IGROUP) .le. 0             .or. &
                 SimBox%CM(IGROUP) .le. 0 ) then
                  write(*,fmt="(' MDPSCU Error: the atomic data in group', I3, ' is not completed')") IGROUP
                  write(*,fmt="(' Usage: &ATOMP atomic symbol; atomic number; atomic mass; ')")
                  write(*,fmt="(' Process to be stopped')")
                  stop
              end if
              return
  !------------------------------------------------------------
  100    write(*,*)"MDPSCU Error in reading simulation box parameters."
         write(*,*)"The process to be stopped."
         stop
  end subroutine Load_GroupParameter_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Load_PotlibParameter_SimMDBox(hFile, SimBox, LINE)
  !***  PURPOSE:   to load the describing parameters of atoms
  !
  !     INPUT:     hFile,  I/O unit number
  !
  !     OUTPUT     SimBox
  implicit none
     !--- dummy varioables
     integer, intent(in)::hFile
     type(SimMDBox)     ::SimBox
     integer            ::LINE

     !--- local variables
      character*256::STR
      character*128::STRNUMB(10), KEYWORD, STRTMP(2)
      integer::J, N, IGROUP

          !**** to start load the group parameters
             IGROUP = 0
             do while(.TRUE.)
                call GetInputStrLine(hFile,STR, LINE, "!", *100)
                STR = adjustl(STR)
                call GetKeyWord("&", STR, KEYWORD)
                call UpCase(KEYWORD)
                select case (KEYWORD(1:LEN_TRIM(KEYWORD)) )
                       case ("&ENDSUBCTL")
                          if(any(SimBox%PTYPE .ne. 0) .and. &
                             IGROUP.lt.SimBox%NGROUP) then
                              write(*,fmt="(' MDPSCU Error: the potential table for pairs of atom groups is not completed')")
                              write(*,fmt="('               check box file at line:', BZI6)") LINE
                              write(*,fmt="(' Process to be stopped')")
                              stop
                          end if
                          exit

                       case default
                          write(*,*)"MDPSCU warning: unknown keyword in  POTSUBCTL section", KEYWORD(1:LEN_TRIM(KEYWORD))
                          write(*,fmt="('               check box file at line:', BZI6)") LINE
                          call ONWARNING(gm_OnWarning)

                        case ("&TYPE")
                              !$$*** To get type of the potential
                              call Extract_Substr(STR,1,n,STRTMP)
                              if(N.LT.1) then
                                  write(*,fmt="(' MDPSCU Warning: the type of potential is not given. User self-defined potential to be used')")
                                  write(*,fmt="('               check box file at line:', BZI6)") LINE
                                  write(*,fmt="(' Usage: &POTTYPE symbole for the type of the potential')")
                                  write(*,fmt="('        symbole should be in quotes')")
                                  call ONWARNING(gm_OnWarning)
                               else
                                  SimBox%POTTYPE = adjustl(STRTMP(1)(1:len_trim(STRTMP(1))))
                               end if

                        case ("&LIBNAME")
                              !$$*** To get type of the potential
                              call Extract_Substr(STR,2,n,STRTMP)
                              if(N.LT.1) then
                                  write(*,fmt="(' MDPSCU Warning: the libname of potential is not given. User self-defined potential to be used')")
                                  write(*,fmt="('               check box file at line:', BZI6)") LINE
                                  write(*,fmt="(' Usage: &POTLIB symbole for the libname of the potential')")
                                  write(*,fmt="('        symbole should be in quotes')")
                                  call ONWARNING(gm_OnWarning)
                               else
                                  SimBox%POTLIBNAME = adjustl(STRTMP(1)(1:len_trim(STRTMP(1))))
                                  if(N .GE. 2) then
                                     SimBox%POTSUBLIBNAME = adjustl(STRTMP(2)(1:len_trim(STRTMP(2))))
                                  else
                                     SimBox%POTSUBLIBNAME = ""
                                  end if
                               end if

                        case ("&TABLE")
                              IGROUP = IGROUP + 1
                              call Extract_Numb(STR,SimBox%NGROUP,n,STRNUMB)
                              if(N.LT.SimBox%NGROUP) then
                                 write(*,fmt="(' MDPSCU Error: the number of table columes is smaller than the number of groups')")
                                 write(*,fmt="('               check box file at line:', BZI6)") LINE
                                 write(*,fmt="(' Usage: &TABLE  t_1, t_2, ..., t_ngroup')")
                                 write(*,fmt="(' Process to be stopped')")
                                 stop
                              end if

                              if(IGROUP .le. SimBox%NGROUP) then
                                 do J=1, SimBox%NGROUP
                                    SimBox%PTYPE(IGROUP,J) = ISTR(STRNUMB(J))
                                 end do
                              else
                                 write(*,fmt="(' MDPSCU Warning: the number of table rows is larger than the number of groups')")
                                 write(*,fmt="('               check box file at line:', BZI6)") LINE
                                 call ONWARNING(gm_OnWarning)
                              end if

                end select
              end do
              !$$--- check consistent of potential
              select case(SimBox%POTTYPE(1:len_trim(SimBox%POTTYPE)) )
                     case("FS_TYPE")
                     case("EAM_TYPE")
              end select

         return
  !------------------------------------------------------------
  100    write(*,*)"MDPSCU Error in reading simulation box parameters."
         write(*,*)"The process to be stopped."
         stop
   end subroutine Load_PotlibParameter_SimMDBox
  !****************************************************************************


  !****************************************************************************
  subroutine Load_Parameter_SimMDBox_MD0(hFile, SimBox, LINE0)
  !***  PURPOSE:   to load the describing parameters of a simulation box
  !
  !     INPUT:     hFile,  I/O unit number
  !
  !     OUTPUT     SimBox
  implicit none
     !--- dummy varioables
     integer, intent(in)          ::hFile
     type(SimMDBox)               ::SimBox
     integer, intent(in), optional::LINE0

     !--- local variables
      character*256::STR
      character*32::STRNUMB(30), KEYWORD
      integer::I, J, N, LINE

          if(present(LINE0)) then
             LINE = LINE0
          else
             LINE = 0
          end if

          call GetInputStrLine(hFile,STR, LINE, "!", *100)
          STR = adjustl(STR)
          call GetKeyWord("&", STR, KEYWORD)
          call UpCase(KEYWORD)
          if(KEYWORD(1:LEN_TRIM(KEYWORD)) .EQ. mp_CTLSTARTFLG) then
          !**** to start load the box parameters

             do while(.TRUE.)
                call GetInputStrLine(hFile,STR, LINE, "!", *100)
                STR = adjustl(STR)
                call GetKeyWord("&", STR, KEYWORD)
                call UpCase(KEYWORD)
                select case (KEYWORD(1:LEN_TRIM(KEYWORD)) )
                       case("&ENDBOX")
                            if(SimBox%NGROUP .lt. 1) then
                               write(*,fmt="(' MDPSCU Error: the number of groups is missed.')")
                               write(*,fmt="('               check box file at line:', BZI6)") LINE
                               write(*,fmt="(' Process to be stopped')")
                               stop
                            end if
                            if(any(SimBox%PTYPE(1:SimBox%NGROUP,1:SimBox%NGROUP) .lt. 1)) then
                               if(any(len_trim(SimBox%Symb(1:SimBox%NGROUP)) .le. 0)) then
                               write(*,fmt="(' MDPSCU Error: potential table of atom group pair is not set.')")
                               write(*,fmt="('               add or check &POTSUBCTL subsection.')")
                               write(*,fmt="(' Process to be stopped')")
                               stop
                               end if
                            end if
                            exit

                       case default
                            write(*,*)"MDPSCU warning: unknown keyword ", KEYWORD(1:LEN_TRIM(KEYWORD))
                            write(*,fmt="('               check box file at line:', BZI6)") LINE
                            call ONWARNING(gm_OnWarning)

                       case ("&BOXSUBCTL")
                             call Load_BoxParameter_SimMDBox(hFile, SimBox, LINE)

                       case ("&ATOMSUBCTL")
                             call Load_AtomParameter_SimMDBox(hFile, SimBox, LINE)

                       case ("&POTSUBCTL")
                             if(SimBox%NGROUP .lt. 1) then
                                write(*,fmt="(A)") ' MDPSCU Error: the information of groups is missed. '// &
                                                   '&ATOMSUBCTL should be given before this line.'
                                write(*,fmt="('               check box file at line:', BZI6)") LINE
                                write(*,fmt="(' Process to be stopped')")
                                stop
                              end if
                              call Load_PotlibParameter_SimMDBox(hFile, SimBox, LINE)
                end select
              end do
          end if

          !&&--- Update the flag of groups
          SimBox%IPA(1) = 1
          do I=2,SimBox%NGROUP+1
              SimBox%IPA(I) = SimBox%IPA(I-1)+SimBox%NA(I-1)
          end do
         return
  !------------------------------------------------------------
  100    write(*,*)"MDPSCU Error in reading simulation box parameters."
         write(*,*)"The process to be stopped."
         stop
  end subroutine Load_Parameter_SimMDBox_MD0
  !****************************************************************************

  !****************************************************************************
  subroutine Load_Parameter_SimMDBox_OLD(hFile, SimBox)
  !***  PURPOSE:   to load the describing parameters of a simulation box
  !
  !     INPUT:     hFile,  I/O unit number
  !
  !     OUTPUT     SimBox
  implicit none
     !--- dummy varioables
     integer, intent(in)::hFile
     type(SimMDBox)     ::SimBox

     !--- local variables
      character*256::STR,STRTMP(1)
      character*32::STRNUMB(30)
      integer::I, J, N, LINE

       LINE = 0
       !$$*** To get box size
         call GetInputStrLine(hFile,STR, LINE, "!", *100)
         call Extract_Numb(STR,3,n,STRNUMB)
         do I=1, 3
            SimBox%LATT(I) = DRSTR(STRNUMB(I))
         end do

      !$$*** To get latice length
         call GetInputStrLine(hFile,STR, LINE, "!", *100)
         call Extract_Numb(STR,1,N,STRNUMB)
         SimBox%RR = DRSTR(STRNUMB(1))

      !$$*** To get the total number of particles
         call GetInputStrLine(hFile,STR, LINE, "!", *100)
         call Extract_Numb(STR,1,N,STRNUMB)
         SimBox%NPRT = ISTR(STRNUMB(1))

      !$$*** To get how many kind of particles concerned
         call GetInputStrLine(hFile,STR, LINE, "!", *100)
         call Extract_Numb(STR,1,N,STRNUMB)
         SimBox%NGROUP = ISTR(STRNUMB(1))

      !$$*** To allocate memory and initialize for the nGroup
         SimBox%NA = 0
         SimBox%IPA = 0
         SimBox%PTYPE = 0
         SimBox%CZ = 0.D0
         SimBox%CM = 0.D0
         SimBox%SYMB = ""
         SimBox%PROP = CP_STATU_ACTIVE

      !$$*** To get information for each kind of particle
         do I=1, SimBox%NGROUP
            call GetInputStrLine(hFile,STR, LINE, "!", *100)
            call Extract_Numb(STR,4,n,STRNUMB)
            if(n .lt. 3) then
               write(*,*)"MDPSCU Error: information for atom type",I, " missed"
               write(*,*)"       The process to be stopped."
               stop
            end if
            SimBox%NA(I) = ISTR(STRNUMB(1) )
            SimBox%CZ(I) = DRSTR(STRNUMB(2))
            SimBox%CM(I) = DRSTR(STRNUMB(3))
            if(n.ge. 4) then
               SimBox%PROP(I) = IOR(SimBox%PROP(I),ISTR(STRNUMB(4)) )
            end if

            call Extract_Substr(STR,1,n,STRTMP)
            SimBox%SYMB(I) = STRTMP(1)(1:len_trim(STRTMP(1)))

            !if(SimBox%NA(I) .GT. 0) SimBox%nNGroup = SimBox%nNGroup + 1
         end do

      !$$*** To check if the input data is self-consistent
         if(sum(SimBox%NA) .NE. SimBox%NPRT) then
            write(*,*)"MDPSCU Error: the sum of particle number not equal to:",SimBox%NPRT
            write(*,*)"       The process to be stopped."
            stop
         end if

         SimBox%IPA(1) = 1
         do I=2,SimBox%NGROUP+1
               SimBox%IPA(I) = SimBox%IPA(I-1)+SimBox%NA(I-1)
         end do

      !$$*** To get information about potentials for atom-pairs
         do I=1, SimBox%NGROUP
            call GetInputStrLine(hFile,STR, LINE, "!", *100)
            call Extract_Numb(STR,SimBox%NGROUP,n,STRNUMB)
            do J=1, SimBox%NGROUP
               SimBox%PTYPE(I,J) = ISTR(STRNUMB(J))
            end do
         end do

      !$$*** To get initial file name
      !$$    NOTE: if the initial file name has been given
      !$$    in setup file, we skip this.
      !$$
      !$$     See Initialize_Globle_Variables( SimBox, CtrlParam, CtrlFile, printlog)
         if(len_trim(SimBox%IniConfig) .gt. 0) goto 200
         call GetInputStrLine(hFile,STR, LINE, "!", *200)
         call Extract_Substr(STR,1,n,STRTMP)
         if(n .gt. 0) then
            SimBox%IniConfig = STRTMP(1)
         end if

         call Extract_Numb(STR,1,n,STRNUMB)
         if(n .gt. 0) then
            SimBox%IniCfgID = ISTR(STRNUMB(1))
         end if


      !$$*** To check what kind of length unit to be used
         call GetInputStrLine(hFile,STR, LINE, "!", *200)
         call Extract_Numb(STR,SimBox%NGROUP,n,STRNUMB)
         SimBox%USEUNIT = ISTR(STRNUMB(1))

      !$$*** To get format information of the intial file
         SimBox%IniCfgFmt = CP_INPUT_POSONLY
         call GetInputStrLine(hFile,STR, LINE, "!", *200)
         call Extract_Substr(STR,1,n,STRTMP)
         if(n .gt. 0) then
            call UpCase(STRTMP(1))
            if(STRTMP(1) .eq. "UNFORMATTED") then
               SimBox%IniCfgFmt = ior(SimBox%IniCfgFmt, CP_INPUT_UNFORMAT)
            end if
         end if

      !$$*** To check if initial velocity needed to be input
         call GetInputStrLine(hFile,STR, LINE, "!", *200)
         call Extract_Substr(STR,1,n,STRTMP)
         if(n .gt. 0) then
            call UpCase(STRTMP(1))
            if(STRTMP(1) .eq. "YES") then
               SimBox%IniCfgFmt = ior(SimBox%IniCfgFmt,  CP_INPUT_VEL)
            end if
         end if

      !$$*** To check if initial force needed to be input
         call GetInputStrLine(hFile,STR, LINE, "!", *200)
         call Extract_Substr(STR,1,n,STRTMP)
         if(n .gt. 0) then
            call UpCase(STRTMP(1))
            if(STRTMP(1) .eq. "YES") then
               SimBox%IniCfgFmt = ior(SimBox%IniCfgFmt, CP_INPUT_FOR)
            end if
         end if

  200    return
  !------------------------------------------------------------
  100    write(*,*)"MDPSCU Error in reading simulation box parameters."
         write(*,*)"The process to be stopped."
         stop
  end subroutine Load_Parameter_SimMDBox_OLD
  !****************************************************************************

  !****************************************************************************
  subroutine Print_Parameter_SimMDBox(hFile, SimBox)
  !***  PURPOSE:   to printout the describing parameters of a simulation box
  !
  !     INPUT:     hFile,  I/O unit number
  !
  !     OUTPUT     SimBox
  implicit none
     !--- dummy varioables
     integer, intent(in)::hFile
     type(SimMDBox)     ::SimBox

     !--- local variables
      integer::I, J
      character(len=2)::SYMB1, SYMB2

       !$$**** HEADER
         write(hFile,*) "!************ BOX INFORMATION **********"

       !$$*** box size
         write(hFile,FMT="(' !    Box size (in LU)............................: ', 3(F8.2,1x))")  SimBox%LATT(1:3)
         if(any(SimBox%BOXLOW .gt. 1.D32)) then
            write(hFile,FMT="(' !    Box low-bound (in LU).......................: ', 3(F8.2,1x))")  -SimBox%LATT(1:3)*C_HALF
         else
            write(hFile,FMT="(' !    Box low-bound (in LU).......................: ', 3(F8.2,1x))")   SimBox%BOXLOW(1:3)
         end if

      !$$*** To get latice length
         write(hFile,FMT="(' !    Lattice lenght (in A).......................: ', 3(F8.2,1x))")  SimBox%RR

      !$$*** To get the total number of particles
         write(hFile,FMT="(' !    Number of atoms.............................: ', 3(I8,1x))")  SimBox%NPRT

      !$$*** To get how many kind of particles concerned
         write(hFile,FMT="(' !    Number of atom groups ......................: ', 3(I8,1x))")  SimBox%NGROUP
         write(hFile,*)

      !$$*** To get information for each kind of particle
         do I=1, SimBox%NGROUP
            write(hFile,FMT="(' !      Number of atoms in group ', I2,' ..............:',1x, I8)") I,  SimBox%NA(I)
            write(hFile,FMT="(' !         with atomic symbol ....................: ',A4)")  SimBox%SYMB(I)
            write(hFile,FMT="(' !              atomic number ....................:',I3)")   int(SimBox%CZ(I)+0.000001)
            write(hFile,FMT="(' !              atomic mass ......................:',F6.2)") SimBox%CM(I)
            write(hFile,FMT="(' !              fixed position in (x,y,z).........:',3(L5))")                                &
                                                                iand(SimBox%PROP(I), CP_STATU_FIXPOSX).eq.CP_STATU_FIXPOSX, &
                                                                iand(SimBox%PROP(I), CP_STATU_FIXPOSY).eq.CP_STATU_FIXPOSY, &
                                                                iand(SimBox%PROP(I), CP_STATU_FIXPOSZ).eq.CP_STATU_FIXPOSZ
         end do
         write(hFile,fmt="(' !')")

      !$$*** To get information about potentials for atom-pairs
         if(len_trim(SimBox%POTTYPE) .gt. 0) then
            write(hFile,FMT="(' !      Type of potential to be used ................:',1x, A10)") SimBox%POTTYPE(1:len_trim(SimBox%POTTYPE))
            write(hFile,FMT="(' !           potential libname ......................:',1x, A20)") SimBox%POTLIBNAME(1:len_trim(SimBox%POTLIBNAME))
         else
            write(hFile,FMT="(' !      User supplied potential is expected to be used ')")
         end if

         do I=1, SimBox%NGROUP
            do J=1, SimBox%NGROUP
               if(SimBox%PTYPE(I,J) .gt. 0) then
                  write(hFile,FMT="(' !    Potential table ID between group',I2,' and group',I2,': ', I2)") &
                                      I, J, SimBox%PTYPE(I,J)
               else
                  call Extract_SubSymb(SimBox%Symb(I), SYMB1)
                  call Extract_SubSymb(SimBox%Symb(J), SYMB2)
                  write(hFile,FMT="(' !    Potential table ID between group',I2,' and group',I2,': ', A)")  &
                                      I, J, '"'//SYMB1(1:len_trim(SYMB1))//"<-"//SYMB2(1:len_trim(SYMB2))//'"'
               end if
            end do
         end do
         write(hFile,fmt="(' !')")


         return
  end subroutine Print_Parameter_SimMDBox
  !****************************************************************************

    !****************************************************************************
  subroutine Initialize_SimMDBox0(NP, SimBox, Scheme)
   !***  PURPOSE:   to initialize simulation box by allocating memories required
   !
   !     INPUT:    NPRT, the size of arraies to be allocated
   !               Scheme, optional, indicating what kind of differential scheme to be use
   !                       in the evolution calculation
   !
   !     OUTPUT    SimBox,    the simulation box
   !    
   !     NOTE:     NPRT must >= current number of atoms (SimBox%NPRT)
   !
   implicit none
      !--- dummy vaiables
        integer          ::NP
        type(SimMDBox)   ::SimBox
        integer,optional ::Scheme
 
      !--- local variables
          integer::I, J, NPRT, IP, ERR
 
          !$$**** To allocate memory for the simulation system
           NPRT = max(NP, SimBox%NPRT)
           if(NPRT .le. 0) return
           
           if(present(Scheme)) then
            ERR = scheme
           else
            ERR = 2 
           end if 
           if(ERR .le. 2) then
               allocate(SimBox%EPOT(NPRT), SimBox%EKIN(NPRT), SimBox%ITYP(NPRT),  &
                        SimBox%XP(NPRT,3), SimBox%XP1(NPRT,3),SimBox%FP(NPRT,3),  &
                        SimBox%DIS(NPRT,3),SimBox%STATU(NPRT), STAT=ERR )
           else
               allocate(SimBox%EPOT(NPRT), SimBox%EKIN(NPRT), SimBox%ITYP(NPRT),  &
                        SimBox%XP(NPRT,3), SimBox%XP1(NPRT,3),SimBox%XP2(NPRT,3), &
                        SimBox%XP3(NPRT,3),SimBox%XP4(NPRT,3), SimBox%XP5(NPRT,3),SimBox%FP(NPRT,3),&
                        SimBox%DIS(NPRT,3),SimBox%STATU(NPRT), STAT=ERR)
           end if
 
           if(ERR) then
              write(*,fmt="(A,A)")        ' MDPSCU Error: fail to allocate memory in initializing a SimBox '
              write(*,fmt="(A)")          '               Process to be stopped'
              stop
           end if
 
           SimBox%EPOT = 0.D0
           SimBox%EKIN = 0.D0
           SimBox%XP   = 0.D0
           SimBox%XP1  = 0.D0
           SimBox%FP   = 0.D0
           SimBox%DIS  = 0.D0
 
           if(allocated(SimBox%XP2)) SimBox%XP2 = 0.D0
           if(allocated(SimBox%XP3)) SimBox%XP3 = 0.D0
           if(allocated(SimBox%XP4)) SimBox%XP4 = 0.D0
           if(allocated(SimBox%XP5)) SimBox%XP5 = 0.D0
 
           SimBox%EPOT = 0.D0
           SimBox%EKIN = 0.D0
 
          !$$--- if we do not have group information we return
           if(SimBox%NGROUP .le. 0) then
              SimBox%ITYP = 0
              SimBox%STATU = CP_STATU_ACTIVE
              return
           else 
             if(sum(SimBox%NA) .gt. SimBox%NPRT) then
                SimBox%ITYP  = 1
                SimBox%STATU = CP_STATU_ACTIVE
                SimBox%NA    = 0
                SimBox%NA(1) = SimBox%NPRT
                return
             end if
           end if 
           !$$--- we give the default itype for the atoms
           !$$    the ITYP will be overwrited in initialzing configure
           IP = 0
           SimBox%IPA(1) = 1
           do I=1, SimBox%NGROUP
              do J=1, SimBox%NA(I)
                 IP = IP + 1
                 SimBox%ITYP(IP) = I
                 SimBox%STATU(IP) = SimBox%PROP(I)
              end do
              SimBox%IPA(I+1) = IP+1
           end do
 
           return
   end subroutine Initialize_SimMDBox0
   !****************************************************************************

  !****************************************************************************
  subroutine Initialize_SimMDBox1(SimBox, Scheme)
  !***  PURPOSE:   to initialize simulation box by allocating memories required
  !
  !     INPUT:    Scheme, optional, indicating what kind of differential scheme to be use
  !                       in the evolution calculation
  !
  !     OUTPUT    SimBox,    the simulation box
  implicit none
     !--- dummy vaiables
       type(SimMDBox)::SimBox
       integer       ::Scheme

     !--- local variables

         !$$**** To allocate memory for the simulation system
          call Initialize_SimMDBox0(SimBox%NPRT, SimBox, Scheme)

          return
  end subroutine Initialize_SimMDBox1
  !****************************************************************************

  !****************************************************************************
  subroutine Initialize_Config_SimMDBox(SimBox, fname, fmt)
  !***  PURPOSE:   to initialize configuration by create a new or
  !                restore a configuration from previous calcualtion.
  !                The configuration to be read from file SimBox%IniConfig.
  !
  !     INPUT:    fname, optional the file storing the configuration
  !
  !     OUTPUT    SimBox,    the simulation box
  implicit none
     !--- dummy vaiables
       type(SimMDBox)         :: SimBox
       character*(*), optional:: fname
       integer,       optional:: FMT

     !--- local variables
       logical::EX
       integer::afmt
       character*256::filename
       type(MDRecordStamp)::STAMP

       !$$-- if we have the file name given, change the IniConfig file to
       !$$   the given file name
       if(present(fname)) then
          filename = fname
       else
          filename =SimBox%IniConfig
       end if

       if(present(fmt)) then
          afmt = fmt
       else
          afmt = SimBox%IniCfgFmt
       end if

       !$$-- to check if the file existing
       inquire(FILE=filename, EXIST=EX)
       if(.not.EX) then
          write(*,*) "MDPSCU Error: cannot find initial configuration file ", filename(1:len_TRIM(filename))
          STOP
       end if

       !$$-- to automatically determine the format of file
       call Read_Initial_Config_SimMDBox(Simbox, filename, aFmt, mod=3)
  
       return
  end subroutine Initialize_Config_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Read_Initial_Config_SimMDBox(Simbox, fname, fmt, mod)
  !***  PURPOSE:   to read in initial configuration of a simulation box
  !     INPUT:     fname,  the filename storing the configuration
  !                fmt,    the format of storage
  !                mod,    optional, indicating if the number of atoms in the initial configure
  !                        is defferent from input Simbox%nprt, Simbox%nprt will be replaced
  !                        by the number of atom in the initial configure
  !
  !     OUTPUT     Simbox, the simulation box
      implicit none
      !--- DUMMY variables
      type(SimMDBox)           :: SimBox
      character*(*), intent(in):: fname
      integer,       intent(in):: fmt
      integer,       optional  :: mod
      !--- local variables
      integer:: hFile, LINE, I, N, COL(3)
      character*256::TSTR
      character*32::KEYWORD0, KEYWORD1, STRNUMB(30)

       call AvailableIOUnit(hFile)
       open(unit=hFile, file=fname, status='old')
       !--- to find out if the header
        LINE = 0
        call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
        TSTR = adjustl(TSTR)
        call GetKeyWord("&", TSTR, KEYWORD0)
        call UpCase(KEYWORD0)
        select case(KEYWORD0(1:LEN_TRIM(KEYWORD0)))
            case(PKW_OUTCFG_FORMAT14, PKW_OUTCFG_FORMAT15,PKW_OUTCFG_FORMAT16, PKW_OUTCFG_FORMAT18)
                 !--- load confiuration created by MDPSCU simulations
                 !--- skip the header firstly
                 !--- read in header of file and check the number of atoms is consistent
                 !    change of number of atoms is not allowed
                 rewind(hFile)
                 LINE  = 0
                 call Read_ConfigFileHeader_SimMDBox(Simbox, hFile, LINE, CFG=KEYWORD0)

                 rewind(hFile)
                 LINE  = 0
                 do while(.true.)  !skip the header
                    call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
                    TSTR = adjustl(TSTR)
                    call GetKeyWord("&", TSTR, KEYWORD1)
                    call UpCase(KEYWORD1)
                    if(KEYWORD1(1:LEN_TRIM(KEYWORD1)) .EQ. "&TYPE") exit
                 end do

                 if(present(mod)) then
                    call Read_Initial_Config_SimMDBox0(Simbox, hFile, fmt, LINE, mod)
                 else
                    call Read_Initial_Config_SimMDBox0(Simbox, hFile, fmt, LINE)
                 end if
                 !--- NOTE: for PKW_OUTCFG_FORMAT18, the unit of velocity and force
                 !          needed to be converted to CGS
                 if(KEYWORD0(1:LEN_TRIM(KEYWORD0)) .eq.  PKW_OUTCFG_FORMAT18) then
                    if(iand(fmt,CP_INPUT_VEL) .gt. C_IZERO) &
                       Simbox%XP1 = Simbox%XP1*SimBox%RR*CP_S2PS
                 end if


            case(PKW_OUTCFG_FORMATXYZ)
                 rewind(hFile)
                 !$$--- XYZCOL is always needed
                 call AddDataProKWD_SimMDBox(Simbox, "XYZCOL")
                 if(present(mod)) then
                    call Read_ConfigByCol18_SimMDBox(Simbox, hFile, mod)
                 else
                    call Read_ConfigByCol18_SimMDBox(Simbox, hFile)
                 end if

            case default
                !--- load confiuration without header
                !    skip the discription line, if there is
                 if(len_trim(KEYWORD0) .gt. 0) then
                    write(*,fmt="(A,A)")        ' MDPSCU Error: unknown file format: ', KEYWORD0(1:len_trim(KEYWORD0))
                    write(*,fmt="(A,A, A, I5)") '               check file ', fname(1:len_trim(fname)), ' at line:', LINE
                    write(*,fmt="(A)")          '               process to be stopped'
                    stop
                 end if
                 rewind(hFile)
                 do I=1, LINE -1
                    read(hFile,*) TSTR
                 end do
                 if(present(mod)) then
                    call Read_Initial_Config_SimMDBox0(Simbox, hFile, fmt, LINE, mod)
                 else
                    call Read_Initial_Config_SimMDBox0(Simbox, hFile, fmt, LINE)
                 end if
        end select
       close(hFile)
       return

  100  close(hFile)
       write(*,fmt="(A)") ' MDPSCU Error: error at loading from the initial configure file.'
       write(*,fmt="(A)") '               process to be stopped'
       stop

  end subroutine Read_Initial_Config_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Load_Config_SimMDBox0(hFile, Simbox)
  !***  PURPOSE:   to load configuration of a simulation box, the difference between this
  !                and  Read_Initial_Config_SimMDBox is that, the BOX data such as
  !                the lattice length, boxsize etc, are load from the confguration
  !                files.  Read_Initial_Config_SimMDBox is used for constructing
  !                the initial configuration on the beginging of MD simulations.
  !                Load_Config_SimMDBox is uded for the convenience in analysis routine
  !                when only single configuration file is used.
  !
  !     INPUT:     hFile,  the I/O unit
  !
  !     OUTPUT     Simbox, the simulation box
  !
      implicit none
      !--- DUMMY variables
      integer,        intent(in):: hFile
      type(SimMDBox)            :: SimBox
      !--- local variables
      integer::LINE, I, J, IP, N, EXT
      real(KINDDF)::ENERGY
      character*256::TSTR
      character*32::KEYWORD, KEYWORD1, STRNUMB(2)
      character*1::TFMT

        !--- to find out if the header
        LINE = 0
        rewind(hFile)
        call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
        TSTR = adjustl(TSTR)
        call GetKeyWord("&", TSTR, KEYWORD)
        call UpCase(KEYWORD)

        select case(KEYWORD(1:LEN_TRIM(KEYWORD)))
            case(PKW_OUTCFG_FORMAT14, PKW_OUTCFG_FORMAT15,PKW_OUTCFG_FORMAT16)
                 !--- load confiuration created by MDPSCU simulations
                 !--- load the box information first
                 rewind(hFile)
                 Simbox%NPRT = 0
                 call Read_ConfigFileHeader_SimMDBox(Simbox, hFile, LINE, CFG=KEYWORD)
                 rewind(hFile)

                 LINE  = 0
                 do while(.true.)  !skip the header
                    call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
                    TSTR = adjustl(TSTR)
                    call GetKeyWord("&", TSTR, KEYWORD1)
                    call UpCase(KEYWORD1)
                    if(KEYWORD1(1:LEN_TRIM(KEYWORD1)) .EQ. "&TYPE") exit
                 end do
                 if( KEYWORD(1:LEN_TRIM(KEYWORD)) .eq. PKW_OUTCFG_FORMAT14) then
                   do I=1, SimBox%NPRT
                       LINE = LINE + 1
                       read(hFile,*, ERR=100) SimBox%ITYP(I), SimBox%XP(I,1:3), SimBox%XP1(I,1:3), SimBox%STATU(I), SimBox%fP(I,1:3), &
                            SimBox%EPOT(I), SimBox%EKIN(I), SimBox%DIS(I,1:3)
                   end do
                 else
                   do I=1, SimBox%NPRT
                       LINE = LINE + 1
                       read(hFile,*, ERR=100) SimBox%ITYP(I), SimBox%XP(I,1:3), SimBox%XP1(I,1:3), SimBox%STATU(I), SimBox%fP(I,1:3), &
                            SimBox%EPOT(I), SimBox%EKIN(I), ENERGY, SimBox%DIS(I,1:3)
                   end do
                 end if
                 do I=1, SimBox%NGROUP
                     SimBox%NA(I) = count(SimBox%ITYP.eq.I)
                 end do
                 !$$--- change the UNIT back to CGS
                 SimBox%XP(1:SimBox%NPRT,1:3) = SimBox%XP(1:SimBox%NPRT,1:3)*SimBox%RR
                 SimBox%DIS(1:SimBox%NPRT,1:3)= SimBox%DIS(1:SimBox%NPRT,1:3)*SimBox%RR
                 SimBox%EPOT(1:SimBox%NPRT)   = -SimBox%EPOT(1:SimBox%NPRT)/CP_ERGEV
                 SimBox%EKIN(1:SimBox%NPRT)   = SimBox%EKIN(1:SimBox%NPRT)/CP_ERGEV

            case(PKW_OUTCFG_FORMAT18, PKW_OUTCFG_FORMATXYZ)
                 !--- load confiuration created by MDPSCU simulations
                 !--- load the box information first
                 !--- Simbox%NPRT = 0 to eliminate the warning message when Simbox%NPRT
                 !    is not the same as read in NATOM
                 rewind(hFile)
                 LINE        = 0
                 Simbox%NPRT = 0
                 call Read_ConfigFileHeader_SimMDBox(Simbox, hFile, LINE, CFG=KEYWORD)

                 !--- check and add the exist of extent data pad
                 if(SimBox%proAutoload .gt. 0) then
                    rewind(hFile)
                    LINE = 0
                    do while(.true.)
                       call GetInputStrLine(hFile, TSTR, LINE, "!",*100)
                       TSTR = adjustl(TSTR)
                       call GetKeyWord("&", TSTR, KEYWORD1)
                       if(len_trim(KEYWORD1) .le. 0) exit

                       if(IsBasicKWD(KEYWORD1)) cycle
                       if(SameFirstWord(KEYWORD1(len_trim(KEYWORD1)-2:len_trim(KEYWORD1)), 'COL')) then
                          call Extract_Numb(TSTR, 2, N, STRNUMB)
                          if(N .ge. 2) then
                             EXT =ISTR(STRNUMB(2))
                          else
                             EXT = 1
                          end if
                          call Extract_Substr(TSTR, 1, N, STRNUMB)
                          TFMT = STRNUMB(1)(1:1)
                          call GetFirstWord(TSTR, KEYWORD1)
                          !$$--- TFMT is empty, not datapad to be added
                          !$$
                          call NewDatPad_SimMDBox(Simbox, KEYWORD1(2:len_trim(KEYWORD1)-3), TFMT, EXT)
                       end if
                    end do
                 end if
                 !$$--- to begin read the configure
                 rewind(hFile)
                 call Read_ConfigByCol18_SimMDBox(SimBox, hFile, mod=0)
                 if(KEYWORD(1:LEN_TRIM(KEYWORD)) .eq. PKW_OUTCFG_FORMAT18) then
                   !$$--- change the unit back to CGS in CFGFMT18
                   !$$    in Read_ConfigByCol18_SimMDBox, the lenght unit
                   !$$    has been read in and changed to CGS
                   SimBox%XP    = SimBox%XP*SimBox%RR
                   SimBox%DIS   = SimBox%DIS*SimBox%RR
                   SimBox%XP1   = SimBox%XP1*SimBox%RR*CP_S2PS
                   SimBox%FP    = SimBox%FP*CP_EVERG/SimBox%RR
                   SimBox%EPOT  = SimBox%EPOT*CP_EVERG
                   SimBox%EKIN  = SimBox%EKIN*CP_EVERG
                 end if
        end select
        return

  100  close(hFile)
       write(*,fmt="(A)") ' MDPSCU Error: error at loading from a configure file: '
       write(*,fmt="(A, I6)") '               at line:  ', LINE
       write(*,fmt="(A)") '               process to be stopped'
       stop

  end subroutine Load_Config_SimMDBox0
  !****************************************************************************

  !****************************************************************************
  subroutine Load_Config_SimMDBox1(fname, Simbox)
  !***  PURPOSE:   to load configuration of a simulation box, the difference between this
  !                and  Read_Initial_Config_SimMDBox is that, the BOX data such as
  !                the lattice length, boxsize etc, are load from the confguration
  !                files.  Read_Initial_Config_SimMDBox is used for constructing
  !                the initial configuration on the beginging of MD simulations.
  !                Load_Config_SimMDBox is uded for the convenience in analysis routine
  !                when only single configuration file is used.
  !
  !     INPUT:     fname,     the filename storing the configuration
  !
  !     OUTPUT     Simbox, the simulation box
  !
      implicit none
      !--- DUMMY variables
      character*(*), intent(in):: fname
      type(SimMDBox)           :: SimBox
      !--- local variables
      integer::LINE
      character*256::TSTR
      character*32::KEYWORD

      integer:: hFile

       call AvailableIOUnit(hFile)
       open(unit=hFile, file=fname, status='old')
       LINE = 0
       call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
       TSTR = adjustl(TSTR)
       call GetKeyWord("&", TSTR, KEYWORD)
       call UpCase(KEYWORD)

       select case(KEYWORD(1:LEN_TRIM(KEYWORD)))
           case(PKW_OUTCFG_FORMAT14, PKW_OUTCFG_FORMAT15,PKW_OUTCFG_FORMAT16)
           case(PKW_OUTCFG_FORMAT18, PKW_OUTCFG_FORMATXYZ)
           case default
               !--- load confiuration without header
               !    skip the discription line, if there is
                if(len_trim(KEYWORD) .gt. 0) then
                   write(*,fmt="(A,A)")        ' MDPSCU Error: unsupportted file format : ', KEYWORD(1:len_trim(KEYWORD))// &
                                                ' in Load_Config_SimMDBox'
                else
                   write(*,fmt="(A,A)")        ' MDPSCU Error: file format is unknown', &
                                                ' in Load_Config_SimMDBox'
                end if
                write(*,fmt="(A,A, A, I5)") '               check file ', fname(1:len_trim(fname)), ' at line:', LINE
                write(*,fmt="(A)")          '               process to be stopped'
                stop
       end select

       rewind(hFile)
       call Load_Config_SimMDBox0(hFile, Simbox)
       close(hFile)
       return

  100  close(hFile)
       write(*,fmt="(A)") ' MDPSCU Error: error at loading from a configure file: ', Fname(1:len_trim(Fname))
       write(*,fmt="(A, I6)") '               at line:  ', LINE
       write(*,fmt="(A)") '               process to be stopped'
       stop

  end subroutine Load_Config_SimMDBox1
  !****************************************************************************

  !****************************************************************************
  subroutine Load_Config_SimMDBox2(fname, Simbox, Stamp)
  !***  PURPOSE:   to load configuration of a simulation box, the difference between this
  !                and  Read_Initial_Config_SimMDBox is that, the BOX data such as
  !                the lattice length, boxsize etc, are load from the confguration
  !                files.  Read_Initial_Config_SimMDBox is used for constructing
  !                the initial configuration on the beginging of MD simulations.
  !                Load_Config_SimMDBox is uded for the convenience in analysis routine
  !                when only single configuration file is used.
  !
  !     INPUT:     fname,     the filename storing the configuration
  !
  !     OUTPUT     Simbox, the simulation box
  !
      implicit none
      !--- DUMMY variables
      character*(*),       intent(in) :: fname
      type(SimMDBox)                  :: SimBox
      type(MDRecordStamp), intent(out):: Stamp
      !--- local variables
      integer:: hFile
      integer::LINE
      character*256::TSTR
      character*32::KEYWORD

       call AvailableIOUnit(hFile)
       open(unit=hFile, file=fname, status='old')
       LINE = 0
       call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
       TSTR = adjustl(TSTR)
       call GetKeyWord("&", TSTR, KEYWORD)
       call UpCase(KEYWORD)

       select case(KEYWORD(1:LEN_TRIM(KEYWORD)))
           case(PKW_OUTCFG_FORMAT14, PKW_OUTCFG_FORMAT15,PKW_OUTCFG_FORMAT16)
           case(PKW_OUTCFG_FORMAT18, PKW_OUTCFG_FORMATXYZ)
           case default
               !--- load confiuration without header
               !    skip the discription line, if there is
                if(len_trim(KEYWORD) .gt. 0) then
                   write(*,fmt="(A,A)")        ' MDPSCU Error: unsupportted file format : ', KEYWORD(1:len_trim(KEYWORD))// &
                                                ' in Load_Config_SimMDBox'
                else
                   write(*,fmt="(A,A)")        ' MDPSCU Error: file format is unknown', &
                                                ' in Load_Config_SimMDBox'
                end if
                write(*,fmt="(A,A, A, I5)") '               check file ', fname(1:len_trim(fname)), ' at line:', LINE
                write(*,fmt="(A)")          '               process to be stopped'
                stop
       end select
  
       rewind(hFile)
       call Putin_RecordStamp(hFile, Stamp)
       
       rewind(hFile)
       call Load_Config_SimMDBox0(hFile, Simbox)
       close(hFile)
       return

  100  close(hFile)
       write(*,fmt="(A)") ' MDPSCU Error: error at loading from a configure file: ', Fname(1:len_trim(Fname))
       write(*,fmt="(A, I6)") '               at line:  ', LINE
       write(*,fmt="(A)") '               process to be stopped'
       stop
  end subroutine Load_Config_SimMDBox2
  !****************************************************************************

  !****************************************************************************
  subroutine Check_Config_Consistent_SimMDBox(Simbox, mod)
  !***  PURPOSE:   to check if the type of atoms are consistent with
  !                the set in a simulation box. It is assumed that
  !                the atoms are grouped in an incremental manner.
  !
  !     INPUT:     Simbox, the simulation box
  !                mod,    optional, indicating if the statu of groups in the configure
  !                        is different from Simbox%NA, Simbox%IPA,  is change
  !                        is permitted.
  !
  !     OUTPUT     Simbox, the simulation box, if changes are made.
      implicit none
      !--- DUMMY variables
      type(SimMDBox)   ::SimBox
      integer, optional::mod
      !--- local variables
      integer::I, J, IP, FLAG, FLAG1, ITYPmx, NA(mp_mxGROUP)=0
      type(SimMDBox), pointer::swapSimBox=>null()

         !--- check input consistent
           NA  = 0
           FLAG = 0
           FLAG1  = 0
           ITYPmx = SimBox%ITYP(1)
           do I=1,SimBox%NPRT
              if( SimBox%ITYP(I) .gt. mp_MXGROUP) then
                  write(*,fmt="(A, I8, A, I3)") ' MDPSCU Error: the type ID of atom #', I, &
                                                ' in the configuration larger than the permitted number of groups:',&
                                                mp_MXGROUP
                  write(*,fmt="(A)")            '               Process to be stopped'
                  stop
               end if
               if( SimBox%ITYP(I) .gt. SimBox%NGROUP) then
                  if(present(mod)) then
                     if(mod .gt. 0) then
                        if(IAND(mod, 2) .gt. 0) then
                           write(*,fmt="(A, I3, A, I3, A, I8)") &
                                                ' MDPSCU Warning: the type ID of atom #', I, &
                                                ' in the configuration larger then number of groups', SimBox%NGROUP
                           call ONWARNING(gm_OnWarning)
                        else
                           write(*,fmt="(A, I3, A, I3, A, I8)") &
                                                ' MDPSCU Warning: the type ID of atom #', I, &
                                                ' in the configuration larger then number of groups', SimBox%NGROUP
                           write(*,fmt="(A)")   '                  Process to be stopped'
                           stop
                        end if
                     else !--- for mod = 0 change NA witout message
                        SimBox%NGROUP = max(SimBox%NGROUP, SimBox%ITYP(I))
                     end if
                  else !--- if mod is not present, we perform stop
                      write(*,fmt="(A, I3, A, I3, A, I8)") &
                                                ' MDPSCU Warning: the type ID of atom #', I, &
                                                ' in the configuration larger then number of groups', SimBox%NGROUP
                      write(*,fmt="(A)")        '                  Process to be stopped'
                      stop
                  end if
               end if

               !$$--- count number of atom in a group
               NA(SimBox%ITYP(I)) =  NA(SimBox%ITYP(I)) + 1
               if(SimBox%ITYP(I) .lt. ITYPmx) then
                  FLAG1 = 1
               else
                  ITYPmx = SimBox%ITYP(I)
               end if
           end do

           do I=1, SimBox%NGROUP
              if(NA(I) .ne. SimBox%NA(I)) then
                 if(present(mod)) then
                    if(mod .gt. 0) then
                      if(IAND(mod, 2) .gt. 0) then
                         write(*,fmt="(A, I3, A, I8, A, I8)") &
                                                ' MDPSCU Warning: the number of atoms in group', I, &
                                                ' is not equal to the number set in BOXFILE:', NA(I), ' vs ', SimBox%NA(I)
                         write(*,fmt="(A)")     '                 re-grouping of atoms will be performed'

                         call ONWARNING(gm_OnWarning)
                         FLAG = 1
                      else !--- for do the change without wraning messasge
                         !write(*,fmt="(A, I3, A, I8, A, I8)") &
                         !                       ' MDPSCU Error: the number of atoms in group', I, &
                         !                       ' is not equal to the number set in BOXFILE:', NA(I), ' vs ', SimBox%NA(I)
                         !write(*,fmt="(A)")        '                  Process to be stopped'
                         !stop
                      end if
                    else !--- for mod = 0 change NA witout message
                      SimBox%NA(I) = NA(I)
                    end if
                 else !--- if mod is not present, we perform stop
                     write(*,fmt="(A, I3, A, I8, A, I8)") &
                                                ' MDPSCU Error: the number of atoms in group', I, &
                                                ' is not equal to the number set in BOXFILE:', NA(I), ' vs ', SimBox%NA(I)
                     write(*,fmt="(A)")        '                  Process to be stopped'
                     stop
                 end if
              end if
           end do

           !--- FLAG eq 0 indicating FLAG1 > 0 indeicate the number of atomis of each
           !    of each kind is OK, but the order is not consistent
           if(FLAG .eq. 0 .and. FLAG1 .gt. 0) then
              if(present(mod) ) then
                 if(mod .gt. 0) then
                    if(iand(mod,2) .gt. 0) then
                       write(*,fmt="(A)")   ' MDPSCU Warning: the atoms in initial configuration is not grouped'&
                                          // ' in an incremental order. The atoms to be re-grouped in an incremental order'
                       call ONWARNING(gm_OnWarning)
                    else !--- for do the change without wraning messasge
                       !write(*,fmt="(A)")         '                  change of the grouping status is not allowed'
                       !write(*,fmt="(A)")         '                  Process to be stopped'
                       !stop
                    end if
                 end if
              else
                    write(*,fmt="(A)")         '                  change of the grouping status is not allowed'
                    write(*,fmt="(A)")         '                  Process to be stopped'
                    stop
              end if
           end if

           if(present(mod)) then
           if(mod .gt. 0 .and. (FLAG .gt. 0 .or. FLAG1.gt.0)) then
              !$$--- allocate memory for a swap SimBox by call copy_
              allocate(swapSimBox)
              call Copy_SimMDBox(SimBox, swapSimBox)
              swapSimBox%NA = NA
              swapSimBox%IPA(1) = 1
              do I=1, SimBox%NGROUP
                 IP = swapSimBox%IPA(I)-1
                 do J=1, SimBox%NPRT
                    if(SimBox%ITYP(J) .eq. I) then
                       IP = IP + 1
                       swapSimBox%ITYP(IP) = I
                       swapSimBox%XP(IP,1:3)    = SimBox%XP(J, 1:3)
                       swapSimBox%XP1(IP,1:3)   = SimBox%XP1(J,1:3)
                       if(allocated(swapSimBox%XP2)) then
                          swapSimBox%XP2(IP,1:3)   = SimBox%XP2(J,1:3)
                          swapSimBox%XP3(IP,1:3)   = SimBox%XP3(J,1:3)
                          swapSimBox%XP4(IP,1:3)   = SimBox%XP4(J,1:3)
                          swapSimBox%XP5(IP,1:3)   = SimBox%XP5(J,1:3)
                       end if
                       swapSimBox%DIS(IP,1:3)   = SimBox%DIS(J,1:3)
                       swapSimBox%FP(IP,1:3)    = SimBox%FP(J,1:3)
                       swapSimBox%EPOT(IP)      = SimBox%EPOT(J)
                       swapSimBox%EKIN(IP)      = SimBox%EKIN(J)
                      ! if(allocated(swapSimBox%proTable)) then
                      !    swapSimBox%proTable(IP, :) = SimBox%proTable(J,:)
                      ! end if
                    end if
                 end do
                 swapSimBox%IPA(I+1) = IP + 1
              end do
              !$$--- copy the swap Simbox back
              call Copy_SimMDBox(swapSimBox, SimBox)
              call Release_SimMDBox(swapSimBox)
              deallocate(swapSimBox)
              swapSimBox => null()
           end if
           end if

           return
  end subroutine Check_Config_Consistent_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Read_Initial_Config_SimMDBox0(Simbox, hFile, fmt, Line, mod)
  !***  PURPOSE:   to read in initial configuration of a simulation box.
  !                The format of the file is:
  !                col #1 is type of atoms
  !                col #2-3 are the positions of atoms
  !                col #4-5 (optional) are velocities of atoms.
  !                The unit of the position will be changed into cm.
  !
  !     INPUT:     hfile,  the I/O unit for reading the configuration
  !                fmt,    the format of storage
  !                mod,    optional, indicating if the number of atoms in the initial configure
  !                        is defiiference from input Simbox%nprt, Simbox%nprt will be changed
  !                        the number of atom in the initial configure
  !     OUTPUT     Simbox, the simulation box
      implicit none
      !--- DUMMY variables
      type(SimMDBox)::SimBox

      integer, intent(in)::hFile
      integer, intent(in)::fmt
      integer            ::Line
      integer, optional  ::mod

      !--- local variables
      integer::I, J, IP, NA(mp_mxGROUP), IPA(mp_mxGROUP+1), NOUT
      real(KINDDF)::UNIT(3)
      character*1::tinput=""
      save::tinput


          if(SimBox%USEUNIT .EQ. C_IZERO) then
             UNIT =  SimBox%RR
          end if

          if(iand(fmt,CP_INPUT_VEL) .gt. C_IZERO) then
             do I=1,SimBox%NPRT
                read(hFile,*, end=100) SimBox%ITYP(I),SimBox%XP(I,1:3), SimBox%XP1(I,1:3)
                Line = Line + 1
             end do
          else
             do I=1,SimBox%NPRT
                read(hFile,*,end=100) SimBox%ITYP(I),SimBox%XP(I,1:3)
                Line = Line + 1
             end do
          end if

         if(present(mod)) then
            call Check_Config_Consistent_SimMDBox(Simbox, mod)
         else
            call Check_Config_Consistent_SimMDBox(Simbox)
         end if
         !---  convert unit
          SimBox%XP(1:SimBox%NPRT, 1) = SimBox%XP(1:SimBox%NPRT, 1)*unit(1)
          SimBox%XP(1:SimBox%NPRT, 2) = SimBox%XP(1:SimBox%NPRT, 2)*unit(2)
          SimBox%XP(1:SimBox%NPRT, 3) = SimBox%XP(1:SimBox%NPRT, 3)*unit(3)
          !--- update the proprerty of atoms acoording its type
          NOUT = 0
          do I=1,SimBox%NPRT
             SimBox%STATU(I) = SimBox%PROP(SimBox%ITYP(I))
             if( SimBox%XP(I,1) .lt. SimBox%BOXLOW(1) .or. SimBox%XP(I,1).gt.SimBox%BOXLOW(1) + SimBox%ZL(1) .or. &
                 SimBox%XP(I,2) .lt. SimBox%BOXLOW(2) .or. SimBox%XP(I,2).gt.SimBox%BOXLOW(2) + SimBox%ZL(2) .or. &
                 SimBox%XP(I,3) .lt. SimBox%BOXLOW(3) .or. SimBox%XP(I,3).gt.SimBox%BOXLOW(3) + SimBox%ZL(3) ) then
                 if(tinput(1:1) .ne. 'C') then
                    write(*,fmt="(A, I8, A)") " MDPSCU Error: particle ",I," is out of box in the initial configuration"
                    write(*,fmt="(A, 1PE12.5,1PE12.5, A, 1PE12.5)") "               box range x ", &
                            SimBox%BOXLOW(1)/unit(1), (SimBox%BOXLOW(1)+SimBox%ZL(1))/unit(1), ", particle x ", SimBox%XP(I,1)/unit(1)
                    write(*,fmt="(A, 1PE12.5,1PE12.5, A, 1PE12.5)") "               box range y ", &
                            SimBox%BOXLOW(2)/unit(2), (SimBox%BOXLOW(2)+SimBox%ZL(2))/unit(2), ", particle y ", SimBox%XP(I,2)/unit(2)
                    write(*,fmt="(A, 1PE12.5,1PE12.5, A, 1PE12.5)") "               box range z ", &
                            SimBox%BOXLOW(3)/unit(3), (SimBox%BOXLOW(3)+SimBox%ZL(3))/unit(3), ", particle z ", SimBox%XP(I,3)/unit(3)

                    write(*,fmt="(A)")"You can input 'C' to marked all out-of-box atoms as inactive and continue the process."
                    write(*,fmt="(A)")"Or input Enter to stop the process:"
                    read(*, fmt="(A1)") tinput
                    if(tinput(1:1) .eq. 'c') tinput(1:1) = 'C'
                    if(tinput(1:1) .ne. 'C') then
                       write(*,fmt="(A)")"Process to be stopped"
                       stop
                    end if
                 endif
                 SimBox%STATU(I) = CP_STATU_OUTOFBOX
                 NOUT = NOUT + 1
             end if

             !$$--- if velocity is inputed, we need to check if atom properti is fix
             if(iand(SimBox%STATU(I), CP_STATU_FIXPOSX) .eq. CP_STATU_FIXPOSX) SimBox%XP1(I,1) = 0.D0
             if(iand(SimBox%STATU(I), CP_STATU_FIXPOSY) .eq. CP_STATU_FIXPOSY) SimBox%XP1(I,2) = 0.D0
             if(iand(SimBox%STATU(I), CP_STATU_FIXPOSZ) .eq. CP_STATU_FIXPOSZ) SimBox%XP1(I,3) = 0.D0
          end do
          if(NOUT .gt. 0) then
             write(*,fmt="(A, I8, A)") " MDPSCU Warning: there are ",NOUT," atoms out of box found in initial configuration."
          end if
        return

    !--- line is less then expected number of atoms
    100 if(present(mod)) then
           if(mod .gt. 0) then
              SimBox%NPRT = I-1
              if(IAND(mod,2) .eq. 0) then
                !--- give a warning message wihtout stop
                write(*,fmt="(A, I8, A)") ' MDPSCU Warning: only ',SimBox%NPRT, ' atoms loaded from the initial configure file'
                write(*,fmt="(A)")        '                 number of atom in the simulation box has been changed'
                call ONWARNING(gm_OnWarning)
              end if
              call Check_Config_Consistent_SimMDBox(Simbox, mod)

              !---  convert unit
              SimBox%XP(1:SimBox%NPRT, 1) = SimBox%XP(1:SimBox%NPRT, 1)*unit(1)
              SimBox%XP(1:SimBox%NPRT, 2) = SimBox%XP(1:SimBox%NPRT, 2)*unit(2)
              SimBox%XP(1:SimBox%NPRT, 3) = SimBox%XP(1:SimBox%NPRT, 3)*unit(3)
              !--- update the proprerty of atoms acoording its type
              NOUT = 0
              do I=1,SimBox%NPRT
                 SimBox%STATU(I) = SimBox%PROP(SimBox%ITYP(I))
                 if( SimBox%XP(I,1) .lt. SimBox%BOXLOW(1) .or. SimBox%XP(I,1).gt.SimBox%BOXLOW(1) + SimBox%ZL(1) .or. &
                     SimBox%XP(I,2) .lt. SimBox%BOXLOW(2) .or. SimBox%XP(I,2).gt.SimBox%BOXLOW(2) + SimBox%ZL(2) .or. &
                     SimBox%XP(I,3) .lt. SimBox%BOXLOW(3) .or. SimBox%XP(I,3).gt.SimBox%BOXLOW(3) + SimBox%ZL(3) ) then
                     if(tinput(1:1) .ne. 'C') then
                        write(*,fmt="(A, I8, A)") " MDPSCU Error: particle ",I," is out of box in the initial configuration"
                        write(*,fmt="(A, 1PE12.5,1PE12.5, A, 1PE12.5)") "               box range x ", &
                                SimBox%BOXLOW(1)/unit(1), (SimBox%BOXLOW(1)+SimBox%ZL(1))/unit(1), ", particle x ", SimBox%XP(I,1)/unit(1)
                        write(*,fmt="(A, 1PE12.5,1PE12.5, A, 1PE12.5)") "               box range y ", &
                                SimBox%BOXLOW(2)/unit(2), (SimBox%BOXLOW(2)+SimBox%ZL(2))/unit(2), ", particle y ", SimBox%XP(I,2)/unit(2)
                        write(*,fmt="(A, 1PE12.5,1PE12.5, A, 1PE12.5)") "               box range z ", &
                                SimBox%BOXLOW(3)/unit(3), (SimBox%BOXLOW(3)+SimBox%ZL(3))/unit(3), ", particle z ", SimBox%XP(I,3)/unit(3)

                        write(*,fmt="(A)")"You can input 'C' to marked all out-of-box atoms as inactive and continue the process."
                        write(*,fmt="(A)")"Or input Enter to stop the process:"
                        read(*, fmt="(A1)") tinput
                        if(tinput(1:1) .eq. 'c') tinput(1:1) = 'C'
                        if(tinput(1:1) .ne. 'C') then
                            write(*,fmt="(A)")"Process to be stopped"
                            stop
                         end if
                     endif
                     SimBox%STATU(I) = CP_STATU_OUTOFBOX
                     NOUT = NOUT + 1
                 end if
                 !$$--- if velocity is inputed, we need to check if atom property is fixed
                 if(iand(SimBox%STATU(I), CP_STATU_FIXPOSX) .eq. CP_STATU_FIXPOSX) SimBox%XP1(I,1) = 0.D0
                 if(iand(SimBox%STATU(I), CP_STATU_FIXPOSY) .eq. CP_STATU_FIXPOSY) SimBox%XP1(I,2) = 0.D0
                 if(iand(SimBox%STATU(I), CP_STATU_FIXPOSZ) .eq. CP_STATU_FIXPOSZ) SimBox%XP1(I,3) = 0.D0
              end do
              if(NOUT .gt. 0) then
                 write(*,fmt="(A, I8, A)") " MDPSCU Warning: there are ",NOUT," atoms out of box found in initial configuration."
              end if
              return
           end if
        end if

   !--- modification of number of atoms is not allowed, stop the process
    200 write(*,fmt="(A, I8, A)") ' MDPSCU Error: only ',I-1, ' atoms loaded from the initial configure file.'
        write(*,fmt="(A, I8, A)") '               but number of atoms in BOX setup is', SimBox%NPRT
        write(*,fmt="(A, I8, A)") '               check your BOX setup file and initial configure'
        write(*,fmt="(A)")        '               process to be stopped'
        stop
  end subroutine Read_Initial_Config_SimMDBox0
  !****************************************************************************

  !****************************************************************************
  subroutine Read_ConfigFileHeader_SimMDBox(Simbox, hFile, LINE, CFG, mod)
  !***  PURPOSE:   to read in the head of a configuration of a simulation box
  !                in &CFGXYZ or in &BOXCFG14 format. Consistent between
  !                the parameters in Simbox and input values are checked.
  !
  !                This routine can be used in MD simulations to load initial
  !                configurations, and also in analysis routines in which need
  !                only one configuration is needed.
  !
  !     INPUT:     hfile,  the I/O unit for reading the configuration
  !                CFG,    the format of the files
  !                mod,    optional, indicating if the number of atoms in the initial configure
  !                        is defferent from input Simbox%nprt, Simbox%nprt will be replaced
  !                        by the number of atom in the initial configure.
  !                        > 0, changed is permitted, =1, give s warning message without stop
  !                             =2, no warning message without stop
  !                        <=0, change if not permitted
  !
  !     OUTPUT     Simbox, the simulation box with the positions of atoms updated
  !                LINE,   the number of lines that the header has
  !
      implicit none
      !--- DUMMY variables
      integer, intent(in)::hFile
      integer            ::LINE
      character*(*)      ::CFG
      integer, optional  ::mod
      type(SimMDBox)     ::SimBox

      !--- local variables
      character*256::TSTR
      character*32::KEYWORD, STRNUMB(5), UNIT(1)
      integer:: N, NATOM, NGROUP, NA(mp_MXGROUP), SKIP, SKIP1
      real(KINDDF)::LU, BOXLOW(3), BOXSIZE(3)
      type(StatementList), pointer::KWDS


      !---
           BOXLOW   = 1.D64
           BOXSIZE  = -1.D0
           NATOM    = 0
           NGROUP   = 0
           NA       = 0
           LU       = -1.D0
           KWDS     =>null()
           select case(CFG(1:len_trim(CFG)) )
                  case (PKW_OUTCFG_FORMAT14, PKW_OUTCFG_FORMAT15)
                        SKIP = 1
                  case (PKW_OUTCFG_FORMAT16, PKW_OUTCFG_FORMAT18)
                        SKIP = 0
                  case default
                        SKIP = 0
           end select

           SKIP1 = 0
           LINE  = 0
           call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
           TSTR = adjustl(TSTR)
           call GetKeyWord("&", TSTR, KEYWORD)
           call UpCase(KEYWORD)
           if((KEYWORD(1:LEN_TRIM(KEYWORD)) .ne. PKW_INCFG_FORMATXYZ) .and.  &
              (KEYWORD(1:LEN_TRIM(KEYWORD)) .ne. PKW_OUTCFG_FORMAT14) .and.  &
              (KEYWORD(1:LEN_TRIM(KEYWORD)) .ne. PKW_OUTCFG_FORMAT15) .and.  &
              (KEYWORD(1:LEN_TRIM(KEYWORD)) .ne. PKW_OUTCFG_FORMAT16) .and.  &
              (KEYWORD(1:LEN_TRIM(KEYWORD)) .ne. PKW_OUTCFG_FORMAT18)  )  then
              write(*,fmt="(A)") ' MDPSCU Error: try to load a file of unknown format in Read_ConfigFileHeader'
              write(*,fmt="(A)") '               the header keyword should be: '// PKW_INCFG_FORMATXYZ(1:len_trim(PKW_INCFG_FORMATXYZ))
              write(*,fmt="(A)") '                                             '// PKW_OUTCFG_FORMAT14(1:len_trim(PKW_OUTCFG_FORMAT14))
              write(*,fmt="(A)") '                                             '// PKW_OUTCFG_FORMAT15(1:len_trim(PKW_OUTCFG_FORMAT15))
              write(*,fmt="(A)") '                                             '// PKW_OUTCFG_FORMAT16(1:len_trim(PKW_OUTCFG_FORMAT16))
              write(*,fmt="(A)") '                                             '// PKW_OUTCFG_FORMAT18(1:len_trim(PKW_OUTCFG_FORMAT18))
              write(*,fmt="(A)") '               process to be stopped'
              stop
           end if

           !$$---
            do while(.true.)
               call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
               TSTR = adjustl(TSTR)
               call GetKeyWord("&", TSTR, KEYWORD)
               call UpCase(KEYWORD)
               if(len_trim( KEYWORD) .le. 0) exit
               select case(KEYWORD(1:LEN_TRIM(KEYWORD)))
                      case( "&LATT")
                            call Extract_Numb(TSTR,SKIP+1,N,STRNUMB)
                            if(N .lt. SKIP+1) then
                               write(*,fmt="(A)")       ' MDPSCU Error: length unit is missed.'
                               write(*,fmt="(A)")       '        Usage: &LATT lu, or &LENTHUNIT lu'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if
                            LU = DRSTR(STRNUMB(SKIP+1))*CP_A2CM

                      case( "&NATOM")
                            if(SKIP1 .eq. 0) then

                            call Extract_Numb(TSTR,SKIP+1,N,STRNUMB)
                            if(N .lt. SKIP+1) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the number of atoms is missed.'
                               write(*,fmt="(A)")       '        Usage: &NATOM  number of atoms'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if
                            NATOM = ISTR(STRNUMB(SKIP+1))

                             if(SKIP .eq. 1) SKIP1 = 1
                            end if

                      case( "&NGROUP")
                            call Extract_Numb(TSTR,SKIP+1,N,STRNUMB)
                            if(N .lt. SKIP+1) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the number of group is missed.'
                               write(*,fmt="(A)")       '        Usage: &NGROUP  number of groups'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if
                            NGROUP = ISTR(STRNUMB(SKIP+1))

                      case( "&BOXLOW")
                            call Extract_Numb(TSTR,SKIP+3,N,STRNUMB)
                            if(N .lt. SKIP+3) then
                               write(*,fmt="(A)")       ' MDPSCU Error: box low boundray should be defined by real numbers'
                               write(*,fmt="(A)")       '        Usage: &BOXLOW  blx, bly, blz'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if
                            BOXLOW(1) =DRSTR(STRNUMB(SKIP+1))
                            BOXLOW(2) =DRSTR(STRNUMB(SKIP+2))
                            BOXLOW(3) =DRSTR(STRNUMB(SKIP+3))

                      case( "&BOXSIZE")
                            call Extract_Numb(TSTR,SKIP+3,N,STRNUMB)
                            if(N .lt. SKIP+3) then
                               write(*,fmt="(A)")       ' MDPSCU Error: box size should be defined by real numbers.'
                               write(*,fmt="(A)")       '        Usage: &BOXSIZE  bsx, bsy, bsz'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if
                            BOXSIZE(1) =DRSTR(STRNUMB(SKIP+1))
                            BOXSIZE(2) =DRSTR(STRNUMB(SKIP+2))
                            BOXSIZE(3) =DRSTR(STRNUMB(SKIP+3))

                      case default !--- add other keyword statement that could be used in analysis routine
                           if(.not.IsBasicKWD(KEYWORD) .and. &
                              .not. HasKeyword_StatementList(KEYWORD(2:len_trim(KEYWORD)),KWDS) ) then
                               call Add_StatementList(KWDS, TSTR, LINE)
                           end if
               end select
            end do

            !$$--- check if the input values are consistent with those
            !      alread defined in SimBox

            !$$--- first, we check the number of atoms in the box,
            !$$    reallocate memery if required if necessary
             if(NATOM .eq. 0 .and. Simbox%NPRT .eq. 0) then
                write(*,fmt="(A)")       ' MDPSCU Error: the number of atoms is not defined'
                write(*,fmt="(A, BZI6)") '               check the box file or the configuration file'
                write(*,fmt="(A)")       '               process to be stopped'
                stop
             end if

             if(Simbox%NPRT .eq. 0) then
                !$$--- the box is still not created, set the number of atoms as NATOM.
                !$$    one type is assume
                 call Release_SimMDBox(Simbox)
                 Simbox%NPRT   = NATOM
                 Simbox%NGROUP = max(1, NGROUP)

                !$$*** To allocate memory an intialize for the nGroup
                 SimBox%NA      = 0
                 SimBox%NA(1)  = NATOM
                 SimBox%IPA(1) = 1
                 SimBox%IPA(2) = NATOM+1
                 SimBox%PTYPE = 0
                 SimBox%SYMB = ""
                 SimBox%CZ = 0.D0
                 SimBox%CM = 0.D0
                 SimBox%PROP = CP_STATU_ACTIVE
                 call Initialize_SimMDBox(SimBox, 2)
             else
                 if(NATOM .eq. 0 .or. NATOM .eq. SimBox%NPRT) then
                   !$$--- do nothing here

                 else
                    if(present(mod)) then
                       if(mod .gt. 0) then !--- change of number of atom is allowed:
                          if(IAND(mod,2) .eq. 0) then
                             !--- give a warning message wihtout stop
                             write(*,fmt="(A, I8)") ' MDPSCU Warning: the number of atoms has been changed to ',NATOM
                             write(*,fmt="(A)")     '                  at loading initial configuration'
                             call ONWARNING(gm_OnWarning)
                          end if

                          if(NATOM .gt. Simbox%NPRT) then !-- reallocate memory is needed
                             call AddAtoms_SimMDBox(Simbox, NATOM-Simbox%NPRT, ITYPE=1, TYPEORDER=1)
                          else  !-- reallocate memory is not needed, just set the number of atoms as NATOM
                             Simbox%NPRT = NATOM
                          end if

                       else !--- change of number of atom is not allowed:
                          write(*,fmt="(A)") ' MDPSCU Error: the number of atoms in the initial configure file differ from that in simulation box'
                          write(*,fmt="(15X,I8,A, I8)")   NATOM, ' vs ', Simbox%nprt
                          write(*,fmt="(A)")        '               process to be stopped'
                          stop
                       end if
                    else !-- mod not present, change of number of atom is not allowed
                        write(*,fmt="(A)") ' MDPSCU Error: the number of atoms in the initial configure file differ from that in simulation box'
                        write(*,fmt="(15X,I8,A, I8)")   NATOM, ' vs ', Simbox%nprt
                        write(*,fmt="(A)")        '               process to be stopped'
                        stop
                    end if
                 end if
             end if

             !--- we check the consistent of length unit
              if(Simbox%RR .le. 0 .and. LU .le. 0.D0) then
                 write(*,fmt="(A)")       ' MDPSCU Error: the lenght unit (in A) is not defined'
                 write(*,fmt="(A, BZI6)") '               check the box file or the configuration file'
                 write(*,fmt="(A)")       '               process to be stopped'
                 stop
              end if

              if(Simbox%RR .le. 0) then
                 Simbox%RR = LU
              else
                 if(LU .le. 0) then
                   LU = Simbox%RR
                 else
                    if(LU .ne. Simbox%RR) then
                       if(present(mod)) then
                          if(mod .gt. 0) then !--- change of unit is allowed:
                             if(IAND(mod,2) .eq. 0) then
                                !--- give a warning message wihtout stop
                                write(*,fmt="(A, F8.4)") ' MDPSCU Warning: the lenth unit (in A) has been changed to ',LU*CP_CM2A
                                write(*,fmt="(A)")     '                  at loading initial configuration'
                                call ONWARNING(gm_OnWarning)
                             end if
                             Simbox%ZL = (Simbox%ZL/Simbox%RR)*LU
                             Simbox%BOXLOW = (Simbox%BOXLOW/Simbox%RR)*LU
                             Simbox%BOXUP  = (Simbox%BOXUP/Simbox%RR)*LU
                             Simbox%RR = LU
                          else !--- change of lenth unitis not allowed:
                             write(*,fmt="(A)") ' MDPSCU Error: the lenth unit in the initial configure file differ from that in simulation box'
                             write(*,fmt="(15X, F8.4, A, F8.4)")   LU*CP_CM2A, ' vs ', Simbox%RR*CP_CM2A
                             write(*,fmt="(A)")        '               process to be stopped'
                             stop
                          end if
                       else !-- mod not present, change of lenth unit is not allowed
                          write(*,fmt="(A, F8.4)") ' MDPSCU Warning: the lenth unit in the initial configure file differ from that in simulation box'
                          write(*,fmt="(15X, F8.4, A, F8.4)")   LU*CP_CM2A, ' vs ', Simbox%RR*CP_CM2A
                          call ONWARNING(gm_OnWarning)
                       end if
                    end if
                 end if
              end if

             !$$--- now, we check the consistent of BOXSIZE
              BOXSIZE(1:3) = BOXSIZE(1:3)*LU
              if(any(Simbox%ZL .le. 0.D0) .and. any(BOXSIZE .le. 0.D0) ) then
                 write(*,fmt="(A)")       ' MDPSCU Error: the lenght unit (in A) or the BOXSIZE are not defined'
                 write(*,fmt="(A, BZI6)") '               check the box file or the configuration file'
                 write(*,fmt="(A)")       '               process to be stopped'
                 stop
              end if

               if(any(Simbox%ZL .le. 0.D0)) then
                  Simbox%ZL = BOXSIZE
               else
                  if(any(BOXSIZE .le. 0.D0)) then
                     BOXSIZE = Simbox%ZL
                  else
                     if(any(Simbox%ZL/Simbox%RR .ne. BOXSIZE/LU)) then
                        if(present(mod)) then
                           if(mod .gt. 0) then !--- change of unit is allowed:
                              if(IAND(mod,2) .eq. 0) then
                              !  $$--- give a warning message wihtout stop
                                 write(*,fmt="(A, 3(F8.4,1x))") ' MDPSCU Warning: the boxsize has been changed to ',BOXSIZE/LU
                                 write(*,fmt="(A)")     '                   at loading initial configuration'
                                 call ONWARNING(gm_OnWarning)
                              end if
                              SimBox%BOXLOW = SimBox%BOXLOW*(BOXSIZE/Simbox%ZL)
                              SimBox%BOXUP  = SimBox%BOXUP*(BOXSIZE/Simbox%ZL)
                              Simbox%ZL = BOXSIZE
                           else !--- change of boxsize not allowed:
                              write(*,fmt="(A)") ' MDPSCU Error: the boxsizet in the configure file differ from that in simulation box'
                              write(*,fmt="(15X, 3(F9.4,1x), A, 3(F9.4,1x))")   BOXSIZE/LU, ' vs ', Simbox%ZL/LU
                              write(*,fmt="(A)")        '               process to be stopped'
                              stop
                           end if
                        else
                           write(*,fmt="(A)") ' MDPSCU Warning: the boxsizet in the configure file differ from that in simulation box'
                           write(*,fmt="(15X, 3(F9.4,1x), A, 3(F9.4,1x))")   BOXSIZE/LU, ' vs ', Simbox%ZL/LU
                           call ONWARNING(gm_OnWarning)
                        end if
                     end if
                  end if
               end if

               if(any(Simbox%BOXLOW .gt. 1.D60) )then
                  Simbox%BOXLOW = -0.5*Simbox%ZL
                  Simbox%BOXUP  = Simbox%BOXLOW+Simbox%ZL
               end if

               !--- save other keywords
               call Copy_StatementList(KWDS, Simbox%proKWDStatment)
               call Release_StatementList(KWDS)
               return

    100       write(*,fmt="(A)") ' MDPSCU Error: end of the configure file reached without find the needed keyword'
              write(*,fmt="(A)") '               check if the keywords &XYZCOL or &TYPE exist'
              stop
  end subroutine Read_ConfigFileHeader_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine AddDataProKWD_SimMDBox(Simbox, Keyword)
  !***  PURPOSE:   to add a keyword to property keyword list
  !
  !     INPUT:    Simbox,  the simulation box
  !               keyword, the keyword to be added
  !     OUTPUT:   Simbox,  the simulation box with its property keywordlist updated
  !
      implicit none
      !--- DUMMY variables
      type(SimMDBox) ::SimBox
      character*(*)  ::Keyword
      !--- local variables

            call New_DataPad( "&"//Keyword(1:LEN_TRIM(KEYWORD)), SimBox%proKWDList)
            return
   end subroutine AddDataProKWD_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine ClearDataProKWD_SimMDBox(Simbox)
  !***  PURPOSE:   to clear keyword to property keyword list
  !
  !     INPUT:    Simbox,  the simulation box
  !     OUTPUT:   Simbox,  the simulation box with its property keywordlist updated
  !
      implicit none
      !--- DUMMY variables
      type(SimMDBox)::SimBox
      !--- local variables

            call Release_DataPad(SimBox%proKWDList)
            return
   end subroutine ClearDataProKWD_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine CheckXYZDataAvailable_SimMDBox(Simbox, hFile)
  !***  PURPOSE:   to check if required data available in XYZ format file.
  !                this routine could be used in analysis processes where
  !                need atom properties
  !
  !     INPUT:    Simbox, the simulation box with the positions of atoms updated
  !               hfile,  the I/O unit for reading the configuration
  !
      implicit none
      !--- DUMMY variables
      integer,        intent(in)::hFile
      type(SimMDBox), intent(in)::SimBox
      !--- local variables
      integer:: I, LINE, NDAT
      character*256::TSTR
      character*32::KEYWORD


               NDAT = 0
               LINE = 0
               rewind(hFile)
               do while(.true.)
                  call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
                  TSTR = adjustl(TSTR)
                  call GetKeyWord("&", TSTR, KEYWORD)
                  if(len_trim(KEYWORD) .le. 0) exit

                  if(HasTag_DataPad(KEYWORD, SimBox%proKWDList)) then
                     NDAT = NDAT + 1
                  end if
               end do

               if(NDAT .lt. NumberofData_DataPad(SimBox%proKWDList)) goto 100
            return

    100     write(*,fmt="(A,A,A)") ' MDPSCU Error: all property data keywords:'
            do I=1, NumberofData_DataPad(SimBox%proKWDList)
               call Tag_DataPad(I, SimBox%proKWDList, KEYWORD)
               write(*,fmt="(A,A,A)") '                                   '//KEYWORD(1:len_trim(KEYWORD))
               write(*,fmt="(A,A,A)") ' is not available from the configure file.'
            end do
            write(*,fmt="(A, BZI6)")  ' check the configuration for the keyword'
            write(*,fmt="(A)")        ' Process to be stopped'
            stop
  end subroutine CheckXYZDataAvailable_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Putout_Instance_Config_SimMDBox(Fhead, SimBox, Stamp, IDA, ExStats)
  !***  PORPOSE: to putout the instant configuaration of a simulation box
  !     INPUT:   Fhead, the head of the file name storing the configuration
  !              SimBox, the simulation box
  !              Stamp,  the recording stamp
  !              ID, optional, the ID of atoms to be put out
  !
  implicit none
      !--- DUMMY variables
      character*(*),              intent(in):: Fhead
      type(SimMDBox),             intent(in):: SimBox
      type(MDRecordStamp),        intent(in):: Stamp
      integer,dimension(:),optional         :: IDA
      type(StatementList), pointer, optional::ExStats
      !--- local variables
      integer, parameter::P_TL = 18, P_TAGL = 12
      integer::K, hFile, I,J,  TNA, NA(mp_MXGROUP)=0, IS, NDAT, ID, NCOL
      character*256 ::FNAME
      character*1024::title, fmt, PSTR0, PSTR

      type(DataPad), dimension(:), allocatable::pDat
      integer, dimension(:,:), allocatable::DIM
      character*64          ::TSN, TS, TSFMT
      type(DataPad), pointer::tsDat
      type(DataPad)         ::TagDat


      if(present(IDA) ) then
         TNA = 0
         NA =  0
         do I=1, size(IDA)
             K = IDA(I)
             if(K .LT. 1 .OR. K.GT.SimBox%NPRT) cycle

             TNA = TNA + 1
             NA(SimBox%ITYP(K)) = NA(SimBox%ITYP(K)) + 1
         end do
      else
         TNA = SimBox%NPRT
         NA  = SimBox%NA
      end if


      !$$--- to calculate the extension of the file
       if(Stamp%ICfg(1) .ge. 0) then
          call STRCATI(fname, Fhead, ".", Stamp%ICfg(1), 4)
       else 
         fname = Fhead
       end if   

       !$$--- to open the file
       call AvailableIOUnit(hFile)
       open(hFile, file = fname, status='unknown')

       !*** write out head and box informations
       write(hFile, fmt="(A)") PKW_OUTCFG_FORMAT18
       call Putout_RecordStamp(hFile, Stamp)

       !$$*** to prepare the format of output
        IS    = 0
        NCOL  = 1
        TSFMT = "(1x I4, 1x, I3, 1x, A)"
        title = ""
        fmt   = "("

        title = title(1:IS)//   "&TYPE         "
        IS    = IS        + len("&TYPE         ")
        fmt   = fmt(1:len_trim(fmt))//"I8,3X"
        TS    = "&TYPECOL"
        write(TSN,fmt=TSFMT)  NCOL, 1, '"I"'
        TS    = TS(1:P_TAGL)//TSN
        call New_DataPad(TS, tsDat)
        NCOL  = NCOL + 1

        title = title(1:IS)//   "POS(LU)  (x)             (y)              (z)         "
        IS    = IS        + len("POS(LU)  (x)             (y)              (z)         ")
        fmt   = fmt(1:len_trim(fmt))//",3(1PE17.8,1X)"
        TS    = "&XYZCOL"
        write(TSN,fmt=TSFMT)  NCOL, 3, '"D"'
        TS    = TS(1:P_TAGL)//TSN
        call New_DataPad(TS, tsDat)
        NCOL  = NCOL + 3

        title = title(1:IS)//   "VEL(LU/ps)(vx)           (vy)             (vz)        "
        IS    = IS        + len("VEL(LU/ps)(vx)           (vy)             (vz)        ")
        fmt   = fmt(1:len_trim(fmt))//",3(1PE17.8,1X)"
        TS    = "&VELCOL"
        write(TSN,fmt=TSFMT) NCOL, 3, '"D"'
        TS    = TS(1:P_TAGL)//TSN
        call New_DataPad(TS, tsDat)
        NCOL  = NCOL + 3

        title = title(1:IS)//   "STATU   "
        IS    = IS        + len("STATU   ")
        fmt   = fmt(1:len_trim(fmt))//",I6,2X"
        TS    = "&STATCOL"
        write(TSN,fmt=TSFMT) NCOL, 1, '"I"'
        TS    = TS(1:P_TAGL)//TSN
        call New_DataPad(TS, tsDat)
        NCOL  = NCOL + 1

        title = title(1:IS)//   "FOR(ev/LU)(fx)           (fy)             (fz)        "
        IS    = IS        + len("FOR(ev/LU)(fx)           (fy)             (fz)        ")
        fmt   = fmt(1:len_trim(fmt))//",3(1PE17.8,1X)"
        TS    = "&FPCOL"
        write(TSN,fmt=TSFMT) NCOL, 3, '"D"'
        TS    = TS(1:P_TAGL)//TSN
        call New_DataPad(TS, tsDat)
        NCOL  = NCOL + 3

        title = title(1:IS)//   "POT(ev).          "
        IS    = IS        + len("POT(ev).          ")
        fmt   = fmt(1:len_trim(fmt))//",1(1PE17.8,1X)"
        TS    = "&EPOTCOL"
        write(TSN,fmt=TSFMT) NCOL, 1, '"D"'
        TS    = TS(1:P_TAGL)//TSN
        call New_DataPad(TS, tsDat)
        NCOL  = NCOL + 1

        title = title(1:IS)//   "K.E.(ev)          "
        IS    = IS        + len("K.E.(ev)          ")
        fmt   = fmt(1:len_trim(fmt))//",1(1PE17.8,1X)"
        TS    = "&EKINCOL"
        write(TSN,fmt=TSFMT) NCOL, 1, '"D"'
        TS    = TS(1:P_TAGL)//TSN
        call New_DataPad(TS, tsDat)
        NCOL  = NCOL + 1

        title = title(1:IS)//   "DISPLACE(dx )            (dy)               (dz)       "
        IS    = IS        + len("DISPLACE(dx )            (dy)               (dz)       ")
        fmt   = fmt(1:len_trim(fmt))//",3(1PE17.8,1X)"
        TS    = "&DISCOL"
        write(TSN,fmt=TSFMT) NCOL,3, '"D"'
        TS    = TS(1:P_TAGL)//TSN
        call New_DataPad(TS, tsDat)
        NCOL  = NCOL + 3

        NDAT = 0
        if(associated(SimBox%ptrDatPad) ) then
           NDAT = NumberofData_DataPad(SimBox%ptrDatPad)
           allocate(pDat(NDAT),DIM(NDAT,2))
           do ID=1, NDAT
              call GetData_DataPad(ID, SimBox%ptrDatPad, pDat(ID))
              call GetSize_DataPad(ID, SimBox%ptrDatPad, DIM(ID,:))
              title = title(1:IS)//pDat(ID)%Tag(1:len_trim(pDat(ID)%Tag))

              call GetFirstWord(pDat(ID)%Tag, TS)
              call UpCase(TS)
              TS    = "&"//TS(1:len_trim(TS))//"COL"
              if(IsInteger_DataPad(pDat(ID)) ) then
                 write(TSN,fmt=TSFMT) NCOL,Dim(ID,2), '"I"'
              else
                 write(TSN,fmt=TSFMT) NCOL,Dim(ID,2), '"D"'
              end if
              TS    = TS(1:P_TAGL)//TSN
              call New_DataPad(TS, tsDat)
              NCOL  = NCOL + DIM(ID, 2)
              IS = IS + P_TL*DIM(ID, 2)
           end do
       end if
       fmt   = fmt(1:len_trim(fmt))//",A)"

       !$$--- to write out colume information
       write(hFile,FMT="(A, 3(1PE12.5,1x))") "!--- Table colume information:"
       do K =1, NumberofData_DataPad(tsDat)
          call GetData_DataPad(K, tsDat, TagDat)
          write(hFile,FMT="(A))")TagDat%Tag(1:len_trim(TagDat%Tag))
       end do

       !$$--- write out box information
       write(hFile,FMT="(A))")
       write(hFile,FMT="(A, 3(1PE12.5,1x))") "&LATT     lattice length (in A):       ",  SimBox%RR*CP_CM2A
       write(hFile,FMT="(A, 3(1PE12.5,1x))") "&BOXLOW   low boundary of box (in LU): ",  SimBox%BOXLOW(1:3)/SimBox%RR
       write(hFile,FMT="(A, 3(1PE12.5,1x))") "&BOXSIZE  boxsize (in LU):             ",  SimBox%ZL(1:3)/SimBox%RR
       write(hFile,FMT="(A, 3(I8,1x))")      "&NATOM    total number of atoms:       ", TNA
       write(hFile,FMT="(A, 3(I8,1x))")      "&NGROUP   number of group of atoms:    ", SimBox%NGROUP
       write(hFile,FMT="(A, 100(I8,1x))")    "    &NA   number of atoms in groups:   ", (NA(J), J=1, SimBox%NGROUP)
       write(hFile,FMT="(A, 3(1PE12.5,1x))") "&TEMPCAL instant temperature(K):      ", SimBox%Temperature

       !$$--- write out supplement information
       if(present(ExStats) ) then
          if(associated(ExStats)) then
            write(hFile,FMT="(A, 3(1PE12.5,1x))") "!--- Supplemnetation information:" 
            call Write_StatementList(hFile, ExStats)
          end if
       end if

       !$$--- write out the configures
       write(hFile,FMT="(A, 3(1PE12.5,1x))") "!--- Configure:"
       write(hFile,FMT="(20A))")title(1:len_trim(title))
       if(.not.present(IDA)) then
          do K=1, SimBox%NPRT
             PSTR = ""
             IS  = 0
             do ID=1, NDAT
                if(IsInteger_DataPad(pDat(ID)) ) then
                   call Write_DataPad(pDat(ID), K, PSTR0, Fmt="5x,I8,5x")
                else if(IsDouble_DataPad(pDat(ID)) ) then
                   call Write_DataPad(pDat(ID), K, PSTR0, Fmt="1PE17.8,1X")
                end if
                PSTR = PSTR(1:IS)//PSTR0(1:DIM(ID,2)*P_TL)
                IS   = IS + DIM(ID,2)*P_TL
             end do

             write(hFile,fmt=fmt)SimBox%ITYP(K), SimBox%XP(K,1:3)/SimBox%RR,                 &
                                 SimBox%XP1(K,1:3)/SimBox%RR/CP_S2PS, SimBox%STATU(K),       &
                                 SimBox%FP(K,1:3)*CP_ERGEV*SimBox%RR,                        &
                                -SimBox%EPOT(K)*CP_ERGEV, SimBox%EKIN(K)*CP_ERGEV,           &
                                 SimBox%DIS(K,1:3)/SimBox%RR,                                &
                                 PSTR(1:len_trim(PSTR))
          end do
       else
          do I=1, size(IDA)
             K = IDA(I)
             if(K .LT. 1 .OR. K.GT.SimBox%NPRT) cycle

             PSTR = ""
             IS  = 0
             do ID=1, NDAT
                if(IsInteger_DataPad(pDat(ID)) ) then
                   call Write_DataPad(pDat(ID), K, PSTR0, Fmt="5x,I8,5x")
                else if(IsDouble_DataPad(pDat(ID)) ) then
                   call Write_DataPad(pDat(ID), K, PSTR0, Fmt="1PE17.8,1X")
                end if
                PSTR = PSTR(1:IS)//PSTR0(1:DIM(ID,2)*P_TL)
                IS   = IS + DIM(ID,2)*P_TL
             end do

             write(hFile,fmt=fmt)SimBox%ITYP(K), SimBox%XP(K,1:3)/SimBox%RR,                 &
                                 SimBox%XP1(K,1:3)/SimBox%RR/CP_S2PS, SimBox%STATU(K),       &
                                 SimBox%FP(K,1:3)*CP_ERGEV*SimBox%RR,                        &
                                -SimBox%EPOT(K)*CP_ERGEV, SimBox%EKIN(K)*CP_ERGEV,           &
                                 SimBox%DIS(K,1:3)/SimBox%RR,                                &
                                 PSTR(1:len_trim(PSTR))
          end do
       end if
       close(hFile)
       if(allocated(pDat)) deallocate(pDat)
       if(allocated(DIM))  deallocate(DIM)
       call Release_DataPad(tsDat)

       return
  end subroutine Putout_Instance_Config_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Read_ConfigByCol18_SimMDBox(Simbox, hFile, mod)
  !***  PURPOSE:   to read in the configuration of a simulation box in XYZ format.
  !                This routine can be used in MD simulations to load initial
  !                configurations, and also in analysis routines in which need
  !                only one configuration is needed.
  !
  !
  !     INPUT:     hfile,   the I/O unit for reading the configuration
  !                mod,     inidcating if the replacement of the box information such as
  !                         the number the number of atoms are permitted
  !                alldata, flag indicasting if all property data to be loaded even wihtout in the proptitl list
  !
  !
  !     OUTPUT     Simbox, the simulation box with the positions of atoms updated
  !
      implicit none
      !--- DUMMY variables
      integer,     intent(in)::hFile
      type(SimMDBox)         ::SimBox
      integer,       optional::mod

      !--- local variables
      integer:: I, J, LINE, NCOL, N, XPCOL, XP1COL, FPCOL, TYPCOL, POTCOL, KENCOL, STATCOL, DISCOL
      integer::NDAT
      type(DataPad), dimension(:), allocatable::PDat
      integer,       dimension(:), allocatable::PDatCol
      real(KINDDF)::LUNIT


           !$$--- XYZ data is always required keyword &XYZCOL is always needed
            !call AddDataProKWD_SimMDBox(SimBox, "XYZCOL",*200)
            call CheckXYZDataAvailable_SimMDBox(SimBox, hFile)

            NDAT = NumberofData_DataPad(SimBox%ptrDatPad)
            if(NDAT .gt. 0) then
               allocate(PDat(NDAT), PDatCol(NDAT*2))
               do I=1, NDAT
                  call GetData_DataPad(I, SimBox%ptrDatPad, PDat(I))
               end do
            end if
           !$$---
            LINE = 0
            rewind(hFile)
            call Read_ConfigByCol18A_SimMDBox(Simbox, hFile, LINE, NCOL, TYPCOL, XPCOL, XP1COL, STATCOL, &
                                                   FPCOL, POTCOL, KENCOL, DISCOL,                             &
                                                   PDatCol, LUNIT)

            write(*,fmt="(A)")                   ' MDPSCU Message: load configuration from file by defined columes'
            write(*,fmt="(A, I8)")               '                 with number of atoms ',SimBox%NPRT
            if(TYPCOL .gt. 0 ) &
               write(*,fmt="(A, I5, 10x, A)")    '                 col', TYPCOL,   ' for atom type'
            if(XPCOL .gt. 0)   &
               write(*,fmt="(A, I5, A5, I5, A)") '                 col', XPCOL,    ' to ',  XPCOL+2,  ' for position'
            if(XP1COL .gt. 0)  &
               write(*,fmt="(A, I5, A5, I5, A)") '                 col', XP1COL,   ' to ',  XP1COL+2, ' for velocity'
            if(FPCOL .gt. 0)   &
               write(*,fmt="(A, I5, A5, I5, A)") '                 col', FPCOL,    ' to ',  FPCOL+2,  ' for force'
            if(DISCOL .gt. 0)  &
               write(*,fmt="(A, I5, A5, I5, A)") '                 col', DISCOL,   ' to ',  DISCOL+2, ' for Displacement'
            if(POTCOL .gt. 0 ) &
               write(*,fmt="(A, I5, 10X, A)")    '                 col', POTCOL,   ' for potential'
            if(KENCOL .gt. 0 ) &
               write(*,fmt="(A, I5, 10X, A)")    '                 col', KENCOL,   ' for kinetic energy'
            if(STATCOL .gt. 0 )&
               write(*,fmt="(A, I5, 10X, A)")    '                 col', STATCOL,  ' for statu'

            do I=1, NDAT
               if(PDatCol(2*I-1).gt.0) then
                   write(*,fmt="(A, I5, A5, I5, A)") '                 col', PDatCol(2*I-1), ' to ',        &
                                                                            PDatCol(2*I-1)+PDatCol(2*I)-1, &
                                                                      ' for '//PDat(I)%Tag(1:len_trim(PDat(I)%Tag))
               end if
            end do

            !$$--- to begain load the data by colume
            !$$    first, skip the hearder
            rewind(hFile)
            do I=1, LINE-1
               read(hFile, fmt="(A256)")
            end do
            call Read_ConfigByCol18B_SimMDBox(Simbox, hFile, NCOL, TYPCOL, XPCOL, XP1COL, STATCOL, &
                                                   FPCOL, POTCOL, KENCOL, DISCOL, &
                                                   PDatCol, LUNIT)


            !$$--- has type information available, check if it consistent with input in BOXFILE
            if(present(mod)) then
               call Check_Config_Consistent_SimMDBox(Simbox, mod)
            else
               call Check_Config_Consistent_SimMDBox(Simbox)
             end if

            if(allocated(PDat) )   deallocate(PDat)
            if(allocated(PDatCol)) deallocate(PDatCol)
        return

   100  write(*,fmt="(A)") ' MDPSCU Error: end of the configure file reached without find the needed keyword'
        write(*,fmt="(A)") '               check if the keywords &XYZCOL or &TYPE exist'
        stop

        return
  end subroutine Read_ConfigByCol18_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Read_ConfigByCol18A_SimMDBox(Simbox, hFile, LINE, NCOL, TYPCOL, XPCOL, XP1COL,  &
                                               STATCOL, FPCOL, POTCOL, KENCOL, DISCOL,            &
                                               PDatCol, LUNIT)
  !***  PURPOSE:   to determine the colum information for read in the configuration of a
  !                simulation box in XYZ format.
  !                This routine can be used in MD simulations to load initial
  !                configurations, and also in analysis routines in which need
  !                only one configuration is needed.
  !
  !     INPUT:     hfile,   the I/O unit for reading the configuration
  !
  !     OUTPUT     Simbox, the simulation box with the positions of atoms updated
  !
      implicit none
      !--- DUMMY variables
      integer, intent(in)   ::hFile
      type(SimMDBox)        ::SimBox
      integer               ::LINE, NCOL, TYPCOL, XPCOL, XP1COL, STATCOL, FPCOL, POTCOL, KENCOL,DISCOL
      integer, dimension(:), allocatable ::PDatCol
      real(KINDDF),optional ::LUNIT

      !--- local variables
      integer:: I, J, N, DIM(2),NDAT, NEEDUNIT
      character*1024::TSTR
      character*32::KEYWORD, KEYWORD1, STRNUMB(5)
      character*32,  dimension(:), allocatable::SUBSTR
      real(KINDDF)::LUNIT0

           !$$--- to initialize the temperary valuse
           XPCOL    = 0
           XP1COL   = 0
           FPCOL    = 0
           TYPCOL   = 0
           POTCOL   = 0
           KENCOL   = 0
           STATCOL  = 0
           DISCOL   = 0
           LUNIT0   = -1
           if(allocated(PDatCol)) then
              PDatCol = 0
           end if
           if(present(LUNIT)) then
              LUNIT    = 1.D0
           end if
           NDAT     = NumberofData_DataPad(SimBox%ptrDatPad)
           NEEDUNIT = 1
           !$$---
            NCOL = 0
            do while(.true.)
               call GetInputStrLine(hFile,TSTR, LINE, "!", *100)
               TSTR = adjustl(TSTR)
               call GetKeyWord("&", TSTR, KEYWORD)
               if(len_trim(KEYWORD) .le. 0) exit

               call UpCase(KEYWORD)
               select case(KEYWORD(1:LEN_TRIM(KEYWORD)))
                      case(PKW_OUTCFG_FORMAT18) 
                      !--- in this case, the unit will be chaneged back to CGS
                      !    in calling routines   
                           NEEDUNIT = 0

                      case( "&LUNIT", "&LENTHUNIT")
                             call Extract_Substr(TSTR,1,N,STRNUMB(1:1))
                             if(N .le. 0) then
                                write(*,fmt="(A)")       ' MDPSCU Error: the length unit is missed'
                                write(*,fmt="(A)")       '        Usage: &LUNIT  n1 "A", or "NM", or "CM"'
                                write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                                write(*,fmt="(A)")       '        process to be stopped'
                               stop
                             end if
                             STRNUMB(1) = adjustl(STRNUMB(1))
                             call UpCase(STRNUMB(1))
                             select case(STRNUMB(1))
                                    case ("A")
                                      LUNIT0 = CP_A2CM
                                    case ("CM")
                                      LUNIT0 = 1.D0
                                    case ("NM")
                                      LUNIT0 = CP_NM2CM
                                    case ("LU")
                                       if(SimBox%RR .gt. 0.D0) then
                                          LUNIT0 = SimBox%RR
                                       end if                                         
                                    case default
                                       write(*,fmt="(A)")       ' MDPSCU Error: unknown length unit'
                                       write(*,fmt="(A)")       '        Usage: &LUNIT  n1 "A", "CM", "NM", "LU" '
                                       write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                                       write(*,fmt="(A)")       '        process to be stopped'
                                       stop
                             end select

                             call Extract_Numb(TSTR,1,N,STRNUMB(1:1))
                             if(N .ge. 1) LUNIT0 = LUNIT0*DRSTR(STRNUMB(1))

                      !case( "&LATT")
                      !     if(present(LUNIT)) then
                      !       call Extract_Numb(TSTR,1,N,STRNUMB)
                      !       if(N .ge. 1) LUNIT = DRSTR(STRNUMB(1))*CP_A2CM
                      !     end if

                      case( "&XYZCOL")
                            call Extract_Numb(TSTR,1,N,STRNUMB)
                            XPCOL = 0
                            if(N .ge. 1) XPCOL = ISTR(STRNUMB(1))
                            if(XPCOL .le. 0) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the colume IDs for position are missed'
                               write(*,fmt="(A)")       '        Usage: &XYZCOL  col(>0)'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if

                      case( "&DISCOL")
                            call Extract_Numb(TSTR,3,N,STRNUMB)
                            DISCOL = 0
                            if(N .ge. 1) DISCOL = ISTR(STRNUMB(1))
                            if(DISCOL .le. 0) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the colume IDs for displacement are missed'
                               write(*,fmt="(A)")       '        Usage: &DISCOL  col(>0)'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if

                      case( "&TYPECOL")
                            call Extract_Numb(TSTR,3,N,STRNUMB)
                            TYPCOL = 0
                            if(N .ge. 1) TYPCOL = ISTR(STRNUMB(1))
                            if(TYPCOL .le. 0) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the colume ID for type is missed'
                               write(*,fmt="(A)")       '        Usage: &TYPECOL  col>0'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if

                      case( "&VELCOL")
                            call Extract_Numb(TSTR,3,N,STRNUMB)
                            XP1COL = 0
                            if(N .ge. 1) XP1COL = ISTR(STRNUMB(1))
                            if(XP1COL .le. 0) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the colume IDs for velocities are missed'
                               write(*,fmt="(A)")       '        Usage: &VELCOL  col(>0)'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if

                      case( "&FPCOL")
                            call Extract_Numb(TSTR,3,N,STRNUMB)
                            FPCOL = 0
                            if(N .ge. 1) FPCOL = ISTR(STRNUMB(1))
                            if(FPCOL .le. 0) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the colume IDs for forces are missed'
                               write(*,fmt="(A)")       '        Usage: &FPCOL  col(>0)'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if

                      case( "&EPOTCOL")
                            call Extract_Numb(TSTR,1,N,STRNUMB)
                            POTCOL = 0
                            if(N .ge. 1) POTCOL = ISTR(STRNUMB(1))
                            if(POTCOL .le. 0) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the colume ID for potential is missed'
                               write(*,fmt="(A)")       '        Usage: &EPOTCOL  col'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if

                      case( "&EKINCOL")
                            call Extract_Numb(TSTR,1,N,STRNUMB)
                            KENCOL = 0
                            if(N .ge. 1) KENCOL = ISTR(STRNUMB(1))
                            if(KENCOL .le. 0) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the colume ID for kinetic energy is missed'
                               write(*,fmt="(A)")       '        Usage: &EKINCOL  col>0'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if

                      case( "&STATUCOL", "&STATCOL")
                            call Extract_Numb(TSTR,1,N,STRNUMB)
                            STATCOL = 0
                            if(N .ge. 1) STATCOL = ISTR(STRNUMB(1))
                            if(STATCOL .le. 0) then
                               write(*,fmt="(A)")       ' MDPSCU Error: the colume ID for statu of atoms is missed'
                               write(*,fmt="(A)")       '        Usage: &STATCOL  col'
                               write(*,fmt="(A, BZI6)") '        check the configuration file at line:', LINE
                               write(*,fmt="(A)")       '        process to be stopped'
                               stop
                            end if

                      case default
                            if(KEYWORD(len_trim(KEYWORD)-2:len_trim(KEYWORD)) .eq. "COL" ) then

                               call Ind_DataPad(KEYWORD(2:len_trim(KEYWORD)-3), SimBox%ptrDatPad, I)
                               if(I .gt. 0) then
                                  call Extract_Numb(TSTR,2,N,STRNUMB)
                                  PDatCol(I*2-1) = 0
                                  PDatCol(I*2)   = 1
                                  if(N.ge.1) PDatCol(I*2-1) = ISTR(STRNUMB(1))
                                  if(N.ge.2) PDatCol(I*2)   = ISTR(STRNUMB(2))
                                  if(PDatCol(I*2-1) .le. 0 .or. PDatCol(I*2).le.0 )then
                                     write(*,fmt="(A)")       ' MDPSCU Error: the colume ID for '// &
                                                               KEYWORD1(1:len_trim(KEYWORD1))//    &
                                                              ' is missed'
                                     write(*,fmt="(A)")       '        Usage: '//                   &
                                                               KEYWORD1(1:len_trim(KEYWORD1))//      &
                                                              ' col>0, ext>0'
                                     write(*,fmt="(A, BZI6)")  '        check the configuration file at line:', LINE
                                     write(*,fmt="(A)")        '        process to be stopped'
                                     stop
                                  end if
                                  call GetSize_DataPad(I, SimBox%ptrDatPad, DIM)

                                  if(PDatCol(I*2) .lt. DIM(2)) then
                                     write(*,fmt="(A)")       ' MDPSCU Error: the colume extent for '// &
                                                               KEYWORD(1:len_trim(KEYWORD))//        &
                                                              ' is smaller than required dimension: '
                                     write(*,fmt="(A, BZI6, A, BZI6)")  '        ', PDatCol(I*2), ' vs required :', DIM(2)
                                     write(*,fmt="(A, BZI6)")  '        check the configuration file at line:', LINE
                                     write(*,fmt="(A)")        '        process to be stopped'
                                     stop
                                  end if
                               endif

                            end if
               end select
            end do
            if(present(LUNIT)) then
               if(NEEDUNIT .gt. 0) then
                  if(LUNIT0 .le. 0.D0) then
                     write(*,fmt="(A)")                 ' MDPSCU Error: the length unit is missed'
                     write(*,fmt="(A, BZI6, A, BZI6)")  '        add keyword &LUNIT xxx "ut" at header of the file'
                     write(*,fmt="(A, BZI6)")           '        where xxx is numerical, ut should be one of A, or cm, or nm or lu '
                     stop
                  end if  
                  LUNIT = LUNIT0
               else 
                  LUNIT = C_UN 
               end if      
            end if   

            !$$--- determine how many colum of data we need
            NCOL =  max(NCOL, XPCOL +3-1)
            NCOL =  max(NCOL, XP1COL+3-1)
            NCOL =  max(NCOL, FPCOL +3-1)
            NCOL =  max(NCOL, DISCOL+3-1)
            NCOL =  max(NCOL, TYPCOL)
            NCOL =  max(NCOL, POTCOL)
            NCOL =  max(NCOL, KENCOL)
            NCOL =  max(NCOL, STATCOL)
            do I=1, NDAT
               NCOL =  max(NCOL, PDatCol(2*I-1)+PDatCol(2*I)-1)
            end do

            !--- to check the completeness
            if(NCOL .le. 0) then
               write(*,fmt="(A)")      ' MDPSCU Error: no colume is defined for input data'
               write(*,fmt="(A)")      '               check the input file '
               write(*,fmt="(A)")      '        process to be stopped'
               stop
            end if

            !$$--- to find out how many colume of data available
            allocate(SUBSTR(NCOL))
            call Extract_Numb(TSTR, NCOL, N, SUBSTR)
            if(N .lt. NCOL) then
               write(*,fmt="(A)")            ' MDPSCU Error: ther number of columes of the input data is less than required colume number'
               write(*,fmt="(A, I4, A, I4)") '               ', NCOL, ' vs ', N
               write(*,fmt="(A)")            '         process to be stopped'
               stop
            end if

            if(allocated(SUBSTR))  deallocate(SUBSTR)
        return

   100  write(*,fmt="(A)") ' MDPSCU Error: end of the configure file reached without find the needed keyword'
        write(*,fmt="(A)") '               check if the keywords &XYZCOL or &TYPE exist'
        stop

        return
  end subroutine Read_ConfigByCol18A_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Read_ConfigByCol18B_SimMDBox(Simbox, hFile, NCOL,  TYPCOL, XPCOL, XP1COL,  &
                                               STATCOL, FPCOL, POTCOL, KENCOL, DISCOL,       &
                                               PDatCol, LUNIT)
  !***  PURPOSE:   to read in the configuration of a simulation box in XYZ format.
  !                This routine can be used in MD simulations to load initial
  !                configurations, and also in analysis routines in which need
  !                only one configuration is needed.
  !
  !     INPUT:     hfile,   the I/O unit for reading the configuration
  !
  !     OUTPUT     Simbox, the simulation box with the positions of atoms updated
  !
      implicit none
      !--- DUMMY variables
      integer,             intent(in) ::hFile
      type(SimMDBox)                 ::SimBox
      integer,             intent(in)::NCOL, XPCOL, XP1COL, FPCOL, TYPCOL, POTCOL, KENCOL, STATCOL, DISCOL
      integer,dimension(:),intent(in)::PDatCol
      real(KINDDF),        intent(in)::LUNIT

      !--- local variables
      integer:: I, J
      integer::NDAT
      type(DataPad), dimension(:), allocatable::PDat
      character*32,  dimension(:), allocatable::SUBSTR


           !$$---
            NDAT = NumberofData_DataPad(SimBox%ptrDatPad)
            if(NDAT .gt. 0) then
               allocate(PDat(NDAT))
               do I=1, NDAT
                  call GetData_DataPad(I, SimBox%ptrDatPad, PDat(I))
               end do
           end if

            allocate(SUBSTR(NCOL))
            do I=1, SimBox%NPRT
               read(hFile,*, end=100) SUBSTR(1:NCOL)
               if(XPCOL .gt. 0) then
                  read(SUBSTR(XPCOL),  *) SimBox%XP(I,1)
                  read(SUBSTR(XPCOL+1),*) SimBox%XP(I,2)
                  read(SUBSTR(XPCOL+2),*) SimBox%XP(I,3)
                  SimBox%XP(I,1:3) = SimBox%XP(I,1:3)*LUNIT
               end if
               if(DISCOL .gt. 0) then
                  read(SUBSTR(DISCOL),  *) SimBox%DIS(I,1)
                  read(SUBSTR(DISCOL+1),*) SimBox%DIS(I,2)
                  read(SUBSTR(DISCOL+2),*) SimBox%DIS(I,3)
                  SimBox%DIS(I,1:3) = SimBox%DIS(I,1:3)*LUNIT
               end if
               if(XP1COL .gt. 0) then
                  read(SUBSTR(XP1COL),  *) SimBox%XP1(I,1)
                  read(SUBSTR(XP1COL+1),*) SimBox%XP1(I,2)
                  read(SUBSTR(XP1COL+2),*) SimBox%XP1(I,3)
               end if
               if(FPCOL .gt. 0) then
                  read(SUBSTR(FPCOL),  *) SimBox%FP(I,1)
                  read(SUBSTR(FPCOL+1),*) SimBox%FP(I,2)
                  read(SUBSTR(FPCOL+2),*) SimBox%FP(I,3)
               end if
               if(TYPCOL .gt. 0) then
                  read(SUBSTR(TYPCOL),  *) SimBox%ITYP(I)
               end if
               if(POTCOL .gt. 0) then
                  read(SUBSTR(POTCOL),  *) SimBox%EPOT(I)
                  SimBox%EPOT(I) = - SimBox%EPOT(I)
               end if
               if(KENCOL .gt. 0) then
                  read(SUBSTR(KENCOL),  *) SimBox%EKIN(I)
               end if
               if(STATCOL .gt. 0) then
                  read(SUBSTR(STATCOL),  *) SimBox%STATU(I)
               end if

               do J=1, NDAT
                  if(PDatCol(2*J-1) .gt. 0) then
                     call Read_DataPad(pDat(J), I, SUBSTR(PDatCol(2*J-1):) )
                  end if
               end do
            end do

            if(TYPCOL  .le. 0) then
                !$$--- no type information available, assigne all atom as type 1
                SimBox%ITYP = 1
             end if

            !$$--- no statu information available, assigne all atom as group property
             if(STATCOL .le. 0) then
               do I=1,SimBox%NPRT
                  SimBox%STATU(I) = SimBox%PROP(SimBox%ITYP(I))
               end do
             end if

             !$$-- to do the length unit converstion

            if(allocated(SUBSTR))  deallocate(SUBSTR)
            if(allocated(PDat))    deallocate(PDat)
        return

   100  write(*,fmt="(A)") ' MDPSCU Error: end of the configure file reached without find the needed keyword'
        write(*,fmt="(A)") '               check if the keywords &XYZCOL or &TYPE exist'
        stop
        return
  end subroutine Read_ConfigByCol18B_SimMDBox
  !****************************************************************************

  !*********************************************************************
   subroutine Restore_Config_SimMDBox0(hFile, Simbox)
      !***  PURPOSE:   to restore configuration of a  box created by last simulation
      !     INPUT:     hFile,  the IO unit
      !     OUTPUT     Simbox, the simulation box
      implicit none

      !--- DUMMY variables
      integer, intent(in)::hFile
      type(SimMDBox)     ::SimBox

      !--- Local variables
      integer::NP, NXP, ERR
      type(SimMDBox)::tBox

         call CopyInformation_SimMDBox(SimBox, tBox)

         read(hFile, IOSTAT=ERR)tBox%RR, tBox%LATT,tBox%BOXSHAPE,tBox%BOXLOW, tBox%BOXUP, tBox%ZL
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%NPRT, tBox%NGROUP
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%NA, tBox%IPA, tBox%SYMB, tBox%CZ, tBox%CM, tBox%PROP, tBox%PTYPE
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%POTTYPE, tBox%POTLIBNAME, tBox%POTSUBLIBNAME
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%TEMPERATURE, tBox%VOLUME, tBox%SPRESS0, tBox%SPRESS1, tBox%SPRESS, tBox%AVEPOT, tBox%HARMIL
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%VTENSOR, tBox%KTENSOR, tBox%PTENSOR
         if(ERR) goto 100

         read(hFile) NP, NXP         
         if(NXP .eq. 1) then
             allocate(tBox%EPOT(NP), tBox%EKIN(NP), tBox%ITYP(NP),  &
                      tBox%XP(NP,3), tBox%XP1(NP,3),tBox%FP(NP,3),  &
                      tBox%DIS(NP,3),tBox%STATU(NP), STAT=ERR )
          else if(NXP .eq. 5) then
             allocate(tBox%EPOT(NP), tBox%EKIN(NP), tBox%ITYP(NP),  &
                      tBox%XP(NP,3), tBox%XP1(NP,3),tBox%XP2(NP,3), &
                      tBox%XP3(NP,3),tBox%XP4(NP,3), tBox%XP5(NP,3),tBox%FP(NP,3),&
                      tBox%DIS(NP,3),tBox%STATU(NP), STAT=ERR)
         end if
         if(ERR) goto 200

         read(hFile, IOSTAT=ERR)tBox%ITYP(1:NP)
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%XP(1:NP,1:3)
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%XP1(1:NP,1:3)
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%FP(1:NP,1:3)
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%EKIN(1:NP)
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%EPOT(1:NP)
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%STATU(1:NP)
         if(ERR) goto 100
         read(hFile, IOSTAT=ERR)tBox%DIS(1:NP,1:3)
         if(ERR) goto 100

         if(NXP .eq.5 ) then
            read(hFile, IOSTAT=ERR)tBox%XP2(1:NP,1:3)
            if(ERR) goto 100
            read(hFile, IOSTAT=ERR)tBox%XP3(1:NP,1:3)
            if(ERR) goto 100
            read(hFile, IOSTAT=ERR)tBox%XP4(1:NP,1:3)
            if(ERR) goto 100
            read(hFile, IOSTAT=ERR)tBox%XP5(1:NP,1:3)
            if(ERR) goto 100
         end if

         call Copy_SimMDBox0(tBox, SimBox)
         call Release_SimMDBox(tBox)
         return
  100    write(*,*) "MDPSUC error: fail to restore the box"
         close(hFile)
         stop          
  200    write(*,*) "MDPSUC error: fail to allocate memory on restoring the box"
         close(hFile)
         stop          

        return
  end subroutine Restore_Config_SimMDBox0
  !***************************************************************************
  
  !****************************************************************************
  subroutine Restore_Config_SimMDBox1(Simbox, Stamp, fname, ExtRestore)
  !***  PURPOSE:   to restore configuration of a simulation box created by last simulation
  !     INPUT:     fname,  the filename storing the configuration
  !
  !     OUTPUT     Stamp,  the time stamp
  !                Simbox, the simulation box
  implicit none

      !--- DUMMY variables
      character*(*), intent(in)::fname
      type(MDRecordStamp)      ::Stamp
      type(SimMDBox)           ::SimBox
      external                 ::ExtRestore
      interface 
        subroutine ExtRestore(hFile)
        implicit none
         !--- dummy vaiables
         integer, intent(in)::hFile
        end subroutine ExtRestore
      end interface 

      !--- Local variables
      integer::hFile
      logical::opened

          do hFile = 10, 99
            inquire(UNIT=hFile, OPENED=opened)
            if(.not.opened) exit
          end do

         open(hFile, file = fname, form='unformatted', status='old')
           call Restore_RecordStamp(hFile, Stamp)
           call Restore_Config_SimMDBox0(hFile, Simbox)
           call Restore_DataPad(hFile, Simbox%ptrDatPad)
           call ExtRestore(hFile)
         close(hFile)

        return
  end subroutine Restore_Config_SimMDBox1
  !*********************************************************************

  !*********************************************************************
   subroutine Archive_Config_SimMDBox0(hFile, Simbox)
      !***  PURPOSE:   to store configuration of a simulation box
      !     INPUT:     hFile,  the IO unit
      !                Simbox, the simulation box
      implicit none

      !--- DUMMY variables
      integer,       intent(in):: hFile
      type(SimMDBox),intent(in):: SimBox
      !--- Local variables
      integer::NP, NXP

         write(hFile)SimBox%RR,SimBox%LATT,SimBox%BOXSHAPE,SimBox%BOXLOW, SimBox%BOXUP,SimBox%ZL
         write(hFile)SimBox%NPRT, SimBox%NGROUP
         write(hFile)SimBox%NA, SimBox%IPA,SimBox%SYMB, SimBox%CZ, SimBox%CM, SimBox%PROP, SimBox%PTYPE
         write(hFile)SimBox%POTTYPE, SimBox%POTLIBNAME, SimBox%POTSUBLIBNAME
         write(hFile)SimBox%TEMPERATURE, SimBox%VOLUME, SimBox%SPRESS0, SimBox%SPRESS1, SimBox%SPRESS, SimBox%AVEPOT, SimBox%HARMIL
         write(hFile)SimBox%VTENSOR, SimBox%KTENSOR, SimBox%PTENSOR

         NP  = size(SimBox%ITYP)
         NXP = 1 
         if(allocated(SimBox%XP2)) NXP = 5
         write(hFile) NP, NXP
         write(hFile)SimBox%ITYP(1:NP)
         write(hFile)SimBox%XP(1:NP,1:3)
         write(hFile)SimBox%XP1(1:NP,1:3)
         write(hFile)SimBox%FP(1:NP,1:3)
         write(hFile)SimBox%EKIN(1:NP)
         write(hFile)SimBox%EPOT(1:NP)
         write(hFile)SimBox%STATU(1:NP)
         write(hFile)SimBox%DIS(1:NP,1:3)

         if(NXP .ge. 5) then 
            write(hFile)SimBox%XP2(1:NP,1:3)
            write(hFile)SimBox%XP3(1:NP,1:3)
            write(hFile)SimBox%XP4(1:NP,1:3)
            write(hFile)SimBox%XP5(1:NP,1:3)
         end if

        return
  end subroutine Archive_Config_SimMDBox0
  !****************************************************************************

  !***************************************************************************
  subroutine Archive_Config_SimMDBox1(Simbox, Stamp, fname, ExtArchive)
  !***  PURPOSE:   to restore configuration of a simulation box created by last simulation
  !     INPUT:
  !                fname,  the filename storing the configuration
  !                Stamp,  the time stamp
  !                Simbox, the simulation box
   implicit none

   !--- DUMMY variables
   character*(*),        intent(in) :: fname
   type(MDRecordStamp),  intent(in) :: Stamp
   type(SimMDBox),       intent(in) :: SimBox
   external                         ::ExtArchive
   interface
     subroutine ExtArchive(hFile)
     implicit none
      !--- dummy vaiables
      integer, intent(in)::hFile
     end subroutine ExtArchive
   end interface

   !--- Local variables
   integer::hFile
   logical::opened

       do hFile = 10, 99
          inquire(UNIT=hFile, OPENED=opened)
          if(.not.opened) exit
       end do

      open(hFile, file = fname, form='unformatted', status='unknown')
      call Archive_RecordStamp(hFile,Stamp)
      call Archive_Config_SimMDBox0(hFile,Simbox)
      call Archive_DataPad(hFile,Simbox%ptrDatPad)
      call ExtArchive(hFile)
      close(hFile)

     return
  end subroutine Archive_Config_SimMDBox1
  !*********************************************************************

  !*********************************************************************
   subroutine CopyInformation_SimMDBox(From, To)
      !***  PURPOSE:   to copy the information of a simulation box to another
      !                The information includ: size and shape of the box,
      !                number of type of atoms.
      !                However, the number of atoms could be different
      !
      !     INPUT:     From, the source simulation box
      !     OUTPUT     To, the copy of FROM
      implicit none

      !--- DUMMY variables
      type(SimMDBox)::From, TO
      !--- Local variables

         TO%USEUNIT       = FROM%USEUNIT
         TO%RR            = FROM%RR
         TO%LATT          = FROM%LATT
         TO%BOXSHAPE      = FROM%BOXSHAPE
         TO%BOXLOW        = FROM%BOXLOW
         TO%BOXUP         = FROM%BOXUP
         TO%ZL            = FROM%ZL
         TO%NGROUP        = FROM%NGROUP
         TO%SYMB          = FROM%SYMB
         TO%CZ            = FROM%CZ
         TO%CM            = FROM%CM
         TO%PROP          = FROM%PROP
         !TO%NA            = FROM%NA
         !TO%IPA           = FROM%IPA
         TO%PTYPE         = FROM%PTYPE
         TO%POTTYPE       = FROM%POTTYPE
         TO%POTLIBNAME    = FROM%POTLIBNAME
         TO%POTSUBLIBNAME = FROM%POTSUBLIBNAME

         TO%proKWDList    = FROM%proKWDList
         TO%proAutoLoad   = FROM%proAutoLoad
         call Copy_StatementList(FROM%proKWDStatment, TO%proKWDStatment)
        return
   end subroutine CopyInformation_SimMDBox
  !***************************************************************************

  !*********************************************************************
   subroutine Copy_SimMDBox0(From, To)
      !***  PURPOSE:   to copy a simulation box to another
      !     INPUT:     From, the source simulation box
      !     OUTPUT     To, the copy of FROM
      implicit none

      !--- DUMMY variables
      type(SimMDBox)::From, TO
      !--- Local variables
      integer::NP

         call Release_SimMDBox(TO)
         call CopyInformation_SimMDBox(FROM, TO)
         TO%TEMPERATURE   = FROM%TEMPERATURE
         TO%VOLUME        = FROM%VOLUME

         TO%NPRT         = FROM%NPRT
         TO%NA           = FROM%NA
         TO%IPA          = FROM%IPA
         !--- NOTE: the size of the array could be larger than FROM%NPRT
         NP              = 0
         if(allocated(FROM%ITYP)) NP = size(FROM%ITYP)
         if(NP .le. 0) return

          if(allocated(FROM%EPOT)) then
             allocate(TO%EPOT(NP))
             TO%EPOT = FROM%EPOT
          end if

          if(allocated(FROM%EKIN)) then
             allocate(TO%EKIN(NP))
             TO%EKIN = FROM%EKIN
          end if

          if(allocated(FROM%ITYP)) then
             allocate(TO%ITYP(NP))
             TO%ITYP = FROM%ITYP
          end if

          if(allocated(FROM%XP)) then
             allocate(TO%XP(NP,3))
             TO%XP = FROM%XP
          end if

          if(allocated(FROM%XP1)) then
             allocate(TO%XP1(NP,3))
             TO%XP1 = FROM%XP1
          end if

          if(allocated(FROM%DIS)) then
             allocate(TO%DIS(NP,3))
             TO%DIS = FROM%DIS
          end if

          if(allocated(FROM%XP2)) then
             allocate(TO%XP2(NP,3))
             TO%XP2 = FROM%XP2
          end if

          if(allocated(FROM%XP3)) then
             allocate(TO%XP3(NP,3))
             TO%XP3 = FROM%XP3
          end if

          if(allocated(FROM%XP4)) then
             allocate(TO%XP4(NP,3))
             TO%XP4 = FROM%XP4
          end if

          if(allocated(FROM%XP5)) then
             allocate(TO%XP5(NP,3))
             TO%XP5 = FROM%XP5
          end if

          if(allocated(FROM%FP)) then
             allocate(TO%FP(NP,3))
             TO%FP = FROM%FP
          end if

          if(allocated(FROM%STATU)) then
             allocate(TO%STATU(NP))
             TO%STATU = FROM%STATU
          end if
          !$$--- to copy the external data
          TO%ptrDatPad = FROM%ptrDatPad

        return
  end subroutine Copy_SimMDBox0
  !***************************************************************************

  !*********************************************************************
  subroutine Copy_SimMDBox1(From, To, ByType)
   !***  PURPOSE:   to copy the particle of given type from a box to another
   !     INPUT:     From, the source simulation box
   !                ByType, the of particles to be copy
   !     OUTPUT     To, the copy of FROM
   implicit none

   !--- DUMMY variables
   type(SimMDBox)::From, TO
   integer            ::ByType
   !--- Local variables
   integer::NP, I, IP, ID, NDAT, DIM(2)
   character::dtyp
   type(DataPad), dimension(:), allocatable::PDatF, PDatT

      call Release_SimMDBox(TO)
      call CopyInformation_SimMDBox(FROM, TO)
      TO%TEMPERATURE   = FROM%TEMPERATURE
      TO%VOLUME        = FROM%VOLUME

      TO%NPRT         = count(FROM%ITYP.eq. ByType)
      TO%NA(ByType)   = TO%NPRT
      NP              = TO%NPRT
      if(NP .le. 0) return

       if(allocated(FROM%EPOT)) allocate(TO%EPOT(NP))
       if(allocated(FROM%EKIN)) allocate(TO%EKIN(NP))
       if(allocated(FROM%ITYP)) allocate(TO%ITYP(NP))
       if(allocated(FROM%XP))   allocate(TO%XP(NP,3))
       if(allocated(FROM%XP1))  allocate(TO%XP1(NP,3))
       if(allocated(FROM%DIS))  allocate(TO%DIS(NP,3))
       if(allocated(FROM%FP))   allocate(TO%FP(NP,3))
       if(allocated(FROM%STATU))allocate(TO%STATU(NP))

       if(allocated(FROM%XP2))  allocate(TO%XP2(NP,3))
       if(allocated(FROM%XP3))  allocate(TO%XP3(NP,3))
       if(allocated(FROM%XP4))  allocate(TO%XP4(NP,3))
       if(allocated(FROM%XP5))  allocate(TO%XP5(NP,3))
       !$$--- to copy the external data
       NDAT = NumberofData_DataPad(FROM%ptrDatPad)
       if(NDAT .gt. 0) then
          allocate(PDatF(NDAT), PDatT(NDAT))
          do ID =1, NDAT
             call GetData_DataPad(ID, FROM%ptrDatPad, PDatF(ID))
             call GetSize_DataPad(ID, FROM%ptrDatPad, Dim)
             if(IsInteger_DataPad(PDatF(ID)) ) then
                dtyp = 'I'
             else
                dtyp = 'D'
             end if
             Dim(1) = NP
             call New_DataPad(PDatF(ID)%Tag, dtyp, Dim, TO%ptrDatPad)
             call GetData_DataPad(ID, TO%ptrDatPad, PDatT(ID))
          end do
       end if

       !$$TO%ptrDatPad = FROM%ptrDatPad
       IP = 0 
       do I=1, FROM%NPRT
          if(FROM%ITYP(I) .eq. ByType) then 
            IP = IP + 1
            TO%EPOT(IP)    = FROM%EPOT(I)
            TO%EKIN(IP)    = FROM%EKIN(I)
            TO%ITYP(IP)    = FROM%ITYP(I)
            TO%XP(IP,1:3)  = FROM%XP(I, 1:3)
            TO%XP1(IP,1:3) = FROM%XP1(I,1:3)
            TO%DIS(IP,1:3) = FROM%DIS(I,1:3)
            TO%FP(IP,1:3)  = FROM%FP(I, 1:3)
            TO%STATU(IP)   = FROM%STATU(I)
            if(allocated(TO%XP2)) then
               TO%XP2(IP,1:3)  =FROM%XP2(I,1:3)
               TO%XP3(IP,1:3)  =FROM%XP3(I,1:3)
               TO%XP4(IP,1:3)  =FROM%XP4(I,1:3)
               TO%XP5(IP,1:3)  =FROM%XP5(I,1:3)
            endif  
            
            do ID =1, NDAT
               if(associated(PDatF(ID)%IDATA1) ) then
                  PDatT(ID)%IDATA1(IP) = PDatF(ID)%IDATA1(I)
               end if
               if(associated(PDatF(ID)%IDATA2) ) then
                  PDatT(ID)%IDATA2(IP,:) = PDatF(ID)%IDATA2(I,:)
               end if
               if(associated(PDatF(ID)%DDATA1) ) then
                  PDatT(ID)%DDATA1(IP) = PDatF(ID)%DDATA1(I)
               end if
               if(associated(PDatF(ID)%DDATA2) ) then
                  PDatT(ID)%DDATA2(IP,:) = PDatF(ID)%DDATA2(I,:)
               end if
            end do
         
          end if
         end do                     
         if(allocated(PDatF)) deallocate(PDatF)
         if(allocated(PDatT)) deallocate(PDatT)

     return
end subroutine Copy_SimMDBox1
!***************************************************************************  

!*********************************************************************
  subroutine Copy_SimMDBox2(From, To, TypeMask)
   !***  PURPOSE:   to copy the particle of given type from a box to another
   !     INPUT:     From, the source simulation box
   !                ByType, the of particles to be copy
   !     OUTPUT     To, the copy of FROM
   implicit none

   !--- DUMMY variables
   type(SimMDBox)        ::From, TO
   integer, dimension(:) ::TypeMask
   !--- Local variables
   type(SimMDBox)::swap
   integer::I 

      call Release_SimMDBox(To)
      do I=1, size(TypeMask)
         if(TypeMask(I) .gt. 0) then
           call Copy_SimMDBox1(From, Swap, I)
           call Merge_SimMDBox(Swap, To)
         end if  
      end do
      call Release_SimMDBox(Swap)
     return
 end subroutine Copy_SimMDBox2
!***************************************************************************

!****************************************************************************
   subroutine CopyFrom_SimMDBox(To, From)
      !***  PURPOSE:   to copy a control parameter to another
      !
      !     INPUT:     From, the source simulation controal
      !     OUTPUT     To, the copy of FROM
      implicit none

      !--- DUMMY variables
      type(SimMDBox)::From, To
      !--- Local variables
         call Copy_SimMDBox0(From, To)
         return
   end subroutine CopyFrom_SimMDBox
!*********************************************************************

!*********************************************************************
   subroutine Seperate_SimMDBox(From, To)
      !***  PURPOSE:   to seperate a simulation box From to a number of independent boxes
      !                with the number of atoms in each of the boxes to be
      !                (From%NPRT)/size(To).
      !                This routine has been related to GPU applications.
      !                NOTE: the seperation boxes have the same BOXSIZE and BOXLOW,
      !                      just the number atoms are different from the source box.
      !
      !     INPUT:     From, the source simulation box
      !     OUTPUT     To, the box array
      implicit none

      !--- DUMMY variables
      type(SimMDBox)              ::From
      type(SimMDBox), dimension(:)::TO
      !--- Local variables
      integer::I, NP, NB, Scheme, IFLAG

         NB = size(TO)
         if(mod(From%NPRT, NB) .ne. 0) then
            write(*,fmt="(A)")    'MDPSCU Error: the number of atoms in source box should be a multiple number of sperattion boxes.'
            write(*,fmt="(A, I)") '             check number of source box: ', From%NPRT
            write(*,fmt="(A, I)") '             and number of seperation boxes: ', NB
            write(*,fmt="(A, I)") 'Process to be stopped'
            stop
         end if
         NP = From%NPRT/NB
         if(allocated(FROM%XP5)) then
            Scheme = 5
         else
            Scheme = 2
         end if

         do I=1, NB
            call Release_SimMDBox(TO(I))
            call CopyInformation_SimMDBox(From, To(I))
            To(I)%NPRT = NP
            call Initialize_SimMDBox(To(I), Scheme)

            if(allocated(FROM%EPOT)) &
               TO(I)%EPOT(1:NP) = FROM%EPOT((I-1)*NP+1:I*NP)

            if(allocated(FROM%EKIN)) &
               TO(I)%EKIN(1:NP) = FROM%EKIN((I-1)*NP+1:I*NP)

            if(allocated(FROM%ITYP)) &
               TO(I)%ITYP(1:NP) = FROM%ITYP((I-1)*NP+1:I*NP)

            if(allocated(FROM%XP)) &
               TO(I)%XP(1:NP, 1:3)  = FROM%XP((I-1)*NP+1:I*NP, 1:3)

            if(allocated(FROM%XP1)) &
               TO(I)%XP1(1:NP, 1:3) = FROM%XP1((I-1)*NP+1:I*NP, 1:3)

            if(allocated(FROM%DIS)) &
               TO(I)%DIS(1:NP, 1:3) = FROM%DIS((I-1)*NP+1:I*NP, 1:3)

            if(allocated(FROM%XP2)) &
               TO(I)%XP2(1:NP, 1:3) = FROM%XP2((I-1)*NP+1:I*NP, 1:3)

            if(allocated(FROM%XP3)) &
               TO(I)%XP3(1:NP, 1:3) = FROM%XP3((I-1)*NP+1:I*NP, 1:3)
            if(allocated(FROM%XP4)) &
               TO(I)%XP4(1:NP, 1:3) = FROM%XP4((I-1)*NP+1:I*NP, 1:3)

            if(allocated(FROM%XP5)) &
               TO(I)%XP5(1:NP, 1:3) = FROM%XP5((I-1)*NP+1:I*NP, 1:3)

            if(allocated(FROM%FP)) &
               TO(I)%FP(1:NP, 1:3) = FROM%FP((I-1)*NP+1:I*NP, 1:3)

            if(allocated(FROM%STATU)) &
               TO(I)%STATU(1:NP) = FROM%STATU((I-1)*NP+1:I*NP)

            call CopyFrom_DataPad(To(I)%ptrDatPad, From%ptrDatPad, (I-1)*NP+1, NP)
         end do

        return
   end subroutine Seperate_SimMDBox
  !***************************************************************************

  !*********************************************************************
   subroutine MergeBoxs_SimMDBox(From, To, MASK)
   !***  PURPOSE:   to merge a number of boxes into a single box.
   !                The number of atoms in the generated box is the summation the boxes.
   !                The box size is the envolope of all the selected boxes
   !
   !     INPUT:     From, the source simulation boxes
   !                MASK, the flag indicating which boxse to be included in the merging
   !
   !     OUTPUT     To,   the to be generated
      implicit none

      !--- DUMMY variables
      type(SimMDBox),dimension(:)          ::From
      type(SimMDBox)                       ::TO
      integer,       dimension(:), optional::MASK
      !--- Local variables
      integer::I, NP, NB, Scheme, IP, IFLAG

         NB = size(From)
         !$$--- to determine the number of atoms in the merged box
         NP = 0
         if(present(MASK)) then
            do I=1, NB
               if(MASK(I).gt.0) then
                  NP = NP + From(I)%NPRT
               end if
            end do
         else
            do I=1, NB
               NP = NP + From(I)%NPRT
            end do
         end if

         if(allocated(FROM(1)%XP5)) then
            Scheme = 5
         else
            Scheme = 2
         end if
         call Release_SimMDBox(To)
         call CopyInformation_SimMDBox(From(1), To)
         To%NPRT = NP
         To%NA   = From(1)%NA*(NP/From(1)%NPRT)
         call Initialize_SimMDBox(To, Scheme)

         IP = 0
         do I=1, NB
            if(present(MASK)) then
               if(MASK(I).le.0) cycle
            end if
            NP = FROM(I)%NPRT
            if(allocated(FROM(I)%EPOT)) &
               TO%EPOT(IP+1:IP+NP) = FROM(I)%EPOT(1:NP)

            if(allocated(FROM(I)%EKIN)) &
               TO%EKIN(IP+1:IP+NP) = FROM(I)%EKIN(1:NP)

            if(allocated(FROM(I)%ITYP)) &
               TO%ITYP(IP+1:IP+NP) = FROM(I)%ITYP(1:NP)

            if(allocated(FROM(I)%XP)) &
               TO%XP(IP+1:IP+NP, 1:3)  = FROM(I)%XP(1:NP, 1:3)

            if(allocated(FROM(I)%XP1)) &
               TO%XP1(IP+1:IP+NP, 1:3) = FROM(I)%XP1(1:NP, 1:3)

            if(allocated(FROM(I)%DIS)) &
               TO%DIS(IP+1:IP+NP, 1:3) = FROM(I)%DIS(1:NP, 1:3)

            if(allocated(FROM(I)%XP2)) &
               TO%XP2(IP+1:IP+NP, 1:3) = FROM(I)%XP2(1:NP, 1:3)

            if(allocated(FROM(I)%XP3)) &
               TO%XP3(IP+1:IP+NP, 1:3) = FROM(I)%XP3(1:NP, 1:3)

            if(allocated(FROM(I)%XP4)) &
               TO%XP4(IP+1:IP+NP, 1:3) = FROM(I)%XP4(1:NP, 1:3)

            if(allocated(FROM(I)%XP5)) &
               TO%XP5(IP+1:IP+NP, 1:3) = FROM(I)%XP5(1:NP, 1:3)

            if(allocated(FROM(I)%FP)) &
               TO%FP(IP+1:IP+NP, 1:3) = FROM(I)%FP(1:NP, 1:3)

            if(allocated(FROM(I)%STATU)) &
               TO%STATU(IP+1:IP+NP) = FROM(I)%STATU(1:NP)

            !--- to merge the external data
            call Merge_DataPad(FROM(I)%ptrDatPad, To%ptrDatPad)

            !$$----
             IP = IP + NP

            !$$--- we also merge the box size
             To%LATT   = max(To%LATT, From(I)%LATT)
             To%ZL     = max(To%ZL, From(I)%ZL)
             To%BOXLOW = min(To%BOXLOW, From(I)%BOXLOW)
             To%BOXUP  = max(To%BOXUP, From(I)%BOXUP)

         end do

        return
  end subroutine MergeBoxs_SimMDBox
  !***************************************************************************

  !*********************************************************************
   subroutine Merge_SimMDBox(From, To)
   !***  PURPOSE:   to merge two boxes into a single box.
   !                The number of atoms in the generated box is the summation of the boxes.
   !                The box size is the envolope of all the selected boxes
   !
   !     INPUT:     From, the source simulation boxes
   !
   !     OUTPUT     To,   the target to be generated
      implicit none

      !--- DUMMY variables
      type(SimMDBox)::From
      type(SimMDBox)::To
      !--- Local variables
      integer::I, Scheme
      type(SimMDBox)::Swap

         !$$--- to determine the number of atoms in the merged box
          if(To%NPRT .eq. 0) then
             call Copy_SimMDBox(From, To)
             return
          end if

         if(From%NPRT .le. 0)  return
         Swap%USEUNIT = FROM%USEUNIT
         Swap%RR        = FROM%RR
         Swap%LATT      = FROM%LATT
         Swap%BOXSHAPE  = FROM%BOXSHAPE
         Swap%BOXLOW    = min(FROM%BOXLOW, TO%BOXLOW)
         Swap%BOXUP     = max(FROM%BOXUP, TO%BOXUP)
         Swap%ZL        = max(FROM%ZL, TO%ZL)
         Swap%NGROUP    =max(FROM%NGROUP, TO%NGROUP)

         Swap%SYMB(1:From%NGROUP)  = FROM%SYMB(1:From%NGROUP)
         Swap%SYMB(1:TO%NGROUP)    = TO%SYMB(1:TO%NGROUP)
         Swap%CZ(1:From%NGROUP)    = FROM%CZ(1:From%NGROUP)
         Swap%CZ(1:TO%NGROUP)      = TO%CZ(1:TO%NGROUP)
         Swap%CM(1:From%NGROUP)    = FROM%CM(1:From%NGROUP)
         Swap%CM(1:TO%NGROUP)      = TO%CM(1:TO%NGROUP)
         Swap%PROP(1:From%NGROUP)  = FROM%PROP(1:From%NGROUP)
         Swap%PROP(1:TO%NGROUP)    = TO%PROP(1:TO%NGROUP)

         Swap%PTYPE(1:From%NGROUP,1:From%NGROUP)  = FROM%PTYPE(1:From%NGROUP,1:From%NGROUP)
         Swap%PTYPE(1:TO%NGROUP,1:TO%NGROUP)      = TO%PTYPE(1:TO%NGROUP,1:TO%NGROUP)
         Swap%POTTYPE                             = TO%POTTYPE
         Swap%POTLIBNAME                          = TO%POTLIBNAME
         Swap%POTSUBLIBNAME                       = TO%POTSUBLIBNAME

         Swap%NPRT =  From%NPRT + To%NPRT
         Swap%NA   =  0
         Swap%IPA  =  0

         if(allocated(To%XP5) .or. allocated(From%XP5)) then
            Scheme = 5
         else
            Scheme = 2
         end if
         call Initialize_SimMDBox(Swap, Scheme)

          swap%XP(1:TO%NPRT,1:3)            = TO%XP(1:TO%NPRT,1:3)
          swap%XP(TO%NPRT+1:swap%NPRT,1:3)  = FROM%XP(1:FROM%NPRT,1:3)
          swap%XP1(1:TO%NPRT,1:3)           = TO%XP1(1:TO%NPRT,1:3)
          swap%XP1(TO%NPRT+1:swap%NPRT,1:3) = FROM%XP1(1:FROM%NPRT,1:3)
          swap%FP(1:TO%NPRT,1:3)            = TO%FP(1:TO%NPRT,1:3)
          swap%FP(TO%NPRT+1:swap%NPRT,1:3)  = FROM%FP(1:FROM%NPRT,1:3)
          swap%EPOT(1:TO%NPRT)              = TO%EPOT(1:TO%NPRT)
          swap%EPOT(TO%NPRT+1:swap%NPRT)    = FROM%EPOT(1:FROM%NPRT)
          swap%EKIN(1:TO%NPRT)              = TO%EKIN(1:TO%NPRT)
          swap%EKIN(TO%NPRT+1:swap%NPRT)    = FROM%EKIN(1:FROM%NPRT)
          swap%ITYP(1:TO%NPRT)              = TO%ITYP(1:TO%NPRT)
          swap%ITYP(TO%NPRT+1:swap%NPRT)    = FROM%ITYP(1:FROM%NPRT)
          swap%DIS(1:TO%NPRT,1:3)           = TO%DIS(1:TO%NPRT,1:3)
          swap%DIS(TO%NPRT+1:swap%NPRT,1:3) = FROM%DIS(1:FROM%NPRT,1:3)
          swap%STATU(1:TO%NPRT)             = TO%STATU(1:TO%NPRT)
          swap%STATU(TO%NPRT+1:swap%NPRT)   = FROM%STATU(1:FROM%NPRT)
          do I=1, swap%NGROUP
             swap%NA(I) = count(swap%ITYP .eq. I)
          end do

          !--- to merge external data
          swap%ptrDatPad = To%ptrDatPad
          call Merge_DataPad(FROM%ptrDatPad, swap%ptrDatPad)
          To = swap
          call Release_SimMDBox(swap)
        return
  end subroutine Merge_SimMDBox
  !***************************************************************************

  !***************************************************************************
   subroutine AddAtoms_SimMDBox0(B, N, ITYP, RXP, RXP1, PROPTITLE, PROTABLE)
   !***  PURPOSE:   to add new atoms to a simulation box. 
   !     NOTE:      It is assumed the size of allocated arraies has been large enough without
   !                reallocate memory. And more, no reordering by type is needed.
   !                See also AddAtoms_SimMDBox1
   !                   
   !     INPUT:     B, the box
   !                N, number of atoms to be added
   !                ityp, the type of the atoms to be added
   !                XP, the initial position of the new atoms
   !                XP1, the initial velocity of the new atoms
   !                TYPEORDER, indicating if reorder the atoms accroding to their type
   !     OUTPUT     B, the box with number of atoms updated
   implicit none
   type(SimMDBox)                        ::B
   integer,      dimension(:)            ::N, ITYP
   real(KINDDF), dimension(:,:), optional::RXP, RXP1
   character*(*),dimension(:),   optional::PROPTITLE
   real(KINDDF), dimension(:,:), optional::PROTABLE

   !--- LOCAL variabels
   type(DataPad), pointer::ptrDatPad
   integer::NPRT, I1, I2, I, J

          !$$--- Reserve the old positions

            I1 = B%NPRT+1
            I2 = I1+sum(N)-1
            if(I2 .gt. size(B%ITYP)) then
               write(*,fmt="(A, I3, A, I3, A, I8)") &
               ' MDPSCU Error: number of atoms in SimBox is not large enough to include new atoms'
               stop
            end if 
            
            if(present(RXP) .and. allocated(B%XP) ) then
               B%XP(I1:I2,1:3) = RXP(1:N,1:3)
            end if

            if(present(RXP1) .and. allocated(B%XP1) ) then
               B%XP1(I1:I2,1:3) = RXP1(1:N,1:3)
            end if
       
            I1 = B%NPRT
            do I=1, size(N)
               do J=1, N(I)
                  I1 = I1 + 1
                  B%ITYP(I1)  = ITYP(I)
                  B%STATU(I1) = IOR(CP_STATU_ACTIVE, B%PROP(ITYP(I)))
               end do   
               B%NA(ITYP(I)) = B%NA(ITYP(I))+N(I)
            end do    
            B%NPRT = I1
            I2     = maxval(ITYP)
            if( I2 .gt. B%NGROUP) B%NGROUP = I2
          return
      end subroutine AddAtoms_SimMDBox0
  !****************************************************************************  

  !***************************************************************************
   subroutine AddAtoms_SimMDBox1(B, N, ITYPE, TYPEORDER, RXP, RXP1, PROPTITLE, PROTABLE)
   !***  PURPOSE:   to add new atoms to a simulation box
   !     INPUT:     B, the box
   !                N, number of atoms to be added
   !                itype, the type of the atoms to be added
   !                XP, the initial position of the new atoms
   !                XP1, the initial velocity of the new atoms
   !                TYPEORDER, indicating if reorder the atoms accroding to their type
   !     OUTPUT     B, the box with number of atoms updated
   implicit none
   type(SimMDBox)                         ::B
   integer,                     intent(in)::N, ITYPE
   integer,                     optional  ::TYPEORDER
   real(KINDDF), dimension(:,:),optional  ::RXP, RXP1
   character*(*),dimension(:),  optional  ::PROPTITLE
   real(KINDDF), dimension(:,:),optional  ::PROTABLE

   !--- LOCAL variabels
   real(KINDDF),  dimension(:,:),allocatable::XP, XP1, XP2, XP3, XP4, XP5, FP,DIS, TABLE
   real(KINDDF),  dimension(:),  allocatable::EPOT, EKIN
   integer,       dimension(:),  allocatable::ITYP, STATU
   type(DataPad), pointer::ptrDatPad
   integer::I, NPRT, I1, I2, NA, NT, REORDER, NPDAT, ID
   type(DataPad), dimension(:), allocatable::PDatF, PDatT
   type(DataPad), pointer::PDatList

          !$$--- Reserve the old positions
          NPRT = B%NPRT
          if(present(TYPEORDER)) then
             REORDER = TYPEORDER
          else
            !--- by default reorder is regired for comptable with previous versions
            !
             REORDER = 1
          end if
          if(NPRT .le. 0) REORDER = 0

          !---
          if(allocated(B%ITYP)) then
             allocate(ITYP(NPRT))
             ITYP = B%ITYP
             deallocate(B%ITYP)
          end if
          allocate(B%ITYP(NPRT+N))
          B%ITYP = 0

          !---
          if(allocated(B%XP)) then
             allocate(XP(NPRT,3))
             XP = B%XP
             deallocate(B%XP)
          end if
          allocate(B%XP(NPRT+N,3))
          B%XP = C_ZERO

          !---
          if(allocated(B%XP1)) then
             allocate(XP1(NPRT,3))
             XP1 = B%XP1
             deallocate(B%XP1)
          end if
          allocate(B%XP1(NPRT+N,3))
          B%XP1 = C_ZERO

          !---
          if(allocated(B%DIS)) then
             allocate(DIS(NPRT,3))
             DIS = B%DIS
             deallocate(B%DIS)
          end if
          allocate(B%DIS(NPRT+N,3))
          B%DIS = C_ZERO

          !---
          if(allocated(B%XP2)) then
             allocate(XP2(NPRT,3))
             XP2 = B%XP2
             deallocate(B%XP2)
             allocate(B%XP2(NPRT+N,3))
             B%XP2 = C_ZERO
          end if

          !---
          if(allocated(B%XP3)) then
             allocate(XP3(NPRT,3))
             XP3 = B%XP3
             deallocate(B%XP3)
             allocate(B%XP3(NPRT+N,3))
             B%XP3 = C_ZERO
          end if

          !---
          if(allocated(B%XP4)) then
             allocate(XP4(NPRT,3))
             XP4 = B%XP4
             deallocate(B%XP4)
             allocate(B%XP4(NPRT+N,3))
             B%XP4 = C_ZERO
          end if

          !---
          if(allocated(B%XP5)) then
             allocate(XP5(NPRT,3))
             XP5 = B%XP5
             deallocate(B%XP5)
             allocate(B%XP5(NPRT+N,3))
             B%XP5 = C_ZERO
          end if

          !---
          if(allocated(B%FP)) then
             allocate(FP(NPRT,3))
             FP = B%FP
             deallocate(B%FP)
          end if
          allocate(B%FP(NPRT+N,3))
          B%FP = C_ZERO

          !---
          if(allocated(B%EPOT)) then
             allocate(EPOT(NPRT))
             EPOT = B%EPOT
             deallocate(B%EPOT)
          end if
          allocate(B%EPOT(NPRT+N))
          B%EPOT = C_ZERO

          !---
          if(allocated(B%EKIN)) then
             allocate(EKIN(NPRT))
             EKIN = B%EKIN
             deallocate(B%EKIN)
          end if
          allocate(B%EKIN(NPRT+N))
          B%EKIN = C_ZERO

          !---
          if(allocated(B%STATU)) then
             allocate(STATU(NPRT))
             STATU = B%STATU
             deallocate(B%STATU)
          end if
          allocate(B%STATU(NPRT+N))
          B%STATU = IOR(CP_STATU_ACTIVE, B%PROP(ITYPE))

          !$$--- to change the size of the external data
          NPDAT = NumberofData_DataPad(B%ptrDatPad)
          if(NPDAT .gt. 0) then
             allocate(PDatF(NPDAT), PDatT(NPDAT))
             PDatList = B%ptrDatPad
             call ChangeSize_DataPad(NPRT+N, B%ptrDatPad)
             do ID =1, NPDAT
                call GetData_DataPad(ID, PDatList, PDatF(ID))
                call GetData_DataPad(ID, B%ptrDatPad, PDatT(ID))
             end do
          end if

          !--- clear the old values
          if(REORDER .gt. 0) then
             if(ITYPE .gt. B%NGROUP) then
               B%NGROUP = ITYPE
             end if
             I1 = 0 
             do I=1, B%NGROUP
                do I2=1, NPRT
                   !--- copy back the old atom
                   if(ITYP(I2) .eq. I) then
                      I1 = I1 + 1
                      B%ITYP(I1)  = ITYP(I2)
                      B%XP(I1,:)  = XP(I2,:)
                      B%XP1(I1,:) = XP1(I2,:)
                      B%DIS(I1,:) = DIS(I2,:)
                      B%FP(I1,:)  = FP(I2,:)
                      B%EPOT(I1)  = EPOT(I2)
                      B%EKIN(I1)  = EKIN(I2)
                      B%STATU(I1) = STATU(I2)
                      if(allocated(XP2))  B%XP2(I1,:) = XP2(I2,:)
                      if(allocated(XP3))  B%XP3(I1,:) = XP3(I2,:)
                      if(allocated(XP4))  B%XP4(I1,:) = XP4(I2,:)
                      if(allocated(XP5))  B%XP5(I1,:) = XP5(I2,:)
                      do ID =1, NPDAT
                        if(associated(PDatF(ID)%IDATA1) ) then
                           PDatT(ID)%IDATA1(I1) = PDatF(ID)%IDATA1(I2)
                        end if
                        if(associated(PDatF(ID)%IDATA2) ) then
                           PDatT(ID)%IDATA2(I1,:) = PDatF(ID)%IDATA2(I2,:)
                        end if
                        if(associated(PDatF(ID)%DDATA1) ) then
                           PDatT(ID)%DDATA1(I1) = PDatF(ID)%DDATA1(I2)
                        end if
                        if(associated(PDatF(ID)%DDATA2) ) then
                           PDatT(ID)%DDATA2(I1,:) = PDatF(ID)%DDATA2(I2,:)
                        end if
                     end do
                   end if 
                end do   
                !--- add the new atom
                if(I .eq. ITYPE) then
                   do I2=1, N
                      I1 = I1 + 1
                      B%ITYP(I1) = ITYPE
                      if(present(RXP)) then
                         B%XP(I1,:) = RXP(I2,:)
                      end if
             
                      if(present(RXP1) ) then
                         B%XP1(I1,:) = RXP1(I2,:)
                      end if
                   end do 
                end if  
             end do !--- end loop for groups
             !--- modify the number of atoms in B
             B%NA(ITYPE) = B%NA(ITYPE)+N
             B%NPRT      = B%NPRT + N
          !---- for no reorder needed  
          else
            B%ITYP(1:NPRT)    = ITYP(1:NPRT)
            B%XP(1:NPRT,1:3)  = XP(1:NPRT,1:3)
            B%XP1(1:NPRT,1:3) = XP1(1:NPRT,1:3)
            B%DIS(1:NPRT,1:3) = DIS(1:NPRT,1:3)
            if(allocated(XP2))  B%XP2(1:NPRT,1:3) = XP2(1:NPRT,1:3)
            if(allocated(XP3))  B%XP3(1:NPRT,1:3) = XP3(1:NPRT,1:3)
            if(allocated(XP4))  B%XP4(1:NPRT,1:3) = XP4(1:NPRT,1:3)
            if(allocated(XP5))  B%XP5(1:NPRT,1:3) = XP5(1:NPRT,1:3)
            B%FP(1:NPRT,1:3)  =  FP(1:NPRT,1:3)
            B%EPOT(1:NPRT)    =  EPOT(1:NPRT)
            B%EKIN(1:NPRT)    =  EKIN(1:NPRT)
            B%STATU(1:NPRT)   =  STATU(1:NPRT)

            I1 = NPRT+1
            I2 = I1+N-1

            B%ITYP(I1:I2) = ITYPE
            if(present(RXP) .and. allocated(B%XP) ) then
               B%XP( I1:I2,1:3) = RXP(1:N,1:3)
            end if

            if(present(RXP1) .and. allocated(B%XP1) ) then
               B%XP1(I1:I2,1:3) = RXP1(1:N,1:3)
            end if

            B%NA(ITYPE) = B%NA(ITYPE)+N
            B%NPRT = B%NPRT + N
          end if

          if(ITYPE .gt. B%NGROUP) then
             B%NGROUP = ITYPE
          end if

         !$$--- release allocated temp memory
          if(allocated(ITYP)) deallocate(ITYP)
          if(allocated(XP))   deallocate(XP)
          if(allocated(XP1))  deallocate(XP1)
          if(allocated(XP2))  deallocate(XP2)
          if(allocated(XP3))  deallocate(XP3)
          if(allocated(XP4))  deallocate(XP4)
          if(allocated(XP5))  deallocate(XP5)
          if(allocated(DIS))  deallocate(DIS)
          if(allocated(FP))   deallocate(FP)
          if(allocated(EPOT)) deallocate(EPOT)
          if(allocated(EKIN)) deallocate(EKIN)
          if(allocated(STATU)) deallocate(STATU)
          if(allocated(TABLE)) deallocate(TABLE)

          if(associated(PDatList)) then
             call Release_DataPad(PDatList)
          end if
          if(allocated(PDatF)) deallocate(PDatF)
          if(allocated(PDatT)) deallocate(PDatT)

          return
      end subroutine AddAtoms_SimMDBox1
  !****************************************************************************

  !*********************************************************************
  subroutine DelAtom_SimMDBox(B, IA)
      !***  PURPOSE:   to delete an atom from a simulation box
      !     INPUT:     B,  the box
      !                IA, the ID of the atom to be deleted
      !     OUTPUT     B, the box with number of atoms updated
      implicit none
      type(SimMDBox)    ::B
      integer,intent(in)::IA
      !--- LOCAL variabels
      real(KINDDF), dimension(:,:),allocatable::XP, XP1, XP2, XP3, XP4, XP5, FP,DIS
      real(KINDDF), dimension(:),  allocatable::EPOT, EKIN
      integer, dimension(:), allocatable::ITYP, STATU
      integer::I, IV,NPRT, IT
          !Reserve the old positions

          NPRT = B%NPRT
          IT   = B%ITYP(IA)

          !---
          if(allocated(B%ITYP)) then
             allocate(ITYP(NPRT))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                ITYP(IV) = B%ITYP(I)
             end do
             deallocate(B%ITYP)
             allocate(B%ITYP(NPRT-1))
             B%ITYP(1:NPRT-1) = ITYP(1:NPRT-1)
          end if

          !---
          if(allocated(B%XP)) then
             allocate(XP(NPRT,3))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                XP(IV,1:3) = B%XP(I,1:3)
             end do
             deallocate(B%XP)
             allocate(B%XP(NPRT-1,3))
             B%XP(1:NPRT-1,1:3) = XP(1:NPRT-1,1:3)
          end if

          !---
          if(allocated(B%XP1)) then
             allocate(XP1(NPRT,3))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                XP1(IV,1:3) = B%XP1(I,1:3)
             end do
             deallocate(B%XP1)
             allocate(B%XP1(NPRT-1,3))
             B%XP1(1:NPRT-1,1:3) = XP1(1:NPRT-1,1:3)
          end if

          !---
          if(allocated(B%XP2)) then
             allocate(XP2(NPRT,3))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                XP2(IV,1:3) = B%XP2(I,1:3)
             end do
             deallocate(B%XP2)
             allocate(B%XP2(NPRT-1,3))
             B%XP2(1:NPRT-1,1:3) = XP2(1:NPRT-1,1:3)
          end if

          !---
          if(allocated(B%XP3)) then
             allocate(XP3(NPRT,3))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                XP3(IV,1:3) = B%XP3(I,1:3)
             end do
             deallocate(B%XP3)
             allocate(B%XP3(NPRT-1,3))
             B%XP3(1:NPRT-1,1:3) = XP3(1:NPRT-1,1:3)
          end if

          !---
          if(allocated(B%XP4)) then
             allocate(XP4(NPRT,3))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                XP4(IV,1:3) = B%XP4(I,1:3)
             end do
             deallocate(B%XP4)
             allocate(B%XP4(NPRT-1,3))
             B%XP4(1:NPRT-1,1:3) = XP4(1:NPRT-1,1:3)
          end if

          !---
          if(allocated(B%XP5)) then
             allocate(XP5(NPRT,3))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                XP5(IV,1:3) = B%XP5(I,1:3)
             end do
             deallocate(B%XP5)
             allocate(B%XP5(NPRT-1,3))
             B%XP5(1:NPRT-1,1:3) = XP5(1:NPRT-1,1:3)
          end if

          !---
          if(allocated(B%FP)) then
             allocate(FP(NPRT,3))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                FP(IV,1:3) = B%FP(I,1:3)
             end do
             deallocate(B%FP)
             allocate(B%FP(NPRT-1,3))
             B%FP(1:NPRT-1,1:3) = FP(1:NPRT-1,1:3)
          end if

          !---
          if(allocated(B%DIS)) then
             allocate(DIS(NPRT,3))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                DIS(IV,1:3) = B%DIS(I,1:3)
             end do
             deallocate(B%DIS)
             allocate(B%DIS(NPRT-1,3))
             B%DIS(1:NPRT-1,1:3) = DIS(1:NPRT-1,1:3)
          end if

          !---
          if(allocated(B%EPOT)) then
             allocate(EPOT(NPRT))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                EPOT(IV) = B%EPOT(I)
             end do
             deallocate(B%EPOT)
             allocate(B%EPOT(NPRT-1))
             B%EPOT(1:NPRT-1) = EPOT(1:NPRT-1)
          end if


          !---
          if(allocated(B%EKIN)) then
             allocate(EKIN(NPRT))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                EKIN(IV) = B%EKIN(I)
             end do
             deallocate(B%EKIN)
             allocate(B%EKIN(NPRT-1))
             B%EKIN(1:NPRT-1) = EKIN(1:NPRT-1)
          end if

          !---
          if(allocated(B%STATU)) then
             allocate(STATU(NPRT))
             IV = 0
             do I=1,NPRT
                IF(I .EQ. IA) cycle
                IV = IV + 1
                STATU(IV) = B%STATU(I)
             end do
             deallocate(B%STATU)
             allocate(B%STATU(NPRT-1))
             B%STATU(1:NPRT-1) = STATU(1:NPRT-1)
          end if
          !---
          call DelElement_DataPad(IA, B%ptrDatPad)

          !---
          B%NA(IT) = B%NA(IT) - 1
          B%IPA(1) = 1
          do I=2,B%NGROUP+1
             B%IPA(I) = B%IPA(I-1)+B%NA(I-1)
          end do
          B%NPRT = NPRT - 1

         !$$--- release allocated temp memory
          if(allocated(ITYP)) deallocate(ITYP)
          if(allocated(XP))   deallocate(XP)
          if(allocated(XP1))  deallocate(XP1)
          if(allocated(XP2))  deallocate(XP2)
          if(allocated(XP3))  deallocate(XP3)
          if(allocated(XP4))  deallocate(XP4)
          if(allocated(XP5))  deallocate(XP5)
          if(allocated(DIS))  deallocate(DIS)
          if(allocated(FP))   deallocate(FP)
          if(allocated(EPOT)) deallocate(EPOT)
          if(allocated(EKIN)) deallocate(EKIN)
          if(allocated(STATU))deallocate(STATU)

          return
      end subroutine DelAtom_SimMDBox
  !****************************************************************************

  !***************************************************************************
      subroutine ReplaceAtomByInd_SimMDBox(B, IA, NTY, VEL)
      !***  PURPOSE:   to replace an atom IA by new type
      !     INPUT:     B,   the box
      !                IA,  the ID of the atom to be replaced
      !                NTY, the new type of the atom
      !                VEL, optional, new velocity
      !     OUTPUT     B, the box with number of atoms updated
      implicit none
      type(SimMDBox)                    ::B
      integer,                intent(in)::IA, NTY
      real(KINDDF), optional, intent(in)::VEL(3)
      !--- LOCAL variabels
      real(KINDDF)::XP(3), XP1(3), XP2(3), XP3(3), XP4(3), XP5(3), FP(3), DIS(3)
      real(KINDDF)::EPOT, EKIN
      integer::ITYP, STATU
      integer::ID

          !Reserve the old positions
           XP(1:3)  = B%XP(IA, 1:3)
           XP1(1:3) = B%XP1(IA, 1:3)
           if(present(VEL)) XP1(1:3)= VEL(1:3)
           XP2(1:3) = B%XP2(IA, 1:3)
           if(allocated(B%XP3)) then
              XP3(1:3) = B%XP3(IA,1:3)
           end if
           if(allocated(B%XP4)) then
              XP4(1:3) = B%XP4(IA,1:3)
           end if
           if(allocated(B%XP5)) then
              XP5(1:3) = B%XP5(IA,1:3)
           end if

           FP(1:3)  = B%FP(IA, 1:3)
           DIS(1:3) = B%DIS(IA, 1:3)
           EPOT     = B%EPOT(IA)
           EKIN     = B%EKIN(IA)
           STATU    = IOR(B%STATU(IA), B%PROP(NTY))
           ITYP     = B%ITYP(IA)

           call  DelAtom_SimMDBox(B, IA)
           call  AddAtoms_SimMDBox(B, 1, NTY, TYPEORDER=1)

           !$$--- recover the statu of the atom
           !$$--- the id of the atom has been changed
           ID = B%IPA(NTY) + B%NA(NTY) - 1
           B%XP(ID, 1:3)  = XP(1:3)
           B%XP1(ID, 1:3) = XP1(1:3)
           XP2(1:3) = B%XP2(ID, 1:3)
           if(allocated(B%XP3)) then
              B%XP3(ID,1:3) = XP3(1:3)
           end if
           if(allocated(B%XP4)) then
              B%XP4(ID,1:3) = XP4(1:3)
           end if
           if(allocated(B%XP5)) then
              B%XP5(ID,1:3) = XP5(1:3)
           end if

           B%FP(ID, 1:3)    = FP(1:3)
           B%DIS(ID, 1:3)   = DIS(1:3)
           B%EPOT(ID)       = EPOT
           B%EKIN(ID)       = EKIN
           B%STATU(ID)      = STATU
          return
      end subroutine ReplaceAtomByInd_SimMDBox
  !****************************************************************************

  !***************************************************************************
      subroutine ReplaceAtomByPos_SimMDBox(B, Pos, Nty, VEL)
      !***  PURPOSE:   to replace an atom cloest to a given position
      !     INPUT:     B,   the box
      !                Pos, the position
      !                NTY, the new type of the atom
      !     OUTPUT     B, the box with number of atoms updated
      implicit none
      type(SimMDBox)                   ::B
      real(KINDDF),          intent(in)::Pos(3)
      integer,               intent(in)::NTY
      real(KINDDF),optional, intent(in)::VEL(3)
      !--- LOCAL variabels
      integer::ID

           ID = NearestAtomID_SimMDBox(B, Pos)
           if(present(VEL)) then
              call ReplaceAtomByInd_SimMDBox(B, ID, Nty, VEL)
           else
              call ReplaceAtomByInd_SimMDBox(B, ID, Nty)
           end if
          return
      end subroutine ReplaceAtomByPos_SimMDBox
  !****************************************************************************

  !***************************************************************************
      integer function NearestAtomID_SimMDBox(B, Pos) result(ID)
      !***  PURPOSE:   to get the index closest tot given poisiotn
      !     INPUT:     B,   the box
      !                Pos, the position
      !                NTY, the new type of the atom
      !     OUTPUT     B, the box with number of atoms updated
      implicit none
      type(SimMDBox)          ::B
      real(KINDDF), intent(in)::Pos(3)
      !--- LOCAL variabels
      real(KINDDF)::SEP(3), DIS, DMI
      integer::I

           DMI = 1.D64
           do I=1, B%NPRT
              SEP(1:3) = B%XP(I, 1:3)-Pos(1:3)
              DIS      = sum(SEP*SEP)
              if(DIS .lt. DMI) then
                 DMI = DIS
                 ID = I
              end if
           end do
          return
      end function NearestAtomID_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Keep_Cluster_Zero_Translation_SimMDBox(Simbox,DIR, ID)
  !***  PURPOSE: to keep the translation velocity of a subbox to be zero
  !     INPUT:     ID, the ID for the subsample
  !                DIR, the direction in which the translation should be zero
  !
  !     OUTPUT     Simbox

  !
  implicit none
      !--- DUMMY variables
      type(SimMDBox)               ::SimBox
      integer, intent(in)          ::DIR(3)
      integer, intent(in), optional::ID
      !--- Local variables
      integer::I1, I2
      real(KINDDF)::Vc

  !$$*** to keep the velocity of the center of mass a zero
      if(present(ID)) then
         I1 = SimBox%IPA(ID)
         I2 = SimBox%IPA(ID+1)-1
      else
         I1 = 1
         I2 = SimBox%NPRT
      end if

      if(DIR(1) .gt. 0) then
         Vc = sum(SimBox%XP1(I1:I2,1))/dble(I2-I1+1)
         SimBox%XP1(I1:I2,1) = SimBox%XP1(I1:I2,1) - Vc
      end if

      if(DIR(2) .gt. 0) then
         Vc = sum(SimBox%XP1(I1:I2,2))/dble(I2-I1+1)
         SimBox%XP1(I1:I2,2) = SimBox%XP1(I1:I2,2) - Vc
      end if

      if(DIR(3) .gt. 0) then
        Vc = sum(SimBox%XP1(I1:I2,3))/dble(I2-I1+1)
        SimBox%XP1(I1:I2,3) = SimBox%XP1(I1:I2,3) - Vc
      end if

      return
  end subroutine Keep_Cluster_Zero_Translation_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Set_Cluster_Translate_Energy_SimMDBox(Simbox, ID, E0, DIRECT)
  !***  PURPOSE: to accelerate a subsample to a translate energy
  !     INPUT:     Simbox
  !                ID, the ID for the subsample
  !                E0, the translate energy/atom to be set
  !                DIRECT, the direction the cluster to move
  !
  !     OUTPUT     Simbox, the simulation box wiht its IDth cluster having kinetic energy E0
  !

  implicit none
      !--- DUMMY variables
      type(SimMDBox)                    ::SimBox
      real(KINDDF), intent(in)          ::E0, DIRECT(3)
      integer,      intent(in), optional::ID
      !--- Local variables
      integer::I1, I2
      real(KINDDF)::Vcx, Vcy, Vcz, Nx, Ny, Nz, N

        I1 = SimBox%IPA(ID)
        I2 = SimBox%IPA(ID+1)-1
  !$$*** first, to set the subsample at a zero translation
        Vcx = sum(SimBox%XP1(I1:I2,1))/dble(I2-I1+1)
        Vcy = sum(SimBox%XP1(I1:I2,2))/dble(I2-I1+1)
        Vcz = sum(SimBox%XP1(I1:I2,3))/dble(I2-I1+1)

        SimBox%XP1(I1:I2,1) = SimBox%XP1(I1:I2,1) - Vcx
        SimBox%XP1(I1:I2,2) = SimBox%XP1(I1:I2,2) - Vcy
        SimBox%XP1(I1:I2,3) = SimBox%XP1(I1:I2,3) - Vcz

  !$$*** get the translate velocity to be set
        N  = dsqrt(DIRECT(1)**2+DIRECT(2)**2+DIRECT(3)**2)
        Nx = DIRECT(1)/N
        Ny = DIRECT(2)/N
        Nz = DIRECT(3)/N

        N = (E0*C_TWO)/SimBox%CM(ID)
        N = dsqrt(N)
        Vcx = N*Nx
        Vcy = N*Ny
        Vcz = N*Nz

  !$$*** to accelerate the atoms
       SimBox%XP1(I1:I2,1) = SimBox%XP1(I1:I2,1) + Vcx
       SimBox%XP1(I1:I2,2) = SimBox%XP1(I1:I2,2) + Vcy
       SimBox%XP1(I1:I2,3) = SimBox%XP1(I1:I2,3) + Vcz

      return
  end subroutine Set_Cluster_Translate_Energy_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Get_Cluster_Translate_Energy_SimMDBox(Simbox, ID, E0)
  !***  PURPOSE: to get translate energy of a cluster
  !     INPUT:     ID, the ID for thecluster
  !     OUTPUT;    E0, the translate energy/atom to be set
  !                DIRECT, the direction to move
  !
  implicit none
      !--- DUMMY variables
      type(SimMDBox), intent(in)::SimBox
      integer,        intent(in)::ID
      real(KINDDF),   intent(out)::E0
      !--- LOCAL variables
      integer::I1, I2
      real(KINDDF)::Vcx, Vcy, Vcz

      I1 = SimBox%IPA(ID)
      I2 = SimBox%IPA(ID+1)-1
      Vcx = sum(SimBox%XP1(I1:I2,1))/dble(I2-I1+1)
      Vcy = sum(SimBox%XP1(I1:I2,2))/dble(I2-I1+1)
      Vcz = sum(SimBox%XP1(I1:I2,3))/dble(I2-I1+1)
      E0 = (Vcx**2+Vcy**2+Vcz**2)*SimBox%CM(ID)/C_TWO/CP_EVERG

      return
  end subroutine Get_Cluster_Translate_Energy_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Keep_Box_Zero_Translation_SimMDBox(Simbox)
  !***  PURPOSE: to keep the translation velocity of a box to be zero
  !     INPUT:     ID, the ID for the subsample
  !                DIR, the direction in which the translation should be zero
  !
  !     OUTPUT     Simbox

  !
  implicit none
      !--- DUMMY variables
      type(SimMDBox)::SimBox
      !--- Local variables
      integer::I, I1, I2
      real(KINDDF)::Vcx, Vcy, Vcz, TCM

      !$$*** to keep the velocity of the center of mass of whole box being zero
      Vcx = 0.D0
      Vcy = 0.D0
      Vcz = 0.D0
      TCM = 0.D0
      do I=1, SimBox%NGROUP
         I1 = SimBox%IPA(I)
         I2 = SimBox%IPA(I+1)-1
         Vcx = Vcx+sum(SimBox%XP1(I1:I2,1))*SimBox%CM(I)
         Vcy = Vcy+sum(SimBox%XP1(I1:I2,2))*SimBox%CM(I)
         Vcz = Vcz+sum(SimBox%XP1(I1:I2,3))*SimBox%CM(I)
         TCM = TCM+SimBox%CM(I)*dble(I2-I1+1)
      end do
      Vcx  = Vcx/TCM
      Vcy  = Vcy/TCM
      Vcz  = Vcz/TCM

      do I=1, SimBox%NGROUP
         I1 = SimBox%IPA(I)
         I2 = SimBox%IPA(I+1)-1
         SimBox%XP1(I1:I2,1) = SimBox%XP1(I1:I2,1) - Vcx
         SimBox%XP1(I1:I2,2) = SimBox%XP1(I1:I2,2) - Vcy
         SimBox%XP1(I1:I2,3) = SimBox%XP1(I1:I2,3) - Vcz
      end do


      return
  end subroutine Keep_Box_Zero_Translation_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Thermalize_Cluster_SimMDBox(SimBox,ID, TL)
  !***  PURPOSE:   to thermalize a cluster with ID to a local temperature TL
  !     INPUT:     SimBox, the simulation box to be thermalized
  !                ID,     the ID of the cluster to be thermalized
  !                TL,     the temperature the cluster ID to be thermalized to
  !     OUTPUT     SimBox,
  use RAND32_MODULE, only:RANF=>DRAND32
  IMPLICIT NONE
      !--- DUMMY variables
      type(SimMDBox)          ::SimBox
      integer,      intent(in)::ID
      real(KINDDF), intent(in)::TL

      !--- Local variables
      real(KINDDF)::V0,VTx, VTy, VTz, VTx0, VTy0, VTz0, Z1, Z2
      real(KINDDF), dimension(:), pointer::RVPx, RVPy, RVPz
      integer::K,I, I1, I2, NA

        I1 = SimBox%IPA(ID)
        I2 = SimBox%IPA(ID+1)-1

        !$$*** the origianl translate velocity
        NA = SimBox%NA(ID)
        VTx0 = sum(SimBox%XP1(I1:I2,1))/dble(NA)
        VTy0 = sum(SimBox%XP1(I1:I2,2))/dble(NA)
        VTz0 = sum(SimBox%XP1(I1:I2,3))/dble(NA)

        !***
        allocate(RVPx(NA), RVPy(NA), RVPz(NA))
        V0 = dsqrt( C_TWO*TL*CP_KB/SimBox%CM(ID))
        VTx = C_ZERO
        VTy = C_ZERO
        VTz = C_ZERO
        RVPx = C_ZERO
        RVPy = C_ZERO
        RVPz = C_ZERO

        do I=1, NA
           Z1 = RANF()
           Z2 = RANF()
           RVPx(I)=V0*SQRT(-LOG(Z1))*COS(CP_TWOPI*Z2)
           VTx =VTx + RVPx(I)
        end do

        do I=1, NA
           Z1 = RANF()
           Z2 = RANF()
           RVPy(I)=V0*SQRT(-LOG(Z1))*COS(CP_TWOPI*Z2)
           VTy =VTy + RVPy(I)
        end do

        do I=1, NA
           Z1 = RANF()
           Z2 = RANF()
           RVPz(I)=V0*SQRT(-LOG(Z1))*COS(CP_TWOPI*Z2)
           VTz =VTz + RVPz(I)
        end do

        VTx = VTx/dble(NA)
        VTy = VTy/dble(NA)
        VTz = VTz/dble(NA)

        VTx = VTx0 - VTx
        VTy = VTy0 - VTy
        VTz = VTz0 - VTz

        K = I1
        do I=1, NA
           SimBox%XP1(K,1) = RVPx(I) + VTx
           SimBox%XP1(K,2) = RVPy(I) + VTy
           SimBox%XP1(K,3) = RVPz(I) + VTz
           K = K + 1
        end do

       deallocate(RVPx,RVPy, RVPz)
      return
  end subroutine Thermalize_Cluster_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Thermalize_SimMDBox(SimBox, TL, METHOD, IK0)
  !***  PURPOSE:   to thermalize a set of clusters or the whole simulation box by
  !                by selected method
  !
  !     INPUT:     SimBox, the simulation box to be thermalized
  !                TL,     the temperature the box to be thermalized to
  !                METHOD, the method to thermalize the box
  !                IK0,    the logical flags to determine if a group of atoms will be thermalized,
  !                        this is optional, if IK0 is not present, the whole box will be thermalized
  !
  !     OUTPUT     SimBox, with velocities of atoms assigned
  implicit NONE
      !--- DUMMY variables
      type(SimMDBox)                           ::SimBox
      real(KINDDF),         intent(in)         ::TL
      integer,              intent(in)         ::METHOD
      logical, dimension(:),intent(in), optional::IK0

           select case(METHOD)
                 case (CP_THERMALSCHEME_MC)
                      if(present(IK0) ) then
                         call Thermalize_MC_SimMDBox(SimBox, TL, IK0)
                      else
                         call Thermalize_MC_SimMDBox(SimBox, TL)
                      end if
                 case (CP_THERMALSCHEME_VSCAL)
                      if(present(IK0) ) then
                         call Thermalize_VSCAL_SimMDBox(SimBox, TL, IK0)
                      else
                         call Thermalize_VSCAL_SimMDBox(SimBox, TL)
                      end if
                 case (CP_THERMALSCHEME_PSCAL)
                      if(present(IK0) ) then
                         call Thermalize_PSCAL_SimMDBox(SimBox, TL, IK0)
                      else
                         call Thermalize_PSCAL_SimMDBox(SimBox, TL)
                      end if

          end select
          return
  end subroutine Thermalize_SimMDBox
  !****************************************************************************
  subroutine Thermalize_MC_SimMDBox(SimBox, TL, IK0)
  !***  PURPOSE:   to thermalize a set of clusters or the whole simulation box by
  !                by assign the atoms velocities generated by MC sampling on the
  !                Maxwell ditribution
  !
  !     INPUT:     SimBox, the simulation box to be thermalized
  !                TL,     the temperature the box to be thermalized to
  !                IK0,    the logical flags to determine if a group of atoms will be thermalized,
  !                        this is optional, if IK0 is not present, the whole box will be thermalized
  !
  !     OUTPUT     SimBox, with velocities of atoms assigned
  use RAND32_MODULE, only:RANF=>DRAND32
  IMPLICIT NONE
      !--- DUMMY variables
      type(SimMDBox)                            ::SimBox
      real(KINDDF),         intent(in)          ::TL
      logical, dimension(:),intent(in), optional::IK0

      !---Loacal variables
      real(KINDDF)::VTx, VTy, VTz, WT, Z1, Z2
      real(KINDDF), dimension(:), pointer::V0, RVPx, RVPy, RVPz
      logical, dimension(:), pointer::IK
      integer::K,I

      !******
      allocate(V0(SimBox%NGROUP),RVPx(SimBox%NPRT), RVPy(SimBox%NPRT), RVPz(SimBox%NPRT),IK(SimBox%NGROUP))
      V0 = DSQRT( C_TWO*TL*CP_KB/SimBox%CM)
      VTx = C_ZERO
      VTy = C_ZERO
      VTz = C_ZERO
      RVPx = C_ZERO
      RVPy = C_ZERO
      RVPz = C_ZERO
      IK = .TRUE.
      if(present(IK0)) IK = IK0

      WT = sum(SimBox%NA*SimBox%CM)

      do K=1, SimBox%NGROUP
         if(IK(K)) then
           do I=SimBox%IPA(K), SimBox%IPA(K+1)-1
              Z1 = RANF()
              Z2 = RANF()
              RVPx(I)=V0(k)*SQRT(-LOG(Z1))*COS(CP_TWOPI*Z2)
              VTx =VTx + (SimBox%CM(k)*RVPx(I))/WT
            end do
          end if
      end do

      do K=1, SimBox%NGROUP
         if(IK(K)) then
           do I=SimBox%IPA(K), SimBox%IPA(K+1)-1
                Z1 = RANF()
                Z2 = RANF()
                RVPy(I)=V0(k)*SQRT(-LOG(Z1))*COS(CP_TWOPI*Z2)
                VTy =VTy + (SimBox%CM(k)*RVPy(I))/WT
            end do
          end if
      end do

      do K=1, SimBox%NGROUP
         if(IK(K)) then
            do I=SimBox%IPA(K), SimBox%IPA(K+1)-1
               Z1 = RANF()
               Z2 = RANF()
               RVPz(I)=V0(k)*SQRT(-LOG(Z1))*COS(CP_TWOPI*Z2)
               VTz =VTz + (SimBox%CM(k)*RVPz(I))/WT
             end do
          end if
       end do

       SimBox%XP1(1:SimBox%NPRT,1)=(RVPx(1:SimBox%NPRT)-VTx)
       SimBox%XP1(1:SimBox%NPRT,2)=(RVPy(1:SimBox%NPRT)-VTy)
       SimBox%XP1(1:SimBox%NPRT,3)=(RVPz(1:SimBox%NPRT)-VTz)

      deallocate(V0,RVPx,RVPy, RVPz, IK)
      return
  end subroutine Thermalize_MC_SimMDBox
  !****************************************************************************


  !****************************************************************************
  subroutine Thermalize_VSCAL_SimMDBox(SimBox, TL, IK0)
  !***  PURPOSE:   to thermalize a set of clusters or the whole simulation box by
  !                by assign the atoms velocities generated by scaling the velocities
  !                to require temperature
  !
  !     INPUT:     SimBox, the simulation box to be thermalized
  !                TL,     the temperature the box to be thermalized to
  !                IK0,    the logical flags to determine if a group of atoms will be thermalized,
  !                        this is optional, if IK0 is not present, the whole box will be thermalized
  !
  !     OUTPUT     SimBox, with velocities of atoms assigned
  implicit NONE
      !--- DUMMY variables
      type(SimMDBox)                            ::SimBox
      real(KINDDF),         intent(in)          ::TL
      logical, dimension(:),intent(in), optional::IK0

      !--- local variables
      integer::K,I
      real(KINDDF)::SCAL, XP1SQ, KENERGY
      logical, dimension(:), allocatable::IK

      allocate(IK(SimBox%NGROUP))
      IK = .TRUE.
      if(present(IK0)) IK = IK0

         do K=1, SimBox%NGROUP
            KENERGY = 0.D0
            if(IK(K)) then
               do I=SimBox%IPA(K), SimBox%IPA(K+1)-1
                  XP1SQ = SimBox%XP1(I,1)*SimBox%XP1(I,1) + SimBox%XP1(I,2)*SimBox%XP1(I,2) + SimBox%XP1(I,3)*SimBox%XP1(I,3)
                  KENERGY = KENERGY+SimBox%CM(K) * XP1SQ * C_UTH / CP_KB
               end do
               KENERGY = KENERGY/SimBox%NA(K)

               if(KENERGY .gt. 0.D0) then
                 SCAL = DSQRT(TL/KENERGY)
                 SimBox%XP1(SimBox%IPA(K):SimBox%IPA(K+1)-1,:) = SimBox%XP1(SimBox%IPA(K):SimBox%IPA(K+1)-1,:)*SCAL
               else
               !$$--- the the velocities of the atoms are zero
               !$$    we thermalize them by MC method
                 call Thermalize_Cluster_SimMDBox(SimBox, K, TL)
               end if
            end if
         end do
       deallocate(IK)

       return
  end subroutine Thermalize_VSCAL_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Thermalize_PSCAL_SimMDBox(SimBox, TL, IK0)
  !***  PURPOSE:   to thermalize a set of clusters or the whole simulation box
  !                by displacing the atoms from  their equilibrium positions
  !
  !     INPUT:     SimBox, the simulation box to be thermalized
  !                TL,     the temperature the box to be thermalized to
  !                RANF,   a dumy function to generate uniform distribed random number
  !                IK0,    the logical flags to determine if a group of atoms will be thermalized,
  !                        this is optional, if IK0 is not present, the whole box will be thermalized
  !
  !     OUTPUT     SimBox, with velocities of atoms assigned
  !
  !     REMARK:    This thermalization method can avoid the angular moment induce by other thermalization method
  use RAND32_MODULE, only:RANF=>DRAND32
  IMPLICIT NONE
      !--- DUMMY variables
      type(SimMDBox)                            ::SimBox
      real(KINDDF),         intent(in)          ::TL
      logical, dimension(:),intent(in), optional::IK0

      !--- local variables
      integer::K,I,IC
      real(KINDDF)::SCAL, XP1SQ, KENERGY
      logical, dimension(:), allocatable::IK

      allocate(IK(SimBox%NGROUP))
      IK = .TRUE.
      if(present(IK0)) IK = IK0

         do K=1, SimBox%NGROUP
            KENERGY = 0.D0
            if(IK(K)) then
               do I=SimBox%IPA(K), SimBox%IPA(K+1)-1
                  do IC = 1, 3
                     SCAL = (ranf() - 0.5) * 0.001
                     SCAL = 1.D0 - SCAL
                     SimBox%XP(I,IC) = SimBox%XP(I,IC) * SCAL
                  end do
               end do
            end if
          end do

        deallocate(IK)
        return
  end subroutine Thermalize_PSCAL_SimMDBox
  !****************************************************************************

  !****************************************************************************
  !**** to get the current thermal quantities
  subroutine Cal_thermal_quantities_SimMDBox(SimBox)
  !***  PORPOSE: to get the thermal quantities
  !     INPUT:   SimBox
  !     OUTPUT:  SimBOX, with thermal quantities updated
  IMPLICIT NONE
      !--- DUMMY VARIABLES
      type(SimMDBox)::SimBox

      !--- Local variables
      integer::K,I,J,I1, I2, K1, K2, aNPRT
      real(KINDDF)::VV, VVx0, VVy0, VVz0, TCM, KE, KET(3,3), VOL, VSX, VSY, VSZ
      real(KINDDF), dimension(:,:), allocatable::CXP1   !$$the velocity in Cartesian coordinate system


       !$$--- To get the velocity of mass center of ACTIVE ATOMS
       VV  = 0.D0
       VVx0 = 0.D0
       VVy0 = 0.D0
       VVz0 = 0.D0
       TCM  = 0.D0
       aNPRT= 0
       do k = 1, SimBox%NGROUP
          I1 = SimBox%IPA(k)
          I2 = SimBox%IPA(k+1)-1
          VSX = C_ZERO
          VSY = C_ZERO
          VSZ = C_ZERO
          if(iand(SimBox%PROP(K), CP_STATU_FIXPOSX) .eq. CP_STATU_FIXPOSX .or. &
             iand(SimBox%PROP(K), CP_STATU_FIXPOSY) .eq. CP_STATU_FIXPOSY .or. &
             iand(SimBox%PROP(K), CP_STATU_FIXPOSZ) .eq. CP_STATU_FIXPOSZ ) cycle

          do J=I1, I2
             if(IAND(SimBox%STATU(J),CP_STATU_ACTIVE) .eq. CP_STATU_ACTIVE) then
                VSx = VSx + SimBox%XP1(J,1)
                VSy = VSy + SimBox%XP1(J,2)
                VSz = VSz + SimBox%XP1(J,3)
                TCM = TCM+SimBox%CM(K)
                aNPRT = aNPRT + 1
             end if
          end do
          VVx0 = VVx0 + VSx*SimBox%CM(k)
          VVy0 = VVy0 + VSy*SimBox%CM(k)
          VVz0 = VVz0 + VSz*SimBox%CM(k)
       end do
       VVx0 = VVx0/TCM
       VVy0 = VVy0/TCM
       VVz0 = VVz0/TCM
       !$$--- TO keep the velocity of center mass as zero
       !$$    It is better to keep the XP1 as it is, espacially
       !$$    in simulation for deposition
       !$$SimBox%XP1(1:SimBox%NPRT,1) = SimBox%XP1(1:SimBox%NPRT,1) - VVx0
       !$$SimBox%XP1(1:SimBox%NPRT,2) = SimBox%XP1(1:SimBox%NPRT,2) - VVy0
       !$$SimBox%XP1(1:SimBox%NPRT,3) = SimBox%XP1(1:SimBox%NPRT,3) - VVz0

       !$$--- to get the velovit in Cartesian coordinate system
       allocate(CXP1(SimBox%NPRT,3))
       do I=1, SimBox%NPRT
          if(IAND(SimBox%STATU(I),CP_STATU_ACTIVE) .EQ. CP_STATU_ACTIVE) then
             if(IAND(SimBox%STATU(I),CP_STATU_FIXPOSX) .EQ. C_IZERO)&
                CXP1(I,1) = sum(SimBox%BOXSHAPE(1,1:3)*(SimBox%XP1(I,1:3)-VVx0))
             if(IAND(SimBox%STATU(I),CP_STATU_FIXPOSY) .EQ. C_IZERO)&
                CXP1(I,2) = sum(SimBox%BOXSHAPE(2,1:3)*(SimBox%XP1(I,1:3)-VVy0))
             if(IAND(SimBox%STATU(I),CP_STATU_FIXPOSZ) .EQ. C_IZERO)&
                CXP1(I,3) = sum(SimBox%BOXSHAPE(3,1:3)*(SimBox%XP1(I,1:3)-VVz0))
          end if
       end do

       !$$--- to calculate the kinetic energy and total kinetic energy tensor
       KET = C_ZERO
       do K = 1, SimBox%NGROUP
          I1 = SimBox%IPA(k)
          I2 = SimBox%IPA(k+1)-1
          if(iand(SimBox%PROP(K), CP_STATU_FIXPOSX) .eq. CP_STATU_FIXPOSX .or. &
             iand(SimBox%PROP(K), CP_STATU_FIXPOSY) .eq. CP_STATU_FIXPOSY .or. &
             iand(SimBox%PROP(K), CP_STATU_FIXPOSZ) .eq. CP_STATU_FIXPOSZ ) cycle

          do J=I1, I2
             if(IAND(SimBox%STATU(J),CP_STATU_ACTIVE) .EQ. CP_STATU_ACTIVE) then
                do K1=1, 3
                do K2=1, 3
                   KET(K1,K2) = KET(K1,K2) + CXP1(J, K1)*CXP1(J, K2)*SimBox%CM(K)
                end do
                end do
             endif
          end do
       end do
       SimBox%KTENSOR = KET

       !$$--- to get the current volume
       VOL   =  SimBox%BOXSHAPE(1,1)*(SimBox%BOXSHAPE(2,2)*SimBox%BOXSHAPE(3,3) - SimBox%BOXSHAPE(2,3)*SimBox%BOXSHAPE(3,2)) &
               -SimBox%BOXSHAPE(2,1)*(SimBox%BOXSHAPE(1,2)*SimBox%BOXSHAPE(3,3) - SimBox%BOXSHAPE(3,2)*SimBox%BOXSHAPE(1,3)) &
               +SimBox%BOXSHAPE(3,1)*(SimBox%BOXSHAPE(1,2)*SimBox%BOXSHAPE(2,3) - SimBox%BOXSHAPE(2,2)*SimBox%BOXSHAPE(1,3))

       SimBox%VOLUME  = VOL*SimBox%ZL(1)*SimBox%ZL(2)*SimBox%ZL(3)

       !$$--- to get the cuurent pressure tensor
       SimBox%PTENSOR =  (SimBox%KTENSOR + SimBox%VTENSOR)/SimBox%VOLUME

       !$$--- to get the current temperature
       SimBox%TEMPERATURE = (SimBox%KTENSOR(1,1) + SimBox%KTENSOR(2,2) + SimBox%KTENSOR(3,3))/(C_THR*dble(aNPRT)*CP_KB)

       !$$--- to get scalar pressures
       SimBox%SPRESS0 =(dble(SimBox%NPRT)*CP_KB*SimBox%TEMPERATURE/SimBox%VOLUME)*CP_CGS2KBAR
       SimBox%SPRESS1 =((SimBox%VTENSOR(1,1)+SimBox%VTENSOR(2,2)+SimBox%VTENSOR(3,3))*C_UTH/SimBox%VOLUME)*CP_CGS2KBAR
       SimBox%SPRESS  = SimBox%SPRESS0 + SimBox%SPRESS1

       !$$--- the cohesive energy
       !SimBox%AVEPOT = sum(SimBox%EPOT)/dble(SimBox%NPRT)*CP_ERGEV
       SimBox%AVEPOT = CP_ERGEV*sum(SimBox%EPOT, mask=(IAND(SimBox%STATU,CP_STATU_ACTIVE) .EQ. CP_STATU_ACTIVE))/ &
                       dble(count(IAND(SimBox%STATU,CP_STATU_ACTIVE) .EQ. CP_STATU_ACTIVE))

       !$$--- the Harmiltonian
       SimBox%HARMIL= SimBox%AVEPOT*CP_EVERG +                                                                &
                      sum(SimBox%EKIN, mask=( (IAND(SimBox%STATU,CP_STATU_ACTIVE) .EQ. CP_STATU_ACTIVE) .and. &
                                              (IAND(SimBox%STATU,CP_STATU_FIXPOSX) .EQ. C_IZERO)        .and. &
                                              (IAND(SimBox%STATU,CP_STATU_FIXPOSY) .EQ. C_IZERO)        .and. &
                                              (IAND(SimBox%STATU,CP_STATU_FIXPOSZ) .EQ. C_IZERO)    ) )/dble(aNPRT)


       !$$--- release allocated memory
       deallocate(CXP1)
       return
  end subroutine Cal_thermal_quantities_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Putout_Instance_Thermal_Quantities_SimMDBox(ITIME, TIME, ISECT, FNAME, SimBox,con)
  !***  PORPOSE: to putout the instant thermal quantities of a simulation box
  !     INPUT:   ITIME, the ith time step
  !              TIME,  the time
  !              FNAME, the file name storing the configuration
  !              SimBox, the simulation box
  !
  implicit none
      !--- DUMMY variables
      integer,        intent(in)::ITIME, ISECT
      real(KINDDF),   intent(in)::TIME
      character*(*)             ::FNAME
      type(SimMDBox), intent(in)::SimBox
      integer,        optional  ::con
      !--- local variables
      integer, save::hFile =0
      logical::opened = .false.
      character*16::str(10)=""
      real(KINDDF)::values(10)

       !$$--- at the first time the routine is called
       !$$    we should open the output file
       if(ITIME .eq. 0) then
          if(hFile .gt. 0) close(hFile)
           !$$--- to open the file
           call AvailableIOUnit(hFile)
           !do hFile = 10, 99
           !  INQUIRE(UNIT=hFile, OPENED=opened)
           !  if(.not.opened) exit
           !end do
          open(hFile, file = fname, status='unknown')
          str(1) = "  TIMESECTION   "
          str(2) = "    TIME(PS)    "
          str(3) = "    TEMP.(K)    "
          str(4) = "  VOULUME(LU)   "
          str(5) = "   PRESS0(kb)   "
          str(6) = "   PRESS1(kb)   "
          str(7) = "   PRESST(kb)   "
          str(8) = "    C.E.(ev)    "
          str(9) = "  HARMILT.(cgs) "
          write(hFile, "(20x,10(A16))") str
        else if(ITIME .lt. 0) then
             if(hFile .gt. 0) close(hFile)
             hFile = 0
        else
          !$$ for cases restart the simulation
          if(hFile .le. 0) then
             do hFile = 10, 99
              INQUIRE(UNIT=hFile, OPENED=opened)
              if(.not.opened) exit
           end do
          open(hFile, file = fname, status='unknown')
          !$$--- read the filrst line
           read(hFile, *, END=100) str(1)
           goto 200

          !$$--- the file is empty
  100     str(1) = "  TIMESECTION   "
          str(2) = "    TIME(PS)    "
          str(3) = "    TEMP.(K)    "
          str(4) = "  VOULUME(LU)   "
          str(5) = "   PRESS0(kb)   "
          str(6) = "   PRESS1(kb)   "
          str(7) = "   PRESST(kb)   "
          str(8) = "    C.E.(ev)    "
          str(9) = "  HARMILT.(cgs) "
          write(hFile, "(20x,10(A16))") str
          goto 300

        !$$--- goto the end of the file
  200     continue
          do while(.true.)
            read(hFile, *, END=300) str(1)
          end do
  300     write(hFile,*)
          end if
     end if

      if(hFile .le. 0) return;
        write(hFile, "(1x,I8, 4x, I4, 8x, 11(1pE14.5,2x))") ITIME,ISECT,TIME,    &
                                                     SimBox%TEMPERATURE,         &
                                                     SimBox%VOLUME/SimBox%RR**3, &
                                                     SimBox%SPRESS0, SimBox%SPRESS1, SimBox%SPRESS, &
                                                     SimBox%AVEPOT, SimBox%HARMIL

         if(present(con)) then
          write(*, "(1x,I8, 4x, I4, 8x, 11(1pE14.5,2x))") ITIME,ISECT,TIME, &
                                                      SimBox%TEMPERATURE,   &
                                                      SimBox%VOLUME/SimBox%RR**3, SimBox%SPRESS, &
                                                      SimBox%AVEPOT, SimBox%HARMIL
       end if
      return
  end subroutine Putout_Instance_Thermal_Quantities_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine Get_Displacement_SimMDBox(SimBox, DIS)
  !***  PORPOSE: to get the displacement of the box
  !     INPUT:   SimBox
  !     OUTPUT:  DIS, the displacement of the box
  !
  IMPLICIT NONE
      !$$--- DUMMY VARIABLES
      type(SimMDBox)::SimBox
      real(KINDDF)  ::DIS(3)

      !$$--- Local variables
      integer::I, NP


       DIS  = C_ZERO
       NP = 0
       do I = 1, SimBox%NPRT
          if(IAND(SimBox%STATU(I),CP_STATU_ACTIVE) .EQ. CP_STATU_ACTIVE) then
             DIS(1:3) = DIS(1:3)+SimBox%DIS(I,1:3)
             NP = NP+1
          end if
       end do
       DIS(1:3)  = DIS(1:3)/NP

       return
  end subroutine Get_Displacement_SimMDBox
  !****************************************************************************
  !****************************************************************************
  !****************************************************************************
  !****************************************************************************
  subroutine NewDatPadType_SimMDBox(Simbox, Tag, Ch)
  !***  PORPOSE: to create a new atomic quantitites
  !     INPUT:   SimBox
  !              Tag,      Tag for the new data
  !     OUTPUT:  Pad,      the allocated memory
  !
  implicit none
      !$$--- DUMMY VARIABLES
      type(SimMDBox)  ::SimBox
      character*(*)   ::Tag
      character*(1)   ::Ch
      !---- local
      integer::NPRT

            NPRT = 0
            if(allocated(SimBox%ITYP)) NPRT = size(SimBox%ITYP)
            NPRT = max(NPRT, SimBox%NPRT)
            call New_DataPad(Tag, Ch, NPRT, SimBox%ptrDatPad)

            return
  end  subroutine NewDatPadType_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine NewDatPadType2_SimMDBox(Simbox, Tag, Ch, Ext)
  !***  PORPOSE: to create a new atomic quantitites
  !     INPUT:   SimBox
  !              Tag,      Tag for the new data
  !     OUTPUT:  Pad,      the allocated memory
  !
  implicit none
      !$$--- DUMMY VARIABLES
      type(SimMDBox) ::SimBox
      character*(*)  ::Tag
      character*(1)  ::Ch
      integer        ::Ext
      !---- local
      integer::NPRT


            if(Ext .eq. 1) then
               call NewDatPadType_SimMDBox(Simbox, Tag, Ch)
            else
               NPRT = 0
               if(allocated(SimBox%ITYP)) NPRT = size(SimBox%ITYP)
               NPRT = max(NPRT, SimBox%NPRT)
               call New_DataPad(Tag, Ch, (/NPRT, Ext/), SimBox%ptrDatPad)
            end if
            return
  end  subroutine NewDatPadType2_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine NewDatPadI_SimMDBox(Simbox, Tag, Pad)
  !***  PORPOSE: to create a new atomic quantitites
  !     INPUT:   SimBox
  !              Tag,      Tag for the new data
  !     OUTPUT:  Pad,      the allocated memory
  !
  implicit none
      !$$--- DUMMY VARIABLES
      type(SimMDBox)                    ::SimBox
      character*(*)                     ::Tag
      integer,     dimension(:), pointer::Pad

            call New_DataPad(Tag, SimBox%NPRT, Pad, SimBox%ptrDatPad)
            return
  end  subroutine NewDatPadI_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine NewDatPadI2_SimMDBox(Simbox, Tag, Pad, Ext)
  !***  PORPOSE: to get the displacement of the box
  !     INPUT:   SimBox
  !              Tag,      Tag for the new data
  !     OUTPUT:  Pad,      the allocated memory
  !
  implicit none
      !$$--- DUMMY VARIABLES
      type(SimMDBox)                  ::SimBox
      character*(*)                   ::Tag
      integer                         ::Ext
      integer, dimension(:,:), pointer::Pad
      !--- local

            if(Ext .eq. 1) then
               call NewDatPadI_SimMDBox(Simbox, Tag, Pad)
            else
               call New_DataPad(Tag, (/SimBox%NPRT,Ext/), Pad, SimBox%ptrDatPad)
            end if
            return
  end  subroutine NewDatPadI2_SimMDBox
 !****************************************************************************

 !****************************************************************************
  subroutine NewDatPadD_SimMDBox(Simbox, Tag, Pad)
  !***  PORPOSE: to get the displacement of the box
  !     INPUT:   SimBox
  !              Tag,      Tag for the new data
      !$$--- DUMMY VARIABLES
  !     OUTPUT:  Pad,      the allocated memory
  !
  implicit none
      type(SimMDBox)                     ::SimBox
      character*(*)                      ::Tag
      real(KINDDF), dimension(:), pointer::Pad
      !--- local

            call New_DataPad(Tag, SimBox%NPRT, Pad, SimBox%ptrDatPad)
            return
  end  subroutine NewDatPadD_SimMDBox
!****************************************************************************

!****************************************************************************
  subroutine NewDatPadD2_SimMDBox(Simbox, Tag, Pad, Ext)
  !***  PORPOSE: to get the displacement of the box
  !     INPUT:   SimBox
  !              Tag,      Tag for the new data
  !     OUTPUT:  Pad,      the allocated memory
  !
  implicit none
      type(SimMDBox)                       ::SimBox
      character*(*)                        ::Tag
      real(KINDDF), dimension(:,:), pointer::Pad
      integer                              ::Ext
      !--- local
            if(Ext .eq. 1) then
               call NewDatPadD_SimMDBox(Simbox, Tag, Pad)
            else
               call New_DataPad(Tag, (/SimBox%NPRT,Ext/), Pad, SimBox%ptrDatPad)
            end if
            return
  end  subroutine NewDatPadD2_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine AccumDatPadD_SimMDBox(Simbox, Tag, Val, Order)
  !***  PORPOSE: to accumulate the data of Tag
  !     INPUT:   SimBox
  !              Tag,      Tag for the new data
  !              Val,      the increments of Tag data
  !              Order,    optional, the index order of array
  !     OUTPUT:  Simbox,   the box with its data of Tag updated
  !
  implicit none
      type(SimMDBox)                       ::SimBox
      character*(*)                        ::Tag
      real(KINDDF), dimension(:)           ::Val
      integer,      dimension(:), optional ::Order
      !--- local
            if(present(Order)) then
               call Accumulate_DataPad(Tag, SimBox%ptrDatPad, Val, Order)
            else
               call Accumulate_DataPad(Tag, SimBox%ptrDatPad, Val)
            end if
            return
  end  subroutine AccumDatPadD_SimMDBox
  !****************************************************************************

  !****************************************************************************
  subroutine CheckForceTableAssigned_SimMDBox0(SimBox)
  !***  PORPOSE: to check if the force table has been assigned for all atom groups
  !     INPUT:   Keyword

        implicit none
        type(SimMDBox) ::SimBox
        !---
        integer::I, J
           
           
           do I=1, SimBox%NGROUP
              do J=1, SimBox%NGROUP
                 if(SimBox%PTYPE(I,J) .le. 0)  then
                    write(*,fmt="(A,I4,A,I4,A)") "MDPSCU error: the force table between atom type ",I," and ", J, " unavaiable"
                    write(*,fmt="('               check box file ', BZI6)") 
                    write(*,*)"Process to be stopped"
                   stop
                 end if
              end do
           end do
           return
  end subroutine CheckForceTableAssigned_SimMDBox0
  !****************************************************************************

  !****************************************************************************
  subroutine CheckForceTableAssigned_SimMDBox1(SimBox)
   !***  PORPOSE: to check if the force table has been assigned for all atom groups
   !     INPUT:   Keyword
 
         implicit none
         type(SimMDBox), dimension(:)::SimBox
         !---
         integer::IB, I
            
            do IB=1, size(SimBox)   
               call CheckForceTableAssigned_SimMDBox0(SimBox(IB))    
            end do
            return
   end subroutine CheckForceTableAssigned_SimMDBox1
   !****************************************************************************  

  !****************************************************************************
  logical function IsBasicKWD(Keyword) result(yes)
  !***  PORPOSE: to check if the Keyword is basic keyword
  !     INPUT:   Keyword

        implicit none
        character*(*), intent(in)::Keyword
        !---
        integer::I

           yes = .false.
           do I=1, size(CP_BASICKWD)
              if(SameFirstWord(Keyword, CP_BASICKWD(I))) then
                 yes = .true.
                 return
              end if
           end do
   end function IsBasicKWD
  !****************************************************************************
  end module MD_TYPEDEF_SimMDBox
