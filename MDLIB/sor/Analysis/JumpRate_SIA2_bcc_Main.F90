 !**** DESCRIPTION: _______________________________________________________________________________________
 !                  The program is used to analyze the change and movement of SIA-cluster in BCC.
 !                  The clutering results generated by Cfg_Track_SIA_GPU will be loaded for the
 !                  configurations of the clusters at difference time.
 !
 !                  SEE ALSO ____________________________________________________________________________
 !                       Cfg_Track_SIA_GPU_Main.F90
 !
 !
 !**** USAGE:       _______________________________________________________________________________________
 !
 !                  DefectCluster_Track.exe -s "filename" -T(est) t1, t2, ts
 !                  where:
 !                        -s filename:          - the pathname of files storing the clustering configurations generated by
 !                                                 Cfg_Track_SIA_GPU.exe
 !                  OPTIONS
 !                        -T(est) t1, t2, ts:   - the range for the tests to be involved in analysis
 !
 !                  ______________________________________________________________________________________
 !**** HISTORY:
 !                  version 1st 2015-11 (Hou Qing, Sichuan university)
 !
 !

 module JumpRate_SIA2_bcc
 use DefectCluster_Analysis_bcc

 implicit none

 contains
  !**********************************************************************************
   subroutine RecordDefectJumpAnalysis()
  !***  DESCRIPTION: to analysis the bond information of clusters. The bond information
  !                  is descirbed in DefectBondInfo_BCC
  !
  !    INPUT:  IB,   the box IDclusters
  !
  !    OUTPUT: BONDS,    the array describing the bonds of the clusters
  !
   implicit none
       !--- dummy variables
       !--- local variables
        integer::IB, J, ICFG1, ICFG2, ITIME,  CNUM, ENDFLAG, NBOX, NCFG
        real(KINDDF)::TIME
        type(PartcleClusterList), dimension(:), allocatable::Clusters1, Clusters2

       !--- the variable for bond analysis
        integer::mxCSIZ      = 0 !--- the max cluster size
        integer::NE, ICHANGE, STAT, IDIR, IBOND1, IBOND2, IBOND1P, IBOND2P, FLAG1, FLAG2, FLAG1P, FLAG2P, NC, ND
        integer, dimension(:), allocatable::EVENT, DEFTYP, DIR, NNS, NNV, LINKS
        integer, dimension(:), allocatable::BondInfo1, BondInfo2, BondInfo1P, BondInfo2P


        !--- local variables for IO
         integer::hFile1, hFile2
         character*256::GFILE
         integer,dimension(:), allocatable::LINE, SEPFLAG

  !-------------
        !--- start analysis
             allocate(LINE(lbound(m_hFILE,dim=1):ubound(m_hFILE,dim=1)),   &
                      SEPFLAG(lbound(m_hFILE,dim=1):ubound(m_hFILE,dim=1))  )
             LINE = 0
             SEPFLAG = 0
             do IB = m_CtrlParam%JOBID0, m_CtrlParam%JOBID1, m_CtrlParam%JOBIDSTEP
                call Start_Load_ClusterCfg(IB, LINE(IB))
             end do

        !--- prepair for output
            call GetParentPath(m_CfgPath, GFILE)
            GFILE = GFILE(1:len_trim(GFILE))//"BondAnaly/"
            call CreateDataFolder_Globle_Variables(GFILE)
            GFILE = GFILE(1:len_trim(GFILE))//"Jumps"
            call AvailableIOUnit(hFile1)
            open(UNIT=hFile1, file = GFILE)
            write(hFile1, fmt="(A, I8)")    '!--- THE CLUSTER JUMPING FREQENCE VS TIME CREATED BY '//gm_ExeName(1:len_trim(gm_ExeName))
            write(hFile1, fmt="(A)")        '!    A PROGRAM GENERATED BY THE MD PACKAGE AT SICHUAN UNIVERSITY'
            write(hFile1, fmt="(A)")        '!    AUTHOR: HOU Qing'
            write(hFile1, fmt="(A)")        '!    '
            write(hFile1, fmt="(A, I8)")    '&JUMP_STAT'
            write(hFile1,fmt="(A)")          "!---  SYMBOL EXPLAINATION:"
            write(hFile1,fmt="(A)")          "!     ITIME:        time steps for jumping event occur"
            write(hFile1,fmt="(A)")          "!     TIME:         time (ps) at the time step"
            write(hFile1,fmt="(A)")          "!     CFG#:         corresponding configure ID of the previous reocding"
            write(hFile1,fmt="(A)")          "!     BOX#:         box ID"
            write(hFile1,fmt="(A)")          "!     S-CHANGE:     flag indicating if shape, which is define by bond distribution has been changed"
            write(hFile1,fmt="(A)")          "!                   = 1, for shape changed; =0, for unchanged shape"
            write(hFile1,fmt="(A)")          "!     B-DIS1:       bond distribution, defining the shape before jump"
            write(hFile1,fmt="(A)")          "!     B-DIS2:       bond distribution, defining the shape after jump"
            write(hFile1,fmt="(A)")          "!     NB-DIS1:      normalized bond distribution, defining the shape before jump"
            write(hFile1,fmt="(A)")          "!     NB-DIS2:      normalized bond distribution, defining the shape after jump"
            write(hFile1,fmt="(A)")          "!     NUM_EVENT:    number of jumping events involved in the movement of the cluster"
            write(hFile1,fmt="(A)")          "!     EVENT#:       # of the event"
            write(hFile1,fmt="(A)")          "!     EVENT_TYPE:   event type for this jumping event"
            write(hFile1,fmt="(A)")          "!                   = 1, for an exhcnage jump;  "
            write(hFile1,fmt="(A)")          "!                   = 2, for a combination jump; "
            write(hFile1,fmt="(A)")          "!                   = 3, for a long distance jump; "
            write(hFile1,fmt="(A)")          "!                   = 4, for a unpaired jump; "
            write(hFile1,fmt="(A)")          "!     DEF_TYPE:     type of the jumping point defect"
            write(hFile1,fmt="(A)")          "!                   =1, for SIA; =6 for VACANCY"
            write(hFile1,fmt="(A)")          "!     JUMP_DIR:     jumping direction defined by index, but:"
            write(hFile1,fmt="(A)")          "!                   [1000], [0100], [0010] are three [100], [010], [001] direction"
            write(hFile1,fmt="(A)")          "!                   [0001] is the direction in [111]"
            write(hFile1,fmt="(A)")          "!     NEIGHB_S:     number of LSIAs near the non-defect site that the defect jumps to"
            write(hFile1,fmt="(A)")          "!     NEIGHB_V:     number of LVACs near the non-defect site that the defect jumps to"
            write(hFile1,fmt="(A)")          "!     CANDID_S:     number of candaidate normal sites that the defect may jump to "
            write(hFile1,fmt="(A)")          "!     DEFECT_S:     number of defect sites"
            write(hFile1,fmt="(A)")          "!     C-D LINKS:    histogram of the number of links between candidate-defect"
            write(hFile1,fmt="(A)")          "!"


            call GetParentPath(m_CfgPath, GFILE)
            GFILE = GFILE(1:len_trim(GFILE))//"BondAnaly/"
            call CreateDataFolder_Globle_Variables(GFILE)
            GFILE = GFILE(1:len_trim(GFILE))//"BondDis"
            call AvailableIOUnit(hFile2)
            open(UNIT=hFile2, file = GFILE)
            write(hFile2, fmt="(A, I8)")    '!--- THE CLUSTER BOND ANAGLYSIS VS TIME CREATED BY '//gm_ExeName(1:len_trim(gm_ExeName))
            write(hFile2, fmt="(A)")        '!    A PROGRAM GENERATED BY THE MD PACKAGE AT SICHUAN UNIVERSITY'
            write(hFile2, fmt="(A)")        '!    AUTHOR: HOU Qing'
            write(hFile2, fmt="(A)")        '!    '
            write(hFile2, fmt="(A, I8)")    '&BOND_STAT'


         !--- do bond analysis
             NCFG = 0
             allocate(Clusters1(m_CtrlParam%JOBID0:m_CtrlParam%JOBID1))
             allocate(Clusters2(m_CtrlParam%JOBID0:m_CtrlParam%JOBID1))

             !--- to load the initial clusters
             mxCSIZ = 0
             do IB = m_CtrlParam%JOBID0, m_CtrlParam%JOBID1, m_CtrlParam%JOBIDSTEP
                call Load_ClusterCfg(IB, ICFG1, ITIME, TIME, LINE(IB), Clusters1(IB))
                call NumberCluster_PartcleClusters(Clusters1(IB), CNUM)
                if(CNUM .gt. 1) SEPFLAG(IB) = 1
                call MergeClusterList_PartcleClusters(Clusters1(IB), m_SiteNeighbor%KVOIS,m_SiteNeighbor%INDI)
                if(mxCSIZ .lt. Clusters1(IB)%NPRT) mxCSIZ = Clusters1(IB)%NPRT
             end do
             !--- allocate working space
             allocate( EVENT(mxCSIZ*4), DEFTYP(mxCSIZ*4), DIR(mxCSIZ*4*4), NNS(mxCSIZ*4), NNV(mxCSIZ*4), LINKS(mxCSIZ*4) )
             allocate(BondInfo1(mp_VSIZ), BondInfo2(mp_VSIZ), BondInfo1P(mp_VSIZ), BondInfo2P(mp_VSIZ))

             !--- write out the number of non-seperated cluster
             write(hFile1,fmt="(A, I)")          "!    NUMBER OF CLUSTER IN ANALYSIS ", count(SEPFLAG .eq. 0)
             write(hFile1, fmt="(A6,1x, A10, 2x, A12, 2x, 30(1x, A9, 1x))") "&TITLE", "ITIME", "TIME", "CFG#", &
                                 "BOX#", "S-CHANGE", "B-DIS1", "B-DIS2", "NB-DIS1", "NB-DIS2", "NUM_EVENT", "EVENT#", "EVENT_TYPE", &
                                 "DEF_TYPE", "JUMP_DIR", "NEIGHB_S", "NEIGHB_V", "CANDID_S", "DEFECT_S", "C-D LINKS"

             do while(.true.)  !--- loop for time steps
                ENDFLAG = 0
                NBOX    = 0
                do IB = m_CtrlParam%JOBID0, m_CtrlParam%JOBID1, m_CtrlParam%JOBIDSTEP
                   NBOX = NBOX + 1
                   call Load_ClusterCfg(IB, ICFG2, ITIME, TIME, LINE(IB), Clusters2(IB))
                   !--- determine if have reach the end of cluster sequence
                   if(Clusters2(IB)%NPRT .eq. 0) then
                       ENDFLAG = ENDFLAG + 1
                       cycle
                   end if
                   call MergeClusterList_PartcleClusters(Clusters2(IB), m_SiteNeighbor%KVOIS,m_SiteNeighbor%INDI)
                end do
                if(ENDFLAG .ge. NBOX) exit

                write(*,fmt="(A, I, A, I)") "MDPSCU Message: Jumping from cfg # ", ICFG1, " to ", ICFG2
                do IB = m_CtrlParam%JOBID0, m_CtrlParam%JOBID1, m_CtrlParam%JOBIDSTEP
                   !--- NOTE: we have filter out the initially seperated cluster
                   !if(SEPFLAG(IB) .gt. 0) cycle

                   call DefectBondInfo0_BCC(Clusters1(IB), BondInfo1, FLAG1)
                   call DefectBondInfo0_BCC(Clusters2(IB), BondInfo2, FLAG2)
                   call DefectBondInfo1_BCC(Clusters1(IB), BondInfo1P, FLAG1P)
                   call DefectBondInfo1_BCC(Clusters2(IB), BondInfo2P, FLAG2P)

                   !print *, "IB", IB, ICFG1, ICFG2
                   call DefectJumpAnalysis(Clusters1(IB), Clusters2(IB), NE, EVENT, DEFTYP, DIR, NNS, NNV, STAT)
                   if(STAT .eq. mp_WARNING_UNLINK_SITES) then
                      write(*,fmt="(A,I,A,I,I)")"MDPSCU Warning: Not all changed sites are linked in pair for BOX", IB, "at CFG", ICFG1, ICFG2
                      call ONWARNING(gm_OnWarning)
                   end if
                   if(NE .gt. 0) then
                     !----
                      if(all(BondInfo1P(1:4) .eq. BondInfo2P(1:4))) then
                         ICHANGE = 0
                      else
                         ICHANGE = 1
                      end if
                      IBOND1 = BondInfo1(1)*1000
                      IBOND1 = IBOND1 + BondInfo1(2)*100
                      IBOND1 = IBOND1 + BondInfo1(3)*10
                      IBOND1 = IBOND1 + BondInfo1(4)
                      if(FLAG1 .gt. 0) IBOND1 = - IBOND1
                      IBOND2 = BondInfo2(1)*1000
                      IBOND2 = IBOND2 + BondInfo2(2)*100
                      IBOND2 = IBOND2 + BondInfo2(3)*10
                      IBOND2 = IBOND2 + BondInfo2(4)
                      if(FLAG2 .gt. 0) IBOND2 = - IBOND2

                      IBOND1P = BondInfo1P(1)*1000
                      IBOND1P = IBOND1P + BondInfo1P(2)*100
                      IBOND1P = IBOND1P + BondInfo1P(3)*10
                      IBOND1P = IBOND1P + BondInfo1P(4)
                      if(FLAG1P .gt. 0) IBOND1P = - IBOND1P
                      IBOND2P = BondInfo2P(1)*1000
                      IBOND2P = IBOND2P + BondInfo2P(2)*100
                      IBOND2P = IBOND2P + BondInfo2P(3)*10
                      IBOND2P = IBOND2P + BondInfo2P(4)
                      if(FLAG2P .gt. 0) IBOND2P = - IBOND2P

                      call CandidateJumpLinks(Clusters1(IB), 1, NC, ND, LINKS)

                      do J=1, NE
                         IDIR =  DIR((J-1)*4+1)*1000
                         IDIR =  IDIR + DIR((J-1)*4+2)*100
                         IDIR =  IDIR + DIR((J-1)*4+3)*10
                         IDIR =  IDIR + DIR((J-1)*4+4)

                         write(hFile1, fmt="(7x, I10, 2x, 1PE12.6, 2x, 30(1x, I9,1x))")   &
                              ITIME, TIME, ICFG1, IB, ICHANGE, IBOND1, IBOND2, IBOND1P, IBOND2P, NE, J, EVENT(J), DEFTYP(J), IDIR, NNS(J), NNV(J), &
                              NC, ND, count(LINKS .eq.1), count(LINKS .eq.2), count(LINKS .eq. 3), count(LINKS .eq. 4), count(LINKS .eq. 5)

                      end do
                    end if
                   call CopyClusterList_PartcleClusters(Clusters2(IB), Clusters1(IB))
                end do
                ICFG1 = ICFG2
             end do
             if(hFile1 .gt. 0) close(hFile1)
             if(hFile2 .gt. 0) close(hFile2)

             deallocate( EVENT, DEFTYP, DIR, NNS, NNV, LINKS)
             deallocate(BondInfo1, BondInfo2, BondInfo1P, BondInfo2P)

             do IB = m_CtrlParam%JOBID0, m_CtrlParam%JOBID1, m_CtrlParam%JOBIDSTEP
                call DeleteAll_PartcleClusters(Clusters1(IB))
                call DeleteAll_PartcleClusters(Clusters2(IB))
             end do
             deallocate(Clusters1, Clusters2)


             return
   end subroutine RecordDefectJumpAnalysis
  !**********************************************************************************

  !**********************************************************************************
  subroutine MyCleaner()
  !***  PURPOSE:  to deallocate the memories allocated
  !    INPUT:     SimBox,    the simulation box, useless here
  !               CtrlParam, the control parameter, useless here
  !   OUTPUT:
  !
          call Clear()
          return
  end subroutine MyCleaner
  !**********************************************************************************

 end module JumpRate_SIA2_bcc


 !**********************************************************************************
 Program JumpRate_SIA2_bcc_Main
 use JumpRate_SIA2_bcc
 implicit none


       call Initialize()
       call RecordDefectJumpAnalysis()

       stop
 End program JumpRate_SIA2_bcc_Main
