 !**** DESCRIPTION: _______________________________________________________________________________________
 !                  The program provides a number of routines to analysis the movemnet of defect clusters.
 !                  The clusters are assummed to be constructed by point defects. The locations of the
 !                  point defects are the lattice sites of a reference crystal lattice. The movements of
 !                  the clusters are thus the result of jumping of the point defects
 !
 !                  The clutering results generated by Cfg_Track_SIA_GPU will be loaded for the
 !                  configurations of the clusters at difference time.
 !
 !                  SEE ALSO ____________________________________________________________________________
 !                       Cfg_Track_SIA_GPU_Main.F90
 !
 !
 !                  ______________________________________________________________________________________
 !**** HISTORY:
 !                  version 1st 2015-11 (Hou Qing, Sichuan university)
 !
 !

 module LatticeClusterTrackCommon
 use MD_TYPEDEF_SimMDBox
 use MD_TYPEDEF_SimMDCtrl
 use MD_Globle_Variables
 use MD_NeighborsList
 use MD_TYPEDEF_ClusterList

 implicit none

       integer, dimension(:), allocatable::m_hFile
       character*256::m_CfgPath = ""
       type(SimMDBox)::m_RefSimBox
       type(NEIGHBOR_LIST)::m_SiteNeighbor
       type(SimMDCtrl)::m_CtrlParam

       integer, parameter::mp_SITE_SIA = 1
       integer, parameter::mp_SITE_NEIB_SIA = 2
       integer, parameter::mp_SITE_NEIB_NORMAL = 3
       integer, parameter::mp_SITE_SIA_ATOM = 4
       integer, parameter::mp_SITE_NEIHB_SITEATOM = 5
       integer, parameter::mp_SITE_VAC = 6
       integer, parameter::mp_SITE_NEIB_VAC = 7

       integer, parameter::mp_EVENT_EXCH   = 1        !--- event id for jump    or exchange
       integer, parameter::mp_EVENT_COMB   = 2        !--- event id for combination
       integer, parameter::mp_EVENT_LJUMP  = 3        !--- event id for long distance jump
       integer, parameter::mp_EVENT_UNPAIR = 4        !--- event id for unpaired distance jump

       integer, parameter::mp_WARNING_UNLINK_SITES = mp_EVENT_UNPAIR !--- there are sites taht are not liked by event

       !----------------
 contains

  !**********************************************************************************
   subroutine Initialize()
   !***  PURPOSE:  to load control parameters and allocate memories needed
   !
   implicit none
  !----   DUMMY Variables

  !----   Local variables
         call ExtractCmdlineFileNames_Globle_Variables()
         call CommandlineBoxsel(m_CtrlParam)

         call GetPath(gm_cfgFileName(1), m_CfgPath)
         write(*,fmt="(A)") "MDPSCU Message: Load referece configure from"//m_CfgPath(1:len_trim(m_CfgPath))//"RefCfg.0000"
         call Load_Config_SimMDBox(m_CfgPath(1:len_trim(m_CfgPath))//"RefCfg.0000",m_RefSimBox)

         write(*,fmt="(A)") "MDPSCU Message: Load neighborelist from "//m_CfgPath(1:len_trim(m_CfgPath))//"RefNNList"
         call Load_NeighboreList(m_CfgPath(1:len_trim(m_CfgPath))//"RefNNList", m_SiteNeighbor)

         allocate(m_hFile(m_CtrlParam%JOBID0:m_CtrlParam%JOBID1) )
         m_hFile = 0
         return
   end subroutine Initialize
  !**********************************************************************************

  !**********************************************************************************
  subroutine Start_Load_ClusterCfg(IBOX, LINE)
  !***  DESCRIPTION: to load the
  !
  !    INPUT:  IBOX,   the id of the box
  !    OUTPUT: SimBox, the simualtion box with box information loaded fron the file
  !            LINE,   the curent line in the configre file
  !
  implicit none
       !--- dummy variables
       integer::IBOX
       integer::LINE
       type(SimMDBox)::SimBox
       !--- local variables
        character*256::GFILE1, STR
        character*64::KEYWORD
        logical::ex

  !-------------
          if(m_hFile(IBOX) .gt. 0) then
             close(m_hFile(IBOX))
          end if

          call STRCATI(GFILE1, m_CfgPath(1:len_trim(m_CfgPath)), "P", 0, 4)
          call STRCATI(GFILE1, GFILE1, "_", IBOX, 4)
          inquire(FILE=GFILE1, exist=EX)
          if(.not. EX) then
              write(*,fmt="(A)") "MDPSCU Error: Fail to open "//GFILE1(1:len_trim(GFILE1))
               write(*,fmt="(A)") "              Process to be stopped"
              stop
          end if

          call AvailableIOUnit(m_hFile(IBOX))
          open(UNIT=m_hFile(IBOX), file = GFILE1, STATUS='old')
          LINE = 0

          call GetInputStrLine(m_hFile(IBOX),STR, LINE, "!", *100)
          STR = adjustl(STR)
          call GetKeyWord("&", STR, KEYWORD)
          call UPCASE(KEYWORD)
          if( KEYWORD(1:LEN_TRIM(KEYWORD)) .ne. '&LATT_CLUST_SEQ') then
              write(*,fmt="(A)")     "MDPSCU Error: Wrong file format for "
              write(*,fmt="(A)")     "              Keyword "//'&LATT_CLUST_SEQ'//"should appear before other keyword"
              write(*,fmt="(A, I7)") "              Check file "//GFILE1(1:len_trim(GFILE1))//"at line", LINE
              write(*,fmt="(A)")     "              Process to be stopped"
              stop
          end if
          return
   100    write(*,fmt="(A)")     "MDPSCU Error: fail to load the configure data from "//GFILE1(1:len_trim(GFILE1))
          write(*,fmt="(A)")     "              Process to be stopped"
          stop

  end subroutine Start_Load_ClusterCfg
  !**********************************************************************************

  !**********************************************************************************
  subroutine Load_ClusterCfg(IBOX, ICFG, ITIME, TIME, LINE, Clusters)
  !***  DESCRIPTION: to load the
  !
  !    INPUT:  IBOX,   the id of the box
  !
  !    OUTPUT: ICFG,   the configuration ID
  !            ITIME,  the time step
  !            TIME,   the simulation time
  !
  !    OUTPUT: Clusters the cluster list of configuration ICFG
  !
  use MiniUtilities
  implicit none
       !--- dummy variables
       integer, intent(in)::IBOX
       integer::ICFG,ITIME, LINE
       real(KINDDF)::TIME
       type(PartcleClusterList)::Clusters
       !--- local variables
        integer::N, SQSIZE
        integer, dimension(:), allocatable::SQTYP, SQNC
        character*256::GFILE1, STR
        character*64::KEYWORD, STRNUMB(6)
        logical::ex

  !-------------
          call DeleteAll_PartcleClusters(Clusters)
          allocate(SQTYP(m_RefSimBox%NPRT), SQNC(m_RefSimBox%NPRT))
          do while(.true.)
             call GetInputStrLine(m_hFile(IBOX),STR, LINE, "!", *200)
             STR = adjustl(STR)
             call GetKeyWord("&", STR, KEYWORD)
             call UPCASE(KEYWORD)
             select case(KEYWORD(1:LEN_TRIM(KEYWORD)))
                    case("&ITIME", "&ITIME:")
                          call EXTRACT_NUMB(STR,1,n,STRNUMB)
                          ITIME = ISTR(STRNUMB(1))
                    case("&TIME", "&TIME:")
                          call EXTRACT_NUMB(STR,1,n,STRNUMB)
                          TIME = DRSTR(STRNUMB(1))
                    case("&ICFG", "&ICFG:")
                          call EXTRACT_NUMB(STR,1,n,STRNUMB)
                          ICFG= ISTR(STRNUMB(1))
                    case("&STARTSQN")
                          exit
             end select
          end do

          SQSIZE = 0
          do while(.true.)
             call GetInputStrLine(m_hFile(IBOX), STR, LINE, "!", *100)
             call EXTRACT_NUMB(STR,6,n,STRNUMB)
             SQSIZE = SQSIZE + 1

             if(N .eq. 6) then
               !--- NOTE: SQTYP is defined by the occupation state of the site
                SQTYP(SQSIZE)  = ISTR(STRNUMB(6))
!                SQXP(SQSIZE,1) = DRSTR(STRNUMB(2))
!                SQXP(SQSIZE,2) = DRSTR(STRNUMB(3))
!                SQXP(SQSIZE,3) = DRSTR(STRNUMB(4))
                SQNC(SQSIZE)   = DRSTR(STRNUMB(5))
             else if(N.eq. 1) then
                call Add_PartcleClusters(Clusters, SQSIZE-1, SQNC, SQTYP)
                SQSIZE = 0
             else
                STR = adjustl(STR)
                call GetKeyWord("&", STR, KEYWORD)
                call UPCASE(KEYWORD)
                if(KEYWORD(1:len_trim(KEYWORD)) .eq. "&ENDSQN") then
                   exit
                else
                  write(*,fmt="(A)")     "MDPSCU Error: No &ENDSQN found "
                  write(*,fmt="(A, I7)") "              Check line at ", LINE
                  write(*,fmt="(A)")     "              Process to be stopped"
                  stop
                end if
             end if

          end do

          if(allocated(SQTYP)) deallocate(SQTYP)
          if(allocated(SQNC))  deallocate(SQNC)
          return

   100    return
          write(*,fmt="(A)")     "MDPSCU Error: fail to load the configure data from "//GFILE1(1:len_trim(GFILE1))
          write(*,fmt="(A)")     "              Process to be stopped"
          stop

   200    continue
          if(allocated(SQTYP)) deallocate(SQTYP)
          if(allocated(SQNC))  deallocate(SQNC)
          return
  end subroutine Load_ClusterCfg
 !**********************************************************************************

 !**********************************************************************************
  subroutine CompareTwoClusters(Cluster1, Cluster2, NCS, IND, NT, TGT, IND2)
  !***  DESCRIPTION: to find out the differenc between two cluster.
  !                  NOTE:   Only the sites containing both clusters are checked.
  !                          If the types of the checked sites is difference, the
  !                          changes are recorded.
  !
  !
  !    INPUT:  Clusters1, Cluster2  the clusters
  !
  !    OUTPUT: NCS,   the number of sites that have been changed
  !            IND,   the # of the changed sites in the first cluster
  !            NT,    the number of sites in cluster1 where the changed sites may jump to
  !            TGT,   the # of the sites in cluster1 that the changed sites may jump to.
  !                   it is possible the there are multiple sites
  !            IND2,  the # of the changed sites in the second cluster
  !

  implicit none
       !--- dummy variables
       type(PartcleClusterList), intent(in)::Cluster1, Cluster2
       integer::NCS
       integer, dimension(:)::IND, NT, IND2
       integer, dimension(:,:)::TGT
       !--- local variables
        integer::I, J, ID1, ITY1, ID2, ITY2, NN, IP

             !$$--- to find out the changed site
             !$$--- find out the sites int cluster1 different from Cluster2
              NCS = 0
              do I=1, Cluster1%NPRT
                 ID1  = Cluster1%IND(I)
                 ITY1 = Cluster1%PTYP(I)
                 do J = 1,  Cluster2%NPRT
                    if(Cluster2%IND(J) .eq. ID1 .and. Cluster2%PTYP(J) .ne. ITY1) then
                       NCS = NCS + 1
                       IND(NCS)  = I
                       IND2(NCS) = J
                       exit
                    end if
                  end do
              end do

             !$$--- find out the neighor sites that a changed site may linked to
             !$$    only the different sites in CLUSTER1 are linked.
             !$$    NOTE: TGT is the index of the changed sites marked above
             !$$          to transfer TGT to the index of  the changed site
             !$$          should be IND(TGT(I,J))
              do I=1, NCS
                 ID1  = Cluster1%IND(IND(I))
                 ITY1 = Cluster1%PTYP(IND(I))
                 NN   = m_SiteNeighbor%KVOIS(ID1)
                 NT(I)= 0
                 IP   = 0
                 do J=1, NCS
                    ID2 = Cluster1%IND(IND(J))
                    ITY2 = Cluster1%PTYP(IND(J))
                    !print *, "I, J, ",ID1, ID2, ITY1, ITY2, any(m_SiteNeighbor%INDI(ID1,1:NN) .eq. ID2)
                    if(any(m_SiteNeighbor%INDI(ID1,1:NN) .eq. ID2) .and. (ITY1.ne.ITY2) )then
                       IP    = IP + 1
                       NT(I) = NT(I) + 1
                       TGT(I, IP) = J !IND(J)
                    end if
                 end do
                 !$$--- we marke the end site as zero
                 IP = IP + 1
                 TGT(I, IP) = 0
              end do

             !print *, "Here NT", NCS, NT

             return
  end subroutine CompareTwoClusters
  !**********************************************************************************

 !**********************************************************************************
  subroutine DefectJumpLink(Cluster1, Cluster2, MXNB, NE, IS1, IS2, EVENT, STAT)
  !***  DESCRIPTION: to find out the jumping link of defect
  !
  !
  !    INPUT:  Clusters1, Cluster2  the clusters
  !            MXNB,  max number of neighbors for a sites, for example
  !                   for HCP, MXNB = 12, for BCC, MXNB = 14
  !
  !
  !    OUTPUT: NE,    the number of events
  !            IS1,   the index of site of the jumping from
  !            IS2,   the index of sites of jumping to
  !            EVENT, the type of events
  !            STAT,  the stat of linking the jumping sites
  !
  !

  implicit none
       !--- dummy variables
       type(PartcleClusterList), intent(in)::Cluster1, Cluster2
       integer::NE, MXNB, STAT
       integer, dimension(:)::IS1, IS2, EVENT
       !--- local variables
       integer::NS, I, J, ID1, ID2, ITY1, ITY2, NN, II
       integer, dimension(:), allocatable::IND, IND2, NT, FLAG
       integer, dimension(:,:),allocatable::TGT

             !$$--- to find out the changed site
              allocate(IND(Cluster1%NPRT),IND2(Cluster1%NPRT), NT(Cluster1%NPRT), FLAG(Cluster1%NPRT), TGT(Cluster1%NPRT,MXNB))
              IND  = 0
              TGT  = 0
              STAT = 0

              !$$--- to generate the potential jump table
              call CompareTwoClusters(Cluster1, Cluster2, NS, IND, NT, TGT, IND2)
              !if(NS .gt. 0) then
              !   print *, "NCS", NS
              !   do I=1, NS
              !      print *, "IND...", IND(I), NT(I), Cluster1%IND(IND(I)), Cluster1%PTYP(IND(I))
              !      do J=1, NT(I)
              !         print *, "TGT J", IND(TGT(I,J)), Cluster1%IND(IND(TGT(I,J))), Cluster1%PTYP(IND(TGT(I,J)))
              !      end do
              !   end do
              !   pause
              !end if
              !$$--- to generate the events table
               NE   = 0
               IS1  = 0
               IS2  = 0

               !$$--- we first seach the site has only one transition neighbor.
               !$$    and the TYP of FROM site is the same as of TO site, corresponding to
               !$$    JUMP event
               FLAG = 0
               do I=1, NS
                  if(FLAG(I) .gt.0) cycle
                  if(NT(I)  .gt.1) cycle
                  ID1 =  Cluster1%IND(IND(I))
                  ITY1 =  Cluster1%PTYP(IND(I))
                  do J=1, NT(I)
                     if(FLAG(TGT(I,J)) .gt. 0) cycle
                     ID2  = Cluster1%IND(IND(TGT(I,J)))
                     ITY2 = Cluster1%PTYP(IND(TGT(I,J)))

                        NE  = NE + 1
                        IS1(NE)   = IND(I)
                        IS2(NE)   = IND(TGT(I,J))
                        EVENT(NE) = mp_EVENT_EXCH
                        FLAG(TGT(I,J))   = 1
                        FLAG(I) = 1
                        exit
                  end do
               end do
               !print *, "NE1 ",NE,  IS1(1:NE), IS2(1:NE)
               !$$--- we then seach the site has more than one transition neighbor
               !$$    also the TYP of FROM site is the same as of TO site
               do I=1, NS
                  if(FLAG(I).gt.0) cycle
                  ID1 =  Cluster1%IND(IND(I))
                  ITY1 =  Cluster1%PTYP(IND(I))
                  do J=1, NT(I)
                     if(FLAG(TGT(I,J)) .gt. 0) cycle
                     ID2  = Cluster1%IND(IND(TGT(I,J)))
                     ITY2 = Cluster1%PTYP(IND(TGT(I,J)))
                        NE  = NE + 1
                        IS1(NE)   = IND(I)
                        IS2(NE)   = IND(TGT(I,J))
                        EVENT(NE) = mp_EVENT_EXCH
                        FLAG(TGT(I,J))   = 1
                        FLAG(I) = 1
                        exit
                  end do
               end do
               !print *, "NE2 ",NE, EVENT(NE), IS1(1:NE), IS2(1:NE)
               !print *, "FLAG", FLAG

               !$$--- NOTE:
               !$$         Because, in CompareTwoClusters, only the different sites in CLUSTER1
               !$$         are linked. There are cases, 2 SIAs (PTYP=2) in CLUSTER1 changed
               !$$         to two SIAs (PTYP=1 + PTYP=3) in CLUSTER2. Such case are not
               !$$        linked in CompareTwoClusters. We still need to process such sites.
               do I=1, NS
                  if(FLAG(I).gt.0) cycle
                  ID1  =  Cluster1%IND(IND(I))
                  ITY1 =  Cluster1%PTYP(IND(I))
                  NN   = m_SiteNeighbor%KVOIS(ID1)
                  do J=1, NS
                     if(FLAG(J) .gt. 0) cycle
                     !$$--- NOTE: different from above, here we check the cluster2
                     ID2  = Cluster2%IND(IND2(J))
                     ITY2 = Cluster2%PTYP(IND2(J))
                     !print *, "here", ID1, ID2, ITY1, ITY2
                     if(any(m_SiteNeighbor%INDI(ID1,1:NN) .eq. ID2) .and. (ITY1.ne.ITY2) )then
                        NE  = NE + 1
                        IS1(NE)   = IND(I)
                        IS2(NE)   = IND(J)
                        EVENT(NE) = mp_EVENT_COMB
                        FLAG(J)   = 1
                        FLAG(I)   = 1
                        exit
                     end if
                  end do
               end do
               !print *, "NE3 ",NS, NE, EVENT(NE), IS1(1:NE), IS2(1:NE)

               !$$--- there are cases, there is a long jump
               !$$    we still need to pare such sites.
                do I=1, NS
                  if(FLAG(I).gt.0) cycle
                  ID1  =  Cluster1%IND(IND(I))
                  ITY1 =  Cluster1%PTYP(IND(I))
                  NN   = m_SiteNeighbor%KVOIS(ID1)
                  do J=1, NS
                     if(FLAG(J) .gt. 0) cycle
                     !$$--- NOTE: different from above, here we check the cluster2
                     ID2  = Cluster2%IND(IND2(J))
                     ITY2 = Cluster2%PTYP(IND2(J))
                     !print *, "here", ID1, ID2, ITY1, ITY2
                     if(ITY1 .eq. ITY2 )then
                        NE  = NE + 1
                        IS1(NE)   = IND(I)
                        IS2(NE)   = IND(J)
                        EVENT(NE) = mp_EVENT_LJUMP
                        FLAG(J)   = 1
                        FLAG(I)   = 1
                        exit
                     end if
                  end do
               end do

              !$$--- if there unpiared link, we marked this site
               do I=1, NS
                  if(FLAG(I).gt.0) cycle
                  NE = NE + 1
                  IS1(NE) = IND(I)
                  IS2(NE) = 0
                  EVENT(NE) = mp_EVENT_UNPAIR
                  STAT = mp_WARNING_UNLINK_SITES
               end do

              !print *, "NE2 ",NE,  IS1(1:NE), IS2(1:NE)
              !--- for debug

               if(NS/2 .ne. NE .or. 2*(NS/2).ne.NS) then
                  STAT = mp_WARNING_UNLINK_SITES
                  !write(*,*)"MDPSCU Warning: Jump link in DefectJumpLink is not in pair"
                  !write(*,*)"                with NS= ", NS, " NE= ", NE
                  !call ONWARNING(gm_OnWarning)
               end if

              deallocate(IND, IND2, NT, FLAG, TGT)
             return
  end subroutine DefectJumpLink
  !**********************************************************************************

  !**********************************************************************************
  subroutine SeperationOfTwoDefectClusters(Cluster1, Cluster2, sep)
  !***  DESCRIPTION: to find out the seperation of two defect clusters. The seperation is
  !                  calculated by expand the first cluster, to chech howmany times
  !                  are need to have the seond cluster in neighbore. The locations of
  !                  defects are defined the lattice site of type not equal to 1.
  !
  !
  !    INPUT:  Clusters1, Cluster2  the clusters
  !
  !    OUTPUT: sep,   the seperation
  !
  implicit none
       !--- dummy variables
       type(PartcleClusterList), intent(in)::Cluster1, Cluster2
       integer::sep
       !--- local variables
        integer::I, J, ID1, ITY1, NN, IP, FLAG, LL, ISQNF, ISQNT, NSQN2
        integer, dimension(:), allocatable::SQN1, SQN2, SFLAG

             !$$--- to find out the changed site
             !$$--- find out the sites int cluster1 different from Cluster2

              NSQN2 = count(Cluster2%PTYP(1:Cluster2%NPRT) .ne. 1)
              allocate(SQN1(m_RefSimBox%NPRT), SFLAG(m_RefSimBox%NPRT), SQN2(NSQN2) )

              SEP =  0
              FLAG = 0
              SFLAG = 0
              IP = 0
              do J = 1,  Cluster2%NPRT
                 if(Cluster2%PTYP(J) .ne. 1) then
                    IP = IP + 1
                    SQN2(IP) = Cluster2%IND(J)
                 end if
              end do

              ISQNF = 1
              ISQNT = Cluster1%NPRT
              do J=1, Cluster1%NPRT
                 SQN1(J) = Cluster1%IND(J)
                 SFLAG(SQN1(J)) = 1
              end do

              LL = 0
              do while(.true.)
                do I=1, NSQN2
                   if(any(SQN1(ISQNF:ISQNT) .eq. SQN2(I)) ) then
                      FLAG = 1
                      exit
                   end if
                end do
                if(FLAG .gt. 0) exit

                LL = LL + 1
                IP = ISQNT
                do I = ISQNF, ISQNT
                   NN =  m_SiteNeighbor%KVOIS(SQN1(I))
                   do J=1, NN
                      ID1 = m_SiteNeighbor%INDI(SQN1(I),J)
                      if(SFLAG(ID1) .gt. 0) cycle
                      IP = IP + 1
                      SQN1(IP) = ID1
                      SFLAG(ID1) = 1
                    end do
                end do

                ISQNF = ISQNT + 1
                ISQNT = IP
                if(ISQNF .gt. ISQNT) exit
              end do
              SEP = LL
              deallocate(SQN1, SFLAG, SQN2 )

             return
  end subroutine SeperationOfTwoDefectClusters
  !**********************************************************************************

  !**********************************************************************************
  subroutine SeperationOfClusterList(Cluster, sep)
  !***  DESCRIPTION: to find out the seperation of two defect clusters. The seperation is
  !                  calculated by expand the first cluster, to chech how many times
  !                  are need to have the seond cluster in neighbore. The locations of
  !                  defects are defined the lattice site of type not equal to 1.
  !
  !
  !    INPUT:  Clusters1, Cluster2  the clusters
  !
  !    OUTPUT: sep,   the seperation
  !
  implicit none
       !--- dummy variables
       type(PartcleClusterList), target, intent(in)::Cluster
       integer, dimension(:,:)::sep
       !--- local variables
        type(PartcleClusterList), pointer::tC1, tC2
        integer::I, J

              sep = 0
              I = 1
              tC1 => Cluster
              do while(associated(tC1))
                  tC2 => tC1%next
                  J = I+1
                  do while(associated(tC2))
                     call SeperationOfTwoDefectClusters(tC1, tC2, sep(I,J))

                     sep(J,I) = sep(I,J)
                     tC2 => tC2%next
                     J = J + 1
                  end do
                  tC1 => tC1%next
                  I = I + 1
               end do

             return
  end subroutine SeperationOfClusterList
  !**********************************************************************************

 !**********************************************************************************
  subroutine CandidateJumpLinks(Cluster, TOFLAG, NC, ND, LINKS)
  !***  DESCRIPTION: to find out number of candidate sites to which the point defect
  !                  may jump to.  The candidate sites are "normal" sites.
  !                  The number of neighboring defects of each candidate sites are
  !                  found.
  !
  !    INPUT:  Clusters,   the clusters
  !            TOFLAG,     the indicating flag of 'normal' sites
  !
  !    OUTPUT: NC,       the number of candidate sites
  !            ND,       the number of point defects
  !            LINKS,    the number of defect sites that the candidate linked to
  !
  implicit none
       !--- dummy variables
       type(PartcleClusterList), intent(in)::Cluster
       integer, intent(in)::TOFLAG
       integer::NC, ND
       integer, dimension(:)::LINKS
       !--- local variables
        integer::I, J, ID1, ID2, NN

            NC = 0
            LINKS = 0
            do I=1, Cluster%NPRT
                if(Cluster%PTYP(I) .eq. TOFLAG) then
                   NC  = NC + 1
                   ID1 = Cluster%IND(I)
                   NN  = m_SiteNeighbor%KVOIS(ID1)
                   do J=1, Cluster%NPRT
                      if(Cluster%PTYP(J) .ne. TOFLAG) then
                         ID2 = Cluster%IND(J)
                         if(any(m_SiteNeighbor%INDI(ID1,1:NN) .eq. ID2)) then
                            LINKS(NC) = LINKS(NC) + 1
                         end if
                      end if
                   end do
                end if
            end do
            ND = Cluster%NPRT - NC

            return
  end subroutine CandidateJumpLinks
  !**********************************************************************************


  !**********************************************************************************
  subroutine Clear()
  !***  PURPOSE:  to deallocate the memories allocated
  !   OUTPUT:
  !
   !--- Local variables
       integer::I

           if(allocated(m_hFile)) then
              do I=1, size(m_hFile)
                 if(m_hFile(I) .gt. 0) then
                   close(m_hFile(I))
                 end if
               end do
               deallocate(m_hFile)
          end if

          call Release_SimMDBox(m_RefSimBox)
          call Clear_NeighboreList(m_SiteNeighbor)


          return
  end subroutine Clear
  !**********************************************************************************


 end module LatticeClusterTrackCommon



