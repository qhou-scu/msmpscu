 !**** DESCRIPTION: _______________________________________________________________________________________
 !                  The program is used to analyze the bond distribution, shape, and movement of defecter clusters.
 !                  in BCC lattice.
 !                  The clutering results generated by Cfg_Track_SIA_GPU will be loaded for the
 !                  configurations of the clusters at difference time.
 !
 !                  SEE ALSO ____________________________________________________________________________
 !                       Cfg_Track_SIA_GPU_Main.F90
 !
 !
 !**** HISTORY:
 !                  version 1st 2015-11 (Hou Qing, Sichuan university)
 !

 module DefectCluster_Analysis_bcc
 use LatticeClusterTrackCommon
 implicit none
        real(KINDDF), parameter, private::m_VECT1(3) = (/1.00D0,  0.00D0,  0.00D0/)
        real(KINDDF), parameter, private::m_VECT2(3) = (/0.00D0,  1.00D0,  0.00D0/)
        real(KINDDF), parameter, private::m_VECT3(3) = (/0.00D0,  0.00D0,  1.00D0/)
        real(KINDDF), parameter, private::m_VECT4(3) = (/1.00D0,  1.00D0,  1.00D0/)
        real(KINDDF), parameter, private::m_EPSLON = 1.D-6
        integer, parameter::mp_VSIZ = 14

 contains

 !**********************************************************************************
  subroutine DefectBondInfo0_BCC(Cluster, BONDS, FLAG)
  !***  DESCRIPTION: to find out shape of the defect cluster. The shape is defined as number
  !                  bonds in directions. 12 intergers are used to describe the shape.
  !                  The first four integers are the number of bonds between LSIAs. The first
  !                  three integers are number of bonds in [2110] drections, the fouth integer
  !                  is the number of off-plane bonds.
  !
  !                  The second four integers are the number of bonds between LSIAs and LVACs
  !                  The third four integers are the number of bonds between  LVACs and LVACs
  !
  !
  !    INPUT:  Clusters,   the clusters
  !
  !
  !    OUTPUT: BONDS,    the array describing the bonds of the clusters
  !            FLAG,     the indicator indicating if the cluster is connectet
  !                      = 0, the cluster is connected
  !                      = 1, the cluster is not conected
  !
  implicit none
       !--- dummy variables
       type(PartcleClusterList), intent(in)::Cluster
       integer, dimension(:)::BONDS
       integer::FLAG
       !--- local variables
        integer::I, J, ID1, ID2, ITY1, ITY2, SH1, SH2, TSP(mp_VSIZ), NN
        real(KINDDF)::RR, DIST, XP0(3), XPP(3), BS(3), HBS(3)


             RR   = m_RefSimBox%RR
             BS   = m_RefSimBox%ZL/RR
             HBS  = C_HALF*BS
             TSP  = 0
             FLAG = 0

                do I=1, Cluster%NPRT
                   if(Cluster%PTYP(I) .le. 0) then
                      ITY1 = mp_SITE_VAC
                   else if(Cluster%PTYP(I) .eq. 1) then
                      ITY1 = mp_SITE_NEIB_NORMAL
                   else
                      ITY1 = mp_SITE_SIA
                   end if
                   if(ITY1 .eq. mp_SITE_NEIB_NORMAL) cycle

                   ID1      = Cluster%IND(I)
                   NN       = m_SiteNeighbor%KVOIS(ID1)
                   XP0(1:3) = m_RefSimBox%XP(ID1, 1:3)/RR
                   do J=I+1, Cluster%NPRT
                      if(Cluster%PTYP(J) .le. 0) then
                         ITY2 = mp_SITE_VAC
                      else if(Cluster%PTYP(J) .eq. 1) then
                         ITY2 = mp_SITE_NEIB_NORMAL
                      else
                         ITY2 = mp_SITE_SIA
                      end if
                      if(ITY2 .eq. mp_SITE_NEIB_NORMAL) cycle

                      ID2      = Cluster%IND(J)
                      XPP(1:3) = m_RefSimBox%XP(ID2, 1:3)/RR - XP0(1:3)
                      if(dabs(XPP(1)) .gt. HBS(1)) &
                         XPP(1) = XPP(1) - DSIGN(BS(1),XPP(1))
                      if(dabs(XPP(2)) .gt. HBS(2)) &
                         XPP(2) = XPP(2) - DSIGN(BS(2),XPP(2))
                      if(dabs(XPP(3)) .gt. HBS(3)) &
                         XPP(3) = XPP(3) - DSIGN(BS(3),XPP(3))

                      if(ITY1 .ne. ITY2) then             !--- for SIA-VAC bounds
                         SH1 = 4
                      else if(ITY1 .eq. mp_SITE_SIA) then !--- for SIA-SIA bond
                         SH1 = 0
                      else                                 !--- for VAC-VAC bound
                         SH1 = 8
                      end if

                      DIST = dsqrt(XPP(1)*XPP(1) + XPP(2)*XPP(2) + XPP(3)*XPP(3))
                      if(dabs(XPP(1)*m_VECT1(1)+XPP(2)*m_VECT1(2)+XPP(3)*m_VECT1(3))/DIST .gt. 0.99) then
                         SH2 = 1
                      else if(dabs(XPP(1)*m_VECT2(1)+XPP(2)*m_VECT2(2)+XPP(3)*m_VECT2(3))/DIST .gt. 0.99) then
                         SH2 = 2
                      else if(dabs(XPP(1)*m_VECT3(1)+XPP(2)*m_VECT3(2)+XPP(3)*m_VECT3(3))/DIST .gt. 0.99) then
                         SH2 = 3
                      else if(dabs(XPP(1)*m_VECT4(1)+XPP(2)*m_VECT4(2)+XPP(3)*m_VECT4(3))/DIST .gt. 0.99) then
                          SH2 = 4
                      else
                          !FLAG = FLAG + 1
                      end if

                      if(any(m_SiteNeighbor%INDI(ID1,1:NN) .eq. ID2) .and. (FLAG.eq.0) ) then
                         TSP(SH1 + SH2) = TSP(SH1 + SH2) + 1
                      end if
                   end do
                end do
                BONDS(1:mp_VSIZ) = TSP(1:mp_VSIZ)

             return
  end subroutine DefectBondInfo0_BCC
  !**********************************************************************************

 !**********************************************************************************
  subroutine DefectBondInfo1_BCC(Cluster, BONDS, FLAG)
  !***  DESCRIPTION: to find out shape of the defect cluster. The shape is defined as number
  !                  bonds in directions. 12 intergers are used to describe the shape.
  !                  The first four integers are the number of bonds between LSIAs. The first
  !                  three integers are number of bonds in [2110] drections, the fouth integer
  !                  is the number of off-plane bonds.
  !                  The difference between this and  DefectBondInfo0_BCC is that the output
  !                  the number of bonds are reordered in direcsing order.
  !
  !                  The second four integers are the number of bonds between LSIAs and LVACs
  !                  The third four integers are the number of bonds between  LVACs and LVACs
  !
  !
  !    INPUT:  Clusters,   the clusters
  !
  !
  !    OUTPUT: BONDS,    the array describing the bonds of the clusters
  !
  implicit none
       !--- dummy variables
       type(PartcleClusterList), intent(in)::Cluster
       integer, dimension(:)::BONDS
       integer::FLAG
       !--- local variables
        integer::I, J, TSP(mp_VSIZ), ISWAP(4)


                call DefectBondInfo0_BCC(Cluster, TSP, FLAG)

                !$$ --- sort the number in decresing order
                !$$     sort the SIA-SIA bond
                ISWAP = 0
                do I=1, 3
                   do J=1,3
                      if(TSP(I).gt.ISWAP(J)) then
                         ISWAP(J+1:4) = ISWAP(J:3)
                         ISWAP(J) = TSP(I)
                         exit
                      end if
                    end do
                end do
                ISWAP(4) = TSP(4)
                BONDS(1:4) = ISWAP(1:4)

                !$$     sort the SIA-VAC bond
                ISWAP = 0
                do I=1, 3
                   do J=1,3
                      if(TSP(I+4).gt.ISWAP(J)) then
                         ISWAP(J+1:4) = ISWAP(J:3)
                         ISWAP(J) = TSP(I+4)
                         exit
                      end if
                    end do
                end do
                ISWAP(4) = TSP(8)
                BONDS(5:8) = ISWAP(1:4)

                !$$     sort the VAC-VAC bond
                ISWAP = 0
                do I=1, 3
                   do J=1,3
                      if(TSP(I+8).gt.ISWAP(J)) then
                         ISWAP(J+1:4) = ISWAP(J:3)
                         ISWAP(J) = TSP(I+8)
                         exit
                      end if
                    end do
                end do
                ISWAP(4) = TSP(12)
                BONDS(9:12) = ISWAP(1:4)

             return
  end subroutine DefectBondInfo1_BCC
  !**********************************************************************************

  !**********************************************************************************
  subroutine DefectBondInfo_BCC(Clusters, SNUM, VNUM, ANUM, BONDS, FLAG)
  !***  DESCRIPTION: to find out shape of the defect cluster. The shape is defined as number
  !                  bonds in directions. 12 intergers are used to describe the shape.
  !                  The first four integers are the number of bonds between LSIAs. The first
  !                  three integers are number of bonds in [2110] drections  in a decreasing order
  !                  , the fouth integer is the number of off-plane bonds.
  !
  !                  The second four integers are the number of bonds between LSIAs and LVACs
  !                  The third four integers are the number of bonds between  LVACs and LVACs
  !
  !
  !    INPUT:  Clusters,   the clusters
  !
  !
  !    OUTPUT: SNUM,     the number of SIA sites
  !            VNUM,     the number of vacancies
  !            ANUM,     the number of SIAs
  !            BONDS,    the array describing the bond distribution of the clusters
  !
  implicit none
       !--- dummy variables
       type(PartcleClusterList), target, intent(in)::Clusters
       integer, dimension(:)::BONDS, SNUM, VNUM, ANUM
       integer::FLAG
       !--- local variables
        integer::IC, FLAG0
        type(PartcleClusterList), pointer::curC

             curC => Clusters
             IC = 0
             SNUM = 0
             VNUM = 0
             ANUM = 0
             BONDS = 0
             FLAG  = 0
             do while(associated(curC))
                !-- to extract the shape for one cluster
                IC  = IC + 1
                 SNUM(IC) = count(curC%PTYP .ge. 2)
                 VNUM(IC) = count(curC%PTYP .eq. 0)
                 ANUM(IC) = sum(curC%PTYP, mask= (curC%PTYP .ge. 2))
                 call DefectBondInfo1_BCC(curC, BONDS((IC-1)*mp_VSIZ+1:IC*mp_VSIZ), FLAG0)
                 FLAG = FLAG + FLAG0
                !--- move to next cluster
                curC => curC%next
             end do
             !print *, 'here', IC, CS
             return
  end subroutine DefectBondInfo_BCC
 !**********************************************************************************

  !**********************************************************************************
  subroutine DefectJumpAnalysis(Cluster1, Cluster2, NE, EVENT, DEFTYP, DIR, NNS, NNV, STAT)
  !***  DESCRIPTION: to analtse jumping event from cluster 1 to cluster2
  !                  for BCC.
  !
  !    INPUT:  Clusters1, Cluster2  the clusters
  !
  !
  !    OUTPUT: NE,     the number of events
  !            EVENT,  the type of events
  !            DEFTYP, the type of defect
  !            DIR,    the direction of jumping
  !            NNS,    the number of LSIA near the non-defect sites that jumps occurs
  !            NNV,    the number of LVAC near the non-defect sites that jumps occurs
  !
  implicit none
       !--- dummy variables
       type(PartcleClusterList), intent(in)::Cluster1, Cluster2
       integer::NE, STAT
       integer, dimension(:):: EVENT, DEFTYP, DIR,  NNS, NNV
       !--- local variables
       integer, dimension(:), allocatable::IS1, IS2
       integer::I, J, ID1, ID2, ITY1, ITY2, NN, IT
       real(KINDDF)::RR, DIST, XP0(3), XPP(3), BS(3), HBS(3)

             RR   = m_RefSimBox%RR
             BS   = m_RefSimBox%ZL/RR
             HBS  = C_HALF*BS
             EVENT = 0
             DIR   = 0
             NNS   = 0
             NNV   = 0
             !--- to extract the jumping sites
             allocate(IS1(Cluster1%NPRT), IS2(Cluster1%NPRT) )
             call DefectJumpLink(Cluster1, Cluster2, mp_VSIZ, NE, IS1, IS2, EVENT, STAT)

                do I=1, NE
                   if(EVENT(I) .eq. mp_EVENT_UNPAIR) then
                      if(Cluster1%PTYP(IS1(I)) .eq. 0) then
                         DEFTYP(I) = mp_SITE_VAC
                      else if(Cluster1%PTYP(IS1(I)) .gt. 1 ) then
                         DEFTYP(I) = mp_SITE_SIA
                      else
                         DEFTYP(I) = mp_SITE_NEIB_NORMAL
                      end if
                      cycle
                   end if

                   !****** to identify the jumping direction
                   !--- first, to identify the type of the jumping defect
                   if(Cluster1%PTYP(IS1(I)) .eq. 0 .or. Cluster1%PTYP(IS2(I)) .eq. 0) then
                      DEFTYP(I) = mp_SITE_VAC
                   else if(Cluster1%PTYP(IS1(I)) .gt. 1 .or.  Cluster1%PTYP(IS2(I)) .gt. 1) then
                      DEFTYP(I) = mp_SITE_SIA
                   end if

                   !--- get the position of first site
                   ID1      = Cluster1%IND(IS1(I))
                   XP0(1:3) = m_RefSimBox%XP(ID1, 1:3)/RR

                   !--- get the position of second site
                   ID2      = Cluster1%IND(IS2(I))
                   XPP(1:3) = m_RefSimBox%XP(ID2, 1:3)/RR - XP0(1:3)

                   if(dabs(XPP(1)) .gt. HBS(1)) &
                       XPP(1) = XPP(1) - DSIGN(BS(1),XPP(1))
                   if(dabs(XPP(2)) .gt. HBS(2)) &
                       XPP(2) = XPP(2) - DSIGN(BS(2),XPP(2))
                   if(dabs(XPP(3)) .gt. HBS(3)) &
                       XPP(3) = XPP(3) - DSIGN(BS(3),XPP(3))

                   DIST = dsqrt(XPP(1)*XPP(1) + XPP(2)*XPP(2) + XPP(3)*XPP(3))
                   if(dabs(XPP(1)*m_VECT1(1)+XPP(2)*m_VECT1(2)+XPP(3)*m_VECT1(3))/DIST .gt. 0.99) then
                          DIR((I-1)*4+1) = 1
                   else if(dabs(XPP(1)*m_VECT2(1)+XPP(2)*m_VECT2(2)+XPP(3)*m_VECT2(3))/DIST .gt. 0.99) then
                      DIR((I-1)*4+2) = 1
                   else if(dabs(XPP(1)*m_VECT3(1)+XPP(2)*m_VECT3(2)+XPP(3)*m_VECT3(3))/DIST .gt. 0.99) then
                          DIR((I-1)*4+3) = 1
                   else if(dabs(XPP(1)*m_VECT4(1)+XPP(2)*m_VECT4(2)+XPP(3)*m_VECT4(3))/DIST .gt. 0.99) then
                          DIR((I-1)*4+4) = 1
                   end if

                   !****** to identify the number of LSIA and LVAC near the non-defect site
                   !--- first, to identify the non-defect site invlove in the jumping
                   if(Cluster1%PTYP(IS1(I)) .eq. 1) then
                      IT = IS1(I)
                   else
                      IT = IS2(I)
                   end if
                  !--- to find how many LSIA nearby
                   ID1 = Cluster1%IND(IT)
                   NN  = m_SiteNeighbor%KVOIS(ID1)
                   do J=1,  Cluster1%NPRT
                      if(Cluster1%PTYP(J) .gt. 1) then
                         if(any(m_SiteNeighbor%INDI(ID1,1:NN) .eq. Cluster1%IND(J)) ) then
                            NNS(I) = NNS(I) + 1
                         end if
                      end if
                   end do

                   do J=1,  Cluster1%NPRT
                      if(Cluster1%PTYP(J) .le. 0) then
                         if(any(m_SiteNeighbor%INDI(ID1,1:NN) .eq. Cluster1%IND(J)) ) then
                            NNV(I) = NNV(I) + 1
                         end if
                      end if
                   end do


                end do !--- end loop for event
                return

   end subroutine DefectJumpAnalysis

!**********************************************************************************


 end module DefectCluster_Analysis_bcc


 !**********************************************************************************
